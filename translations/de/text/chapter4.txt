    Kapitel 4

    Rate die Zahl

In diesem Kapitel lernst du:

•   import Kommandos
•   Module
•   while Kommandos
•   Bedingungen
•   Blöcke
•   Boolean-Datentypen
•   Vergleichsoperatoren
•   Den Unterschied zwischen = und ==
•   if Kommandos
•   Das break Kommando
•   Die str(), int() und float() Funktionen
•   Die random.randint() Funktion

Das "Rate die Zahl" Spiel

In diesem Kapitel wirst du ein "Rate die Zahl" Spiel schreiben. Der Computer wird an eine Zufallzahl zwischen 1 und 20 denken und dich bitten, sie zu erraten. Der Computer wird dir bei jedem Tipp, den du abgibst, sagen ob er zu hoch oder zu niedrig war. Du gewinnst wenn du die Zahl innerhalb von sechs Versuchen erraten kannst.

"Rate die Zahl" ist interessant zu programmieren weil es Zufallszahlen, Schleifen und Benutzereingaben in einem ziemlich kurzen Programm verwendet. Du wirst lernen, wie man Werte in unterschiedliche Datentypen umwandelt (und warum das notwendig ist). Weil unser Programm ein Spiel ist, nennen wir den Benutzer Spieler, aber "Benutzer" wäre auch ok.

Beispiel Lauf zu Rate die Zahl

So sieht das Programm für den Spieler aus, wenn es ausgeführt wird. Der Text den der Spieler eintippt ist fett geschrieben.

Hallo! Was ist dein Name?
Albert
Also, Albert, ich denke an eine Zahl zwischen 1 und 20.
Los, rate.
10
Los, rate.
Dein Tipp ist zu hoch.
Los, rate.
2
Dein Tipp ist zu niedrig.
Los, rate.
4
Gut gemacht, Albert! Du hast meine Zahl in 3 Zügen erraten.





Der Quellcode von "Rate die Zahl"

Öffne ein neues Dateieditorfenster indem auf Datei►Neues Fenster klickst. Tippe in dem neu erschienen leeren Fenster  den Quellcode ein und speichere die Datei dann unter zahlenRaten.py ab. Drücke F5 um das Programm auszuführen. Wenn du den Programmcode eintippst muss du besonders auf die Leerzeichen am Beginn der Zeilen achten. Manche Zeilen haben vier und einige sogar acht Leerzeichen am Zeilenanfang.

Hier ist der Quellcode von "Rate dir Zahl". Gib auf die Leerzeichen vor manchen der Zeilen acht, wenn du den Quellcode in den Dateieditor eingibst. Manche der Zeilen haben vier, manche haben acht Leerzeichen.

WICHTIGER HINWEIS! Die Programme in diesem Buch können nur in Python 3 ausgeführt werden, nicht in Python 2. Wenn IDLE startet sollte es so etwas wie "Python 3.4.2" oben anzeigen. Du kannst Python 2 und Python 3 zur selben Zeit auf deinem Computer installiert haben. Um Python 3 herunter zu laden geh zu http://python.org/download/.

Wenn du nach dem Eintippen des Codes Fehlermeldungen bekommst, verwende das Online diff Werkzeug unter http://invpy.com/de/diff/zahlenRaten um deinen Code mit dem Code aus dem Buch zu vergleichen.

zahlenRaten.py

 1.  # Das ist ein Zahlenratespiel.
 2.  import random
 3.
 4.  abgegebenTipps = 0
 5.
 6.  print('Hallo! Was ist dein Name?')
 7.  meinName = input()
 8.
 9.  zahl = random.randint(1, 20)
10.  print('Also, ' + meinName + ', ich denke an eine Zahl zwischen 1 und 20.')
11.
12.  while abgegebenTipps < 6:
13.      print('Los, rate.') # Vor print sind vier Leerzeichen.
14.      tipp = input()
15.      tipp = int(tipp)
16.
17.      abgegebenTipps = abgegebenTipps + 1
18.
19.      if tipp < zahl:
20.          print('Dein Tipp ist zu niedrig.') # Hier sind acht Leerzeichen vor print.
21.
22.      if tipp > zahl:
23.          print('Dein Tipp ist zu hoch.')
24.
25.      if tipp == zahl:
26.          break
27.
28.  if tipp == zahl:
29.      abgegebenTipps = str(abgegebenTipps)
30.      print('Gut gemacht, ' + meinName + '! Du hast meine Zahl in ' + abgegebenTipps + ' Zügen erraten!')
31.
32.  if tipp != zahl:
33.      zahl = str(zahl)
34.      print('Nene. Die Nummer an die ich gedacht habe war ' + zahl)

Schauen wir uns den Code Zeile für Zeile an um zu verstehen wie das Programm funktioniert.

import Befehle

 1.  # Das ist ein Zahlenratespiel.
 2.  import random

Die erste Zeile ist ein Kommentar. Python ignoriert alles nach dem # Zeichen. Diese Zeile dient nur dazu, uns daran zu erinnern was das Programm macht.

#TODO: Check that we really already know that.
Zeile Zwei ist ein import Befehl. Befehle sind Instruktionen die eine Handlung durchführen aber nicht wie Ausdrücke ausgewertete werden können. Wir haben bereits Befehle kennengelernt: Zuweisungsbefehle speichern einen Wert in einer Variable.

Python bringt viele Funktionen mit, ein großer Teil davon befindet sich aber in getrennten Programmen die Module genannt werden. Um diese Funktionen zu verwenden musst du die zugerhörigen Module mit einem import Befehl in dein Programm importieren.

Zeile 2 importiert das modul mit dem Namen random (engl. zufällig) damit das Programm random.randint() aufrufen kann.Diese Funktion liefert die Zufallszahlen die der Benutzer erraten muss.

4. abgegebeneTipps = 0

Diese Zeile erstellt eine neue Variable mit dem Namen agbgebeneTipps. In dieser Variable wird die Anzahl der Tipps, die der Spieler abgegeben hat, gespeichert. Wir setzen die Variable hier auf den Integer 0 weil der Spieler noch keinen Tipp abgegeben hat.

6.  print('Hallo! Was ist dein Name?')
7.  meinName = input()

Zeilen 6 und 7 sind wie im Hallo Welt Programm aus Kapitel 3. Programmierer verwenden Programmcode aus alten Programmen oft wieder um sich Arbeit zu sparen.

Zeile 6 ist ein Funktionsaufruf, hier wird die print() Funktion aufgerufen. Erinner dich, dass ein Funktionsaufruf wie ein Miniprogramm in deinem Programm ist. Wenn dein Programm eine Funktion aufruft, dann führt es dieses Miniprogramm aus. Der Programmcode in der print() Funktion zeigt den Text, der im String Argument übergeben wird, auf dem Bildschirm an.

Zeile 7 lässt den Benutzer seinen Name eingeben und speichert die Eingabe in der Variable meinName. (Der String muss nicht wirklich der Name des Spieler sein sondern ist einfach genau der String, den der Spieler eintippt. Computer sind dumm und folgen einfach stur deinen Befehlen.)

Die random.randint() Funktion

9.  zahl = random.randint(1, 20)

Zeile 9 ruft eine  neue Funktion mit dem Namen randint() auf und speichert den Rückgabewert in zahl ab. Funktionsaufrufe können Teil eines Ausdrucks sein, weil sie zu einem Wert ausgewerteten haben.

Die randint() Funktion wird vom random Modul zur Verfügung gestellt wird muss ihm random vorangestellt werden (Vergiss nicht auf den Punkt!) um Python mitzuteilen, dass die Funktion randint() im Modul random zu finden ist.

Die randint() Funktion wird eine Zufallszahl zwischen (und inklusive) den beiden übergebenen Integerargumenten zurückgeben. Zeile 9 übergibt 1 und 20 zwischen den Klammern die dem Funktionsnamen folgen, unterteilt durch ein Komma. Die Zufallszahl die von randint() zurück gibt wird einer Variable namens zahl gespeichert; das ist die geheime Zahl die der Spieler erraten muss.

Wechsle für einen Moment in die interaktive Shell und gib import random ein, um das random modul zu importieren. Dann tippe random.randint(1,20) und drücke die Eingabetaste um zu sehen zu was der Funktionsaufruf ausgewertet wird. Wenn du die Eingabe wiederholst wird der Funktionsaufruf wahrscheinlich zu einer anderen Zahl ausgewertet. Die randint() Funktion gibt jedesmal irgendeine Zufallszahl zurück, genau so wie Würfel bei jedem Wurf eine Zufallszahl zurück geben.

>>> import random
>>> random.randint(1, 20)
12
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
3
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
7

Verwende die randint() Funktion wenn du einen Teil deines Spiels zufällig statt vorhersagbar zu machen. Viele Spiele brauchen Zufälligkeit - wie zum Beispiel in Brettspiele, in denen aus diesem Grund oft Würfel verwendet werden.

Mit den Argumenten der randint Funktion kannst du den Bereich aus dem die Zufallszahlen Gewählt werden einstellen. Gib - zum Beispiel - random.randint(1,4) ein um nur ganze Zahlen von 1 bis 4 zurück zu bekommen. Oder versuche random.randint(1000,2000) um ganze Zahlen zwischen 1000 und 2000 zu erhalten.

Probier die Beispiele in der Eingabezeile ein. Natürlich wirst du andere Ergebnisse erhalten, wenn du random.randint() ausführst (es sind ja Zufallszahlen).

>>> random.randint(1, 4)
3
>>> random.randint(1000, 2000)
1294

Du kannst den Programmcode des Spiels leicht abändern um sein Verhalten zu ändern. Wenn du Zeilen 9 und 10:

 9. zahl = random.randint(1, 20)
10. print('Also, ' + meinName + ', ich denke an eine Zahl zwischen 1 und 20.')

... folgendermaßen abänderst:

 9. zahl = random.randint(1, 100)
10. print('Also, ' + meinName + ', ich denke an eine Zahl zwischen 1 und 100.')

Jetzt wird der Computer an eine Zahl zwischen 1 und 100 statt an eine zwischen 1 und 20 denken. Durch ändern der Zeile 9 wird der Zahlenbereich der Zufallszahlen geändert, vergiss dabei nicht auch Zeile 10 zu ändern damit das Spiel dem Spieler den geänderten Zahlenbereich mitteilt.

Hallo Spieler

10. print('Also, ' + meinName + ', ich denke an eine Zahl zwischen 1 und 20.')

In Zeile 10 heißt die print() Funktion den Spieler willkommen und teilt ihm mit, dass der Computer an eine Zufallszahl denkt.

Es sieht so aus als wäre mehr als ein string Argument in Zeile 10, aber schau dir die Zeile genau an. Die Pluszeichen verketten die drei strings zu einem einzigen. Und das ist das einzige string Argument das and die print() Funktion übergeben wird. Wenn du genau schaust, siehst du, dass die Kommas innerhalb der Anführungszeichen und damit Teile der strings selbst sind.

Schleifen

12. while abgegebenTipps < 6:

Zeile 12 ist ein while Befehl, das den Beginn einer while Schleife anzeigt. Schleifen lassen dich einen immer wieder ausführen. Wir müssen jedoch ein paar andere Konzepte durchgehen, bevor wir uns Schleifen genauer ansehen. Diese Konzepte sind Blocks, Booleans, Vergleichsoperatoren, Bedingungen und das while Statement.

Blöcke

Mehrere Zeilen Programmcode können in einem Block gruppiert werden. Jede Zeile in einem Block hat die selbe minimale Einrückung. An der Anzahl an Leerzeichen am Anfang der Zeile siehst du wo ein Block beginnt. Das ist die Einrückung (engl: indentation) der Zeile.


Ein Block beginnt wenn die Einrückung der Zeile sich erhöht (normalerweise um vier Leerzeichen). Alle folgenden Zeilen, die auch gleich weit Eingerückt sind, sind auch Teil des Blocks. Der Block endet, sobald eine der Zeilen, die eine geringere Einrückung - so wie der darüber liegende Block hat, beginnt. Das heißt, dass ein Block innerhalb eines anderen Blocks liegt. Abbildung 4-1 ist ein Diagramm des Codes, in dem die Blocks angezeichnet und durchnummeriert sind. Die Leerzeichen sind als schwarze Quadrate eingezeichnet um sie besser zählbar zu machen.


In Abbildung 4-1, in Zeile 12 gibt es keine Einrückung daher ist diese Zeile nicht in einem Block. Zeile 13 hat einem Einrückung von vier Leerzeichen. Da diese Einrückung eine größer ist als die der vorigen beginnt die hier ein neuer Block. Der Block ist in Abbildung 4-1 mit (1) bezeichnet. Dieser Block geht wird weiter gehen, bis eine Zeile ohne Einrückung (so wie bevor der Block gebonnen hat). Leere Zeilen werden ignoriert.

Zeile 20 hat eine Einrückung von acht Leerzeichen. Acht Leerzeichen sind mehr als vier Leerzeichen, was wiederum einen neuen Block beginnt. Dieser Block ist in Abbildung 4-1 mit (2) gekennzeichnet. Dieser Block ist in einem anderen Block.


Abbildung 4-1: Blöcke und ihre Einrückung. Die schwarzen Quadrate zeigen Leerzeichen an.

Zeile 22 hat nur vier Einrückungen. Die Einrückung ist also weniger geworden, du daher ist der Block beendet. Zeile 20 ist die einzige Zeile in diesem Block. Zeile 22 ist im selben Block wie die anderen Zeilen mit vier Leerzeichen.

Zeile 23 erhöht die Einrückung wieder auf 8 Leerzeichen, es beginnt also wieder eine neuer Block. Es ist in Abbildung 4-1 mit (3) bezeichnet.

Zusammengefasst, Zeile 12 ist in keinem Block. Zeilen 13 bis 23 sind alle in einem Block (markiert als Block 1).  Zeile 20 ist einem Block innerhalb eines Blocks (markiert als Block 2). Und Zeile 23 ist die einzige Zeile in einem weiterem Block in einem Block (markiert als Block 3).

Der Boolean Datentyp

Der Boolean Datentyp kann nur zwei Werte haben: True (engl. für wahr) oder False (engl. für falsch). Diese Werte müssen mit einem Großem "T" oder "F" geschrieben werden. Der Rest der Namen der Werte muss klein geschrieben sein. Du wirst Boolean Werte (auch bools genannt) mit Vergleichsoperatoren verwenden um Bedingungen zu bilden. (Bedingungen werden später erklärt.)

Du kannst bools natürlich auch in Variablen speichern:

>>> Speck = True
>>> Eier = False



Die Datentypen die bis jetzt vorgestellt wurden sind integer, strings und jetzt bools. Jeder Wert in Python gehört zu einem Datentyp.

Vergleichsoperatoren

Zeile 12 enthält ein while statement:

12. while abgegebenTipps < 6:

Der Ausdruck der dem while Schlüsselwort folgt ( der abgegebenTipps < 6 Teil) enthält zwei Werte ( der Wert in der Variable abgegebeneTipps, und den integer Wert 6) verbinden mit einem Operator (das < Zeichen, das "kleiner als" Zeichen). Das < Zeichen ist ein Vergleichsoperator.

Vergleichsoperatoren vergleichen zwei Werte und werden entweder zu True oder False Boolean Werte ausgewertet. Eine Liste von allen Vergleichoperatoren findest du in Tabelle 4-1.

Tabelle 4-1: Vergleichsoperatoren
Operator Zeichen Operator Name
<	Kleiner als
>	Größer als
<=	Kleiner als oder gleich
>=	Mehr als oder gleich
==	Gleich
!=	Ungleich

Du kennst jetzt also schon die mathematischen Operatoren +, -, * und /. Wie alle Operatoren werden die Vergleichsoperatoren mit Werten verknüpft um Ausdrücke wie abgegebenTipps < 6 zu bilden.

Bedingungen

Eine Bedingung ist ein Ausdruck der zwei Werte mit einem Vergleichsoperator verbindet (so wie < oder >) und zu einem Boolean Wert auswertet. Bedingung ist nur ein anderer Name für Ausdruck der zu True oder False ausgwertet wird. Bedingungen werden in while Statements verwendet (und an ein paar anderen Befehlen, wie später erklärt wird.)

Die Bedingung abgegebeneTipps < 6 fragt, zum Beispiel, "Ist der Wert der in abgegebeneTipps gespeichert ist kleiner als die Zahl 6?" Wenn ja, dann wir die Bedingung zu True ausgewertet, wenn nein, dann wir sie zu False ausgewertet.

In unserem "Rate die Zahl" Programm wird in Zeile 4 der Wert 0 in abgegebeneTipps gespeichert. Weill 0 weniger als 6 ist, wird diese Bedingung zu True ausgewertet. Die Ausertung würde in etwa so aussehen:

abgegebeneTipps < 6
             ▼
           0 < 6
             ▼
            True
Experimente mit Booleans, Vergleichsoperatoren, und Bedingungen

Gib den folgenden Ausdruck in der Eingabezeile ein und sieh dir an, zu welchen Booleans sie ausgewertet werden:

>>> 0 < 6
True
>>> 6 < 0 
False
>>> 50 < 10 
False
>>> 10 < 11
True
>>> 10 < 10
False

Die Bedingung 0 < 6 wird zu True ausgewertet weil die Zahl 0 kleiner als die Zahl 6 ist. Umgekehrt ist natürlich 6 nicht kleiner als 0 also ergibt 6 < 0 False. 50 ist nicht weniger als 10 also ist 50 < 10 False. 10 ist weniger als 11 also ist 10 < 11 True.

10 < 10 wird zu False ausgewertet weil 10 nicht kleiner als 10 ist sonder gleich groß. Wenn Alice und Bertl gleich groß sind, dann würdest du auch nicht sagne, dass Alice größer als Bertl ist oder dass Bertl kleiner als Alice ist. Beide Aussagen wären falsch.

Probier jetzt aus, wie die folgenden Ausdrücke in der Eingezeile ausgewertet werden:

>>> 10 == 10
True
>>> 10 == 11
False
>>> 11 == 10
False
>>> 10 != 10
False
>>> 10 != 11
True
>>> 'Hallo' == 'Hallo'
True
>>> 'Hallo' == 'Tschüss'
False
>>> 'Hallo' == 'HALLO'
False
>>> 'Tschüss' != 'Hallo'
True

Der Unterschied zwischen = und ==

Der Zuweisungsoperator (=) und der "ist gleich" Vergleichsoperator (==) sind leicht zu verwechseln. Das einfache Gleichzeichen (=) wird in Zuweisungsausdrücken verwendet um einen Wert in einer Variable zu speichern, das Doppelte Gleichzeichen (==) wird verwendet um zu testen ob zwei Werte gleich sind. Die beiden Operatoren können leicht vertauscht werden. 

Es gibt eine Eselsbrücke um die beiden Operatoren auseinander zu halten:  Der "ist gleich" Verfleichsoperator (==) hat wie der "nicht gleich" Operator (!=) zwei Zeichen hat.

String und integer Werte können niemals gleich zueinander sein. Hier sind ein zwei Beispiele dazu, die du in der Eingabezeile versuchen kannst:

>>> 42 == 'Hallo'
False
>>> 42 != '42'
True

Schleifen mit while Befehlen

Der while (engl. während) Befehl zeigt den Beginn einer Schleife an. Schleifen führen den selben Code wiederholt aus. Wenn die Ausführung den while Befehl erreicht, dann wird die Bedingungen neben dem while Befehl ausgewertet. Wenn die Bedingung True ist, dann wird der Block unter der while Bedingung ausgeführt. Dieser Block heisst while Block. (In diesem Program beginnt der while Block in Zeile 13.) Wenn die Bedingung zu False ausgewertet wird, dann wird der while Block übersprungen und die Ausführung in der ersten Zeile nach dem while Block fortgesetzt.  In Rate die Zahl ist Zeile 28 die erste Zahl nach dem while Block.

Ein while Befehl hat immer einen Doppelpunkt : nach der Bedingung. Befehle die mit einem Doppelpunkt enden erwarten, dass in der nächsten Zeile ein neuer Block beginnt.

12. while abgegebenTipps < 6:

Abbildung 4-2: Die Bedingung der while Schleife

Abbildung 4-2 zeigt wie den Verlauf der Ausführung je nach dem Wert der Bedingung. Wenn die Bedingung zu True ausgewertet wird (wie sie es beim ersten Durchlaufen des Programms der Falls ist, weil der Wert von abgegebeneTipps 0 ist), dann wird nach dem while Befehl der while Block beginnend mit Zeile 13 ausgeführt. Wenn das Programm das Ende des while Blocks erreicht, dann wird es nicht zur Zeile darunter weiter gehen sondern wieer zurück zum while Statement (Zeile 12) springen und diese auswerten. Wie beim ersten Mal wird die Bedingung ausgewertet, wenn sie zu True evaluiert wird, dann wird anschließend wieder der while Block ausgeführt. Jedes durchlaufen der Schleife wird Iteration genannt.

Die while Schleife funktionier folgendermaßen: So lange die Bedingung True ist, wird das Programm weiter immer wieder den while Block ausführen bis Bedingung zum ersten Mal False ist. Den while Befehl könnten man in Worten auch so ausdrücken: "während (while) diese Bedingung wahr (True) ist, führe den Code im folgenden Block aus".

Der Spieler rät

13.    print('Los, rate.') # Vor print sind vier Leerzeichen.
14.    tipp = input()

Zeilen 13 bis 17 fordern den Spieler auf eine Zahl zu raten und diese einzugeben. Diese Zahl wird in der Variable tipp gespeichert. 

Zahlen mit den Funktionen int(), float() und str() umwandeln

15.    tipp = int(tipp)

Zeile 15 ruft eine neue Funktion mit dem Namen int() auf. Die int() Funktion nimmt ein Argument und gibt den Integerwert zu diesem Argument zurück. Versuche es mit dem folgenden Befehlen in der Eingabgezeile:

>>> int('42')
42
>>> 3 + int('2')
5

Der Funktionsaufruf int('42') gibt den integer Wert 42 zurück. int() kann allerdings nicht beliebige strings in integer umwandeln. Wenn 'zweiundvierzig' oder 'forty-two' übergeben wird, dann ist das Ergebnis ein Fehler. Der string der an int() übergeben wird muss aus Zahlen bestehen:

>>> int('forty-two')
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
int('forty-two')
ValueError: invalid literal for int() with base 10: 'forty-two'

In der Zeile 3 + int('2') wir der Rückgabewert von int() als Teil eines Ausdrucks verwendet. Der Ausdruck wird zu integer 5 ausgewertet:

3 + int('2')
  ▼
3 + 2
  ▼
  5

Erinner dich, die input() Funktion gibt die Eingabe des Spielers als Text, also als string zurück. Wenn der Spieler 5 eintippt, dann gibt die input() Funktion den string Wert '5' zurück, nicht denn integer Wert 5. Python kann die Vergleichsoperatoren < und > nicht verwenden um einen string und einen integer wert zu vergleichen:

>>> 4 < '5'
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    4 < '5'
TypeError: unorderable types: int() < str()

In Zeile 15 enthält die Variable tipp zuerst den string Wert der Eingabe des Spielers. In Zeile 16 wird der string Wert mit einem integer Wert, der von int() zurück gegeben wird, überschrieben. Das erlaubt dem Code später im Programm zu testen ob der Tipp größer, kleiner oder gleich der Geheimzahl die in der Variable zahl gespeichert ist.

Eine letzte Sachen noch:  Wenn int(tipp) aufgerufen wird ändert sich der Wert in tipp nicht. Der Code int(tipp) ist ein Ausdruck der zu einem integer ausgewertet wird. tipp wird erst durch den Zuweisungsoperator geändert: tipp = int(tipp)

Die float(), str() und bool() Funktionen geben ähnlich wie int() float, string und Boolean Versionen der Argumente zurück. Versuche die folgenden Befehle in der Eingabezeile:

>>> float('42')
42.0
>>> float(42)
42.0
>>> str(42)
'42'
>>> str(42.0)
'42.0'
>>> str(False)
'False'
>>> bool('')
False
>>> bool('any nonempty string')
True
 
Den int(), float(), str() und bool() Funktionen kannst du Werte eines Datentyps übergeben und ihn als Wert eines anderen Datentyps erhalten.

