  Chapter 9
  Kapitel 9
  HANGMAN
  GALGENMANN

Topics Covered In This Chapter:
In diesem Kapitel behandelte Themen:

• Multi-line Strings
• Mehrzeilige Zeichenketten
• Methods
• Methoden
• Lists
• Listen
• The append() and reverse() list methods
• Die Listen-Methoden append() und reverse()
• The lower(), upper(), split(), startswith(), and endswith() string methods
• Die Zeichenketten-Methoden lower(), upper(), split(), startswith() und endswith()
• The in and not in operators
• Die Operatoren in und not in
• The range() and list() functions
• Die Funktionen range() und list()
• del statements
• del-Ausdrücke
• for loops
• for-Schleifen
• elif statements
• elif-Ausdrücke

This chapter’s game introduces many new concepts, but don’t worry. You’ll experiment with these programming concepts in the interactive shell first. You’ll learn about methods, which are functions attached to values. You’ll also learn about a new type of loop called a for loop and a new data type called a list. Once you understand these concepts, it will be much easier to program Hangman.
Diese Kapitel führt viele neue Konzepte ein, aber keine Sorge! Wir werden mit diesen Programmier-Konzepten zuerst im interaktiven Kommandozeileninterpreter experimentieren und uns mit ihnen vertraut machen. Danach lernen wir Methoden kennen, das sind an Werte gebundene Funktionen. Wir beschäftigen uns außerdem mit einem neuen Schleifen-Typen namens for-Schleife und einem neuen Daten-Typen namens Liste. Wenn Du diese Konzepte verinnerlicht hast, gestaltet sich die Programmierung von Galgenmann gleich viel einfacher.

Source Code of Hangman
Quellcode zu Galgenmann

This chapter’s game is a bit longer than the previous games, but much of it is the ASCII art for the hangman pictures. Enter the following into the file editor and save it as hangman.py.
Das Spiel in diesem Kapitel ist um einiges länger als vorherige Spiele, aber vieles davon ist ASCII-Kunst für die Galgenmann-Animation. Gib folgenden Code in den Datei-Editor ein und speichere ihn als galgenmann.py ab.

hangman.py
galgenmann.py

  1. import random
  2. GALGENMANNBILDER = ['''
  3.
  4.   +---+
  5.   |   |
  6.       |
  7.       |
  8.       |
  9.       |
 10. =========''', '''
 11.
 12.   +---+
 13.   |   |
 14.   O   |
 15.       |
 16.       |
 17.       |
 18. =========''', '''
 19.
 20.   +---+
 21.   |   |
 22.   O   |
 23.   |   |
 24.       |
 25.       |
 26. =========''', '''
 27.
 28.   +---+
 29.   |   |
 30.   O   |
 31.  /|   |
 32.       |
 33.       |
 34. =========''', '''
 35.
 36.   +---+
 37.   |   |
 38.   O   |
 39.  /|\  |
 40.       |
 41.       |
 42. =========''', '''
 43.
 44.   +---+
 45.   |   |
 46.   O   |
 47.  /|\  |
 48.  /    |
 49.       |
 50. =========''', '''
 51.
 52.   +---+
 53.   |   |
 54.   O   |
 55.  /|\  |
 56.  / \  |
 57.       |
 58. =========''']
 59. worte = 'aal adler alligator ameise amsel bär biber bussard chamäleon dachs delfin eichhörnchen eidechse elch elefant faultier fledermaus fuchs gans gepard gorilla hai hamster hase hirsch huhn igel jaguar kamel känguru koala leopard libelle marienkäfer maulwurf meerschweinchen möwe nachtigal nilpferd panda pfau qualle ratte regenwurm schaf schimpanse schwan schwein strauß tausendfüßer tintenfisch wachtel wal wolf zebra ziege'.split()
 60.
 61. def zufallsWort(wortListe):
 62.     # Diese Funktion gibt eine zufällige Zeichenkette aus der übergebenen Zeichenketten-Liste zurück.
 63.     wortIndex = random.randint(0, len(wortListe) - 1)
 64.     return wortListe[wortIndex]
 65.
 66. def zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort):
 67.     print(GALGENMANNBILDER[len(falscheBuchstaben)])
 68.     print()
 69.
 70.     print('Falsche Buchstaben:', end=' ')
 71.     for buchstabe in falscheBuchstaben:
 72.         print(buchstabe, end=' ')
 73.     print()
 74.
 75.     luecken = '_' * len(geheimWort)
 76.
 77.     for i in range(len(geheimWort)): # Ersetze Lücken mit korrekt geratenen Buchstaben
 78.         if geheimWort[i] in richtigeBuchstaben:
 79.             luecken = luecken[:i] + geheimWort[i] + luecken[i+1:]
 80.
 81.     for buchstabe in luecken: # Zeige das Geheimwort mit Leerzeichen zwischen den Buchstaben
 82.         print(buchstabe, end=' ')
 83.     print()
 84.
 85. def rateBuchstabe(bereitsGeraten):
 86.     # Stellt sicher, dass der Spieler nur einen einzelnen Buchstaben eintippt und gibt ihn zurück.
 87.     while True:
 88.         print('Rate einen Buchstaben.')
 89.         eingabe = input()
 90.         eingabe = eingabe.lower()
 91.         if len(eingabe) != 1:
 92.             print('Bitte gib einen einzelnen Buchstaben ein.')
 93.         elif eingabe in bereitsGeraten:
 94.             print('Du hast diesen Buchstaben bereits probiert. Rate noch einmal.')
 95.         elif eingabe not in 'abcdefghijklmnopqrstuvwxyz':
 96.             print('Bitte gib einen BUCHSTABEN ein.')
 97.         else:
 98.             return eingabe
 99.
100. def spieleNochEinmal():
101.     # Diese Funktion True zurück, falls der Spieler noch einmal spielen möchte, False sonst.
102.     print('Möchtest Du noch einmal spielen? (ja oder nein)')
103.     return input().lower().startswith('j')
104.
105.
106. print('G A L G E N M A N N')
107. falscheBuchstaben = ''
108. richtigeBuchstaben = ''
109. geheimWort = zufallsWort(worte)
110. spielIstBeendet = False
111.
112. while True:
113.     zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)
114.
115.     # Lass den Spieler einen Buchhstaben eingeben.
116.     buchstabe = rateBuchstabe(falscheBuchstaben + richtigeBuchstaben)
117.
118.     if buchstabe in geheimWort:
119.         richtigeBuchstaben = richtigeBuchstaben + buchstabe
120.
121.         # Überprüfe, ob der Spieler gewonnen hat
122.         alleBuchstabenGeraten = True
123.         for i in range(len(geheimWort)):
124.             if geheimWort[i] not in richtigeBuchstaben:
125.                 alleBuchstabenGeraten = False
126.                 break
127.         if alleBuchstabenGeraten:
128.             print('Ja! Das geheime Wort ist "' + geheimWort + '"! Du hast gewonnen!')
129.             spielIstBeendet = True
130.     else:
131.         falscheBuchstaben = falscheBuchstaben + buchstabe
132.
133.         # Überprüfe, ob der Spieler zu viele Rateversuche verbraucht und damit verloren hat
134.         if len(falscheBuchstaben) == len(GALGENMANNBILDER) - 1:
135.             zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)
136.             print('Du hast zu viele Versuche gebraucht!\nNach ' + str(len(falscheBuchstaben)) + ' falsch und ' + str(len(richtigeBuchstaben)) + ' richtig geratenen Buchstaben lautet das Wort "' + geheimWort + '"')
137.             spielIstBeendet = True
138.
139.     # Frage den Spieler, ob er noch einmal spielen möchte (aber nur, wenn das Spiel zu Ende ist).
140.     if spielIstBeendet:
141.         if spieleNochEinmal():
142.             falscheBuchstaben = ''
143.             richtigeBuchstaben = ''
144.             spielIstBeendet = False
145.             geheimWort = zufallsWort(worte)
146.         else:
147.             break

How the Code Works
Wie der Code funktioniert

  1. import random

The Hangman program randomly selects a secret word from a list of secret words. The random module will provide this ability, so line 1 imports it.
Das Galgenmann-Programm sucht zufällig ein geheimes Wort aus einer Liste von geheimen Worten aus. Dafür benötigen wir die Funktionalität des random-Moduls, also importieren wir es.

  2. GALGENMANNBILDER = ['''
  3.
  4.   +---+
  5.   |   |
  6.       |
  7.       |
  8.       |
  9.       |
 10. =========''', '''

...the rest of the code is too big to show here...
...der Rest des Codes ist zu groß, um ihn hier zu zeigen...

This one assignment statement stretches over lines 2 to 58 in the source code. To help you understand what this code means, let’s learn about multi-line strings.
Diese eine Zuweisung erstreckt sich über die Zeilen 2 bis 58 im Code. Die Bedeutung dieses Codes wird ersichtlich, sobald wir uns mit mehrzeiligen Zeichenketten näher beschäftigt haben.

Multi-line Strings
Mehrzeilige Zeichenketten

So far all strings have been on one line and had one quote character at the start and end. However, if you use three quotes at the start and end then the string can go across several lines:
Bis jetzt waren Zeichenketten immer von einfachen Anführungszeichen umschlossen und standen in einer Zeile. Wird eine Zeichenkette jedoch von jeweils drei einfachen Anführungszeichen umschlossen, so kann sie sich über mehrere Zeilen erstrecken:

>>> fizz = '''Dear Alice,
>>> fizz = '''Liebe Alice,
I will return to Carol's house at the end of the month. I will see you then.
Ich komme am Ende des Monats zu Carols Haus zurück. Wir sehen uns dann.
Your friend,
Dein Freund,
Bob'''
Bob'''
>>> print(fizz)
>>> print(fizz)
Dear Alice,
Liebe Alice,
I will return to Carol's house at the end of the month. I will see you then.
Ich komme am Ende des Monats zu Carols Haus zurück. Wir sehen uns dann.
Your friend,
Dein Freund,
Bob
Bob

These are multi-line strings. In a multi-line string, the newline characters are included as part of the string. You don’t have to use the \n escape character, or escape quotes as long as you don’t use three of them together. This makes the code easier to read for large amounts of text.
Dies sind mehrzeilige Zeichenketten. In mehrzeiligen Zeichenketten sind Zeilenumbrüche Teil der Zeichenkette. Sie brauchen nicht durch das Escape-Zeichen \n extra kenntlich gemacht werden. Dies macht es einfacher, große Mengen an Text zu lesen.

Constant Variables
Konstante Variablen

The HANGMANPICS variable’s name is in all capitals. This is the programming convention for constant variables. Constants are variables meant to have values that never changes from their first assignment statement. Although you can change the value in HANGMANPICS just like any other variable, the all-caps name reminds you to not do so. Since the HANGMANPICS variable never needs to change, it’s marked as a constant.
Der Name der Variablen GALGENMANN ist in Großbuchstaben geschrieben. Dies ist Konvention bei konstanten Variablen. Konstanten sind Variablen, deren Wert sich nach der ersten Zuweisung nie mehr ändert. Obwohl man den Wert von GALGENMANN genauso wie bei jeder anderen Variable ändern könnte, erinnert uns ihr Name, dies nicht zu tun. Es ist eine Vereinbarung zwischen Programmierern.

Like all conventions, you don’t have to follow it. But following this convention makes it easier for other programmers to read your code. They’ll know that HANGMANPICS will always have the value it was assigned on line 2.
Wie bei allen Konventionen, braucht diese nicht befolgt zu werden. Es ist jedoch ratsam, weil es anderen Programmierern erleichtert, Deinen Code zu lesen. Sie können sich darauf verlassen, dass GALGENMANN immer den Wert haben wird, der ihr in Zeile 2 zugewiesen wurde.

Lists
Listen

A list value can contain several other values inside it. Try entering this into the interactive shell:.
Eine Liste kann mehrere Werte enthalten. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = ['Life', 'The Universe', 'Everything', 42]
>>> spam = ['Leben', 'Das Universum', 'Alles', 42]
>>> spam
>>> spam
['Life', 'The Universe', 'Everything', 42]
['Leben', 'Das Universum', 'Alles', 42]

This list value in spam contains four values. When typing the list value into your code, it begins with a [ square bracket and ends with a ] square bracket. This is like how strings begin and end with a quote character.
Die Liste spam enthält vier Werte. Die Definition beginnt mit einer öffnenden eckigen Klammer [ und endet mit einer schließenden eckigen Klammer ], ähnlich wie Zeichenketten mit Apostrophen beginnen und enden.

Commas separate the individual values inside of a list. These values are also called items.
Kommata trennen die einzelnen Werte innerhalb einer Liste. Diese Werte bezeichnet man als Einträge.

Indexes
Indizes

Try entering animals = ['aardvark', 'anteater', 'antelope', 'albert'] into the interactive shell to store a list in the variable animals. The square brackets are also used to access an item inside a list. Try entering animals[0], animals[1], animals[2], and animals[3] into the interactive shell to see how they evaluate:
Probiere tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope'] in den interaktiven Kommandozeileninterpreter einzugeben um eine Liste in der Variablen tiere zu speichern. Die eckigen Klammern werden auch verwendet, um auf Elemente in der Liste zuzugreifen. Probiere tiere[0], tiere[1], tiere[2] und tiere[3] in den interaktiven Kommandozeileninterpreter einzugeben um zu sehen, wie diese Ausdrücke ausgewertet werden:

>>> animals = ['aardvark', 'anteater', 'antelope', 'albert']
>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> animals[0]
>>> tiere[0]
'aardvark'
'Affe'
>>> animals[1]
>>> tiere[1]
'anteater'
'Alpaka'
>>> animals[2]
>>> tiere[2]
'antelope'
'Ameise'
>>> animals[3]
>>> tiere[3]
'albert'
'Antilope'

The number between the square brackets is the index. In Python, the index of the first item in a list is 0. The second item is at index 1, the third item is at index 2, and so on. Because the indexes begin at 0, not 1, we say that Python lists are zero-indexed.
Die Zahl zwischen den eckigen Klammern ist der Index. In Python hat das erste Element in einer Liste den Index 0. Das zweite Element hat den Index 1, das dritte den Index 2, und so weiter. Weil die Indizes bei 0 und nicht bei 1 beginnen, sagt man Python sei 0-indiziert.

Lists are good for storing several values without using a variable for each one. Otherwise, the code would look like this:
Listen eignen sich dafür mehrere Werte zu speichern, ohne mehrere Variablen zu verwenden. Andererseits würde der Code wie folgt aussehen:

>>> animals1 = 'aardvark'
>>> tiere1 = 'Affe'
>>> animals2 = 'anteater'
>>> tiere2 = 'Alpaka'
>>> animals3 = 'antelope'
>>> tiere3 = 'Ameise'
>>> animals4 = 'albert'
>>> tiere4 = 'Antilope'

This code would be hard to manage if you have hundreds or thousands of strings. But a list can easily contain any number of values. Using the square brackets, you can treat items in the list just like any other value. Try entering animals[0] + animals[2] into the interactive shell:
Dieser Code wäre schwierig zu verwalten, wenn er aus hunderten oder tausenden von Zeichenketten bestünde. Eine Liste hingenen, kann beliebige Anzahlen von Werten enthalten. Über die eckigen Klammern kann auf diese Werte zugegriffen werden. Probiere tiere[0] + tiere[2] in den interaktiven Kommandozeileninterpreter einzugeben:

>>> animals[0] + animals[2]
>>> tiere[0] + tiere[2]
'aardvarkantelope'
'AffeAmeise'

The evaluation looks like this:
Die Auswertung läuft wie folgt ab:

tiere[0] + tiere[2]
         ▼
'Affe'   + tiere[2]
         ▼
'Affe'   + 'Ameise'
         ▼
   'AffeAmeise'

IndexError
Indizierungs-Fehler

If you try accessing an index that is too large, you’ll get an IndexError that will crash your program. Try entering the following into the interactive shell:
Der Versuch auf einen Index zuzugreifen, der zu groß ist, resultiert in einem IndexError (auf Deutsch Indizierungs-Fehler) und das Programm stürzt ab. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> animals = ['aardvark', 'anteater', 'antelope', 'albert']
>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> animals[9999]
>>> tiere[9999]
Traceback (most recent call last):
File "", line 1, in
tiere[99]
IndexError: list index out of range

Changing the Values of List Items with Index Assignment
Werte von Listen-Elementen ändern

You can also use the square brackets to change the value of an item in a list. Try entering the following into the interactive shell:
Die eckigen Klammern können auch verwendet werden, um den Wert eines Elements in der Liste zu ändern. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> animals = ['aardvark', 'anteater', 'antelope', 'albert']
>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> animals[1] = 'ANTEATER'
>>> tiere[1] = 'AMEISE'
>>> animals
>>> tiere
['aardvark', 'ANTEATER', 'antelope', 'albert']
['Affe', 'Alpaka', 'AMEISE', 'Antilope']

The new 'ANTEATER' string overwrites the second item in the animals list. So animals[1] will evaluate to the list’s second item in expressions, but you can also use it on the left side of an assignment statement to assign a value as the list’s second item.
Die neue Zeichenkette 'AMEISE' überschreibt das zweite Element in der Liste tiere. tiere[1] evaluiert also zum zweiten Listen-Element in Ausdrücken, kann aber auch auf der linken Seite von Zuweisungen verwendet werden, um Werte zum zweiten Listen-Element zuzuweisen. 

List Concatenation
Listen-Verknüpfung

You can join lists into one list with the + operator, just like you can join strings. Joining lists with the + operator is list concatenation. Try entering the following into the interactive shell:
Listen können mit Hilfe des Operators + zu einer Liste verknüpft werden, genauso wie Zeichenketten. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> [1, 2, 3, 4] + ['apples', 'oranges'] + ['Alice', 'Bob']
>>> [1, 2, 3, 4] + ['Äpfel', 'Orangen'] + ['Alice', 'Bob']
[1, 2, 3, 4, 'apples', 'oranges', 'Alice', 'Bob']
[1, 2, 3, 4, 'Äpfel', 'Orangen', 'Alice', 'Bob']
['apples'] + ['oranges'] will evaluate to ['apples', 'oranges']. But ['apples'] + 'oranges' will result in an error. You cannot add a list value and string value instead of two list values. If you want to add non-list values to a list, use the append() method (described later).
['Äpfel'] + ['Orangen'] evaluiert zu ['Äpfel', 'Orangen']. ['Äpfel'] + 'Orangen' jedoch resultiert ein einem Fehler. Eine Liste kann nicht mit einer Zeichenkette verknüpft werden. Sollen Nicht-Listen-Elemente zu einer Liste hinzugefügt werden, so verwendet man die Methode append() (später beschrieben).

The in Operator
Der Operator in

The in operator can tell you if a value is in a list or not. Expressions that use the in operator return a Boolean value: True if the value is in the list and False if it isn’t. Try entering the following into the interactive shell:
Der Operator in verrät Dir, ob sich ein Wert in einer Liste befindet. Der in-Operator gibt einen booleschen Wert zurück: True, falls sich der Wert in der Liste befindet, False sonst. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> animals = ['aardvark', 'anteater', 'antelope', 'albert']
>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> 'antelope' in animals
>>> 'Antilope' in tiere
True
True

The expression 'antelope' in animals returns True because the string 'antelope' is one of the values in the animals list. It is located at index 2.
Der Ausdruck 'Antilope' in tiere gibt True zurück, weil sich die Zeichenkette 'Antilope' in der Liste tiere befindet. Ihre Position ist Index 2.

But if you type the expression 'ant' in animals, this will return False because the string 'ant' doesn’t exist in the list.
Gibtst Du jedoch den Ausdruck 'Aal' in tiere ein, so ergibt dies False, weil die Zeichenkette 'Aal' nicht in der Liste vorkommt.

>>> animals = ['aardvark', 'anteater', 'antelope', 'albert']
>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> 'antelope' in animals
>>> 'Antilope' in tiere
True
True
>>> 'ant' in animals
>>> 'Aal' in tiere
False
False

The in operator also works for strings. It checks if one string exists in another. Try entering the following into the interactive shell:
Der Operator in funktioniert auch mit Zeichenketten. Er überprüft, ob eine Zeichenkette Teil einer anderen Zeichenkette ist. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> 'hello' in 'Alice said hello to Bob.'
>>> 'Hallo' in 'Alice sagt Hallo zu Bob.'
True
True

Deleting Items from Lists with del Statements
Elemente aus Listen löschen

A del statement will delete an item at a certain index from a list. Try entering the following into the interactive shell:
Der del-Ausdruck löscht ein Element an einer bestimmten Position aus einer Liste. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = [2, 4, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 6, 8, 10]

Notice that when you deleted the item at index 1, the item that used to be at index 2 became the new value at index 1. The item that used to be at index 3 moved to be the new value at index 2. Everything above the deleted item moved down one index.
Beachte, dass als Du das Element an Position 1 gelöscht hast, alle folgenden Elemente aufgerückt sind und sich ihr Index um eins verringert hat.

You can type del spam[1] again and again to keep deleting items from the list:
Du kannst den Befehl del spam[1] erneut eingeben, um weitere Elemente aus der Liste zu löschen.

>>> spam = [2, 4, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 8, 10]
>>> del spam[1]
>>> spam
[2, 10]

The del statement is a statement, not a function or an operator. It doesn’t have parentheses or evaluate to a return value.
Der del-Ausdruck ist ein Ausdruck, er ist keine Funktion und kein Operator. Er beinhaltet keine Klammern und gibt auch keinen Wert zurück.

Lists of Lists
Listen aus Listen

Lists can contain other values, including other lists. Let’s say you have a list of groceries, a list of chores, and a list of your favorite pies. You can put all three lists into another list. Try entering the following into the interactive shell:
Listen können selbst Listen enthalten. Nehmen wir an Du hättest eine Einkaufsliste, eine Aufgabenliste und eine Liste Deiner Lieblingskuchen. Du kannst all diese Listen in eine andere Liste einfügen. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> groceries = ['eggs', 'milk', 'soup', 'apples', 'bread']
>>> einkaeufe = ['Eier', 'Milch', 'Suppe', 'Aepfel', 'Brot']
>>> chores = ['clean', 'mow the lawn', 'go grocery shopping']
>>> aufgaben = ['Sauber machen', 'Rasen maehen', 'Einkaeufe erledigen']
>>> favoritePies = ['apple', 'frumbleberry']
>>> lieblingsKuchen = ['Apfel', 'Brombeere']
>>> listOfLists = [groceries, chores, favoritePies]
>>> listeAusListen = [einkaeufe, aufgaben, lieblingsKuchen]
>>> listOfLists
>>> listeAusListen
[['eggs', 'milk', 'soup', 'apples', 'bread'], ['clean', 'mow the lawn', 'go grocery shopping'], ['apple', 'frumbleberry']]
[['Eier', 'Milch', 'Suppe', 'Aepfel', 'Brot'], ['Sauber machen', 'Rasen maehen', Einkaeufe erledigen'], ['Apfel', 'Brombeere']]

To get an item inside the list of lists, you would use two sets of square brackets like this: listOfLists[1][2] which would evaluate to the string 'go grocery shopping'.
Um ein Element aus einer Liste aus Listen abzufragen, benutzt man zwei Klammern-Paare: listeAusListen[1][2] würde zu 'Einkaeufe erledigen' ausgewertet werden.

This is because listOfLists[1][2] evaluates to ['clean', 'mow the lawn', 'go grocery shopping'][2]. That finally evaluates to 'go grocery shopping':
Dies liegt daran, dass listeAusListen[1][2] zu ['Sauber machen', 'Rasen maehen', Einkaeufe erledigen'][2] evaluiert, was schlussendlich zu 'Einkaeufe erledigen' evaluiert:

listOfLists[1][2]
listeAusListen[1][2]
         ▼
[['eggs', 'milk', 'soup', 'apples', 'bread'], ['clean', 'mow the lawn', 'go grocery shopping'], ['apple', 'frumbleberry']][1][2]
[['Eier', 'Milch', 'Suppe', 'Aepfel', 'Brot'], ['Sauber machen', 'Rasen maehen', Einkaeufe erledigen'], ['Apfel', 'Brombeere']][1][2]
         ▼
['clean', 'mow the lawn', 'go grocery shopping'][2]
['Sauber machen', 'Rasen maehen', 'Einkaeufe erledigen'][2]
         ▼
'go grocery shopping'
'Einkaeufe erledigen'

Figure 9-1 is another example of a list of lists, along with some of the indexes that point to the items. The arrows point to indexes of the inner lists themselves. The image is also flipped on its side to make it easier to read.
Abbildung 9-1 ist ein weiteres Beispiel fuer eine Liste aus Listen, zusammen mit einigen Beispiel-Indizes, die auf die Elemente verweisen. Die Pfeile verweisen auf die Indizes der inneren Listen. Die Abbildung ist für eine bessere Lesbarkeit gedreht.

Methods
Methoden

Methods are functions attached to a value. For example, all string values have a lower() method, which returns a copy of the string value in lowercase. You can call it like 'Hello'.lower(), which returns 'hello'. You cannot call lower() by itself and you do not pass a string argument to lower() (as in lower('Hello')). You must attach the method call to a specific string value using a period. The next section describes string methods further.
Methoden sind an Werte gebundene Funktionen. Zum Beispiel besitzen alle Zeichenketten eine lower()-Methode, die eine Kopie der Zeichenkette in Kleinbuchstaben zurückgibt. Zum Beispiel gibt 'Hallo'.lower() 'hallo' zurück. lower() kann nicht alleine aufgerufen werden und man kann auch keine Argumente an lower() übergebenen (wie z.B. lower('Hallo')). Der Methoden-Aufruf muss an eine bestimmte Zeichenkette gebunden sein. Der nächste Abschnitt geht tiefer auf Zeichenketten-Methoden ein.

Figure 9-1: The indexes of a list of lists.
Abbildung 9-1: Die Indizes von einer Liste aus Listen.

The lower() and upper() String Methods
Die Zeichenketten-Methoden lower() und upper()

Try entering 'Hello world!'.lower() into the interactive shell to see an example of this method:
Probiere 'Hallo Welt!'.lower() in den interaktiven Kommandozeileninterpreter einzugeben, um sich diese Methode zu veranschaulichen:

>>> 'Hello world!'.lower()
>>> 'Hallo Welt!'.lower()
'hello world!'
'hallo welt!'

There is also an upper() method for strings, which returns a string with all the characters in uppercase. Try entering 'Hello world!'.upper() into the interactive shell:
Es gibt auch eine upper()-Methode für Zeichenketten, die eine Zeichenketten in Großbuchstaben zurückgibt. Probiere 'Hallo Welt!'.upper() in den interaktiven Kommandozeileninterpreter einzugeben:

>>> 'Hello world!'.upper()
>>> 'Hallo Welt!'.upper()
'HELLO WORLD!'
'HALLO WELT!'

Because the upper() method returns a string, you can call a method on that string also. Try entering 'Hello world!'.upper().lower() into the interactive shell:
Da die upper()-Methode eine Zeichenkette zurückgibt, kann man an ihr ebenfalls eine Methode aufrufen. Probiere 'Hallo Welt!'.upper().lower() in den interaktiven Kommandozeileninterpreter einzugeben:

>>> 'Hello world!'.upper().lower()
>>> 'Hallo Welt!'.upper().lower()
'hello world!'
'hallo welt!'
'Hello world!'.upper() evaluates to the string 'HELLO WORLD!', and then string's lower() method is called. This returns the string 'hello world!', which is the final value in the evaluation.
'Hallo Welt!'.upper() evaluiert zu 'HALLO WELT!'. Auf dieser Zeichenkette wird die Methode lower() aufgerufen, was zu 'hallo welt!' evaluiert.

'Hello world!'.upper().lower()
'Hallo Welt!'.upper().lower()
                    ▼
       'HELLO WORLD!'.lower()
       'HALLO WELT!'.lower()
                    ▼
                'hello world!'
                'hallo welt!'

The order is important. 'Hello world!'.lower().upper() isn’t the same as 'Hello world!'.upper().lower():
Die Reihenfolge ist wichtig. 'Hallo Welt!'.lower().upper() ist nicht dasselbe wie  'Hallo Welt!'.upper().lower():

>>> 'Hello world!'.lower().upper()
>>> 'Hallo Welt!'.lower().upper()
'HELLO WORLD!'
'HALLO WELT!'

That evaluation looks like this:
Die Auswertung sieht wie folgt aus:

'Hello world!'.lower().upper()
'Hallo Welt!'.lower().upper()
                    ▼
        'hello world!'.upper()
        'hallo welt!'.lower()
                    ▼
               'HELLO WORLD!'
               'HALLO WELT!'

If a string is stored in a variable, you can call a string method on that variable. Look at this example:
Wenn eine Zeichenkette in einer Variablen gespeichert ist, kann man eine Zeichenketten-Methode an dieser Variablen aufrufen. Schaue Dir folgendes Beispiel an:

>>> spam = 'Hello world!'
>>> spam = 'Hallo Welt!'
>>> spam.upper()
>>> spam.upper()
'HELLO WORLD!'
'HALLO WELT!'

This does not change the value in spam. The spam variable will still contain 'Hello world!'.
Dieser Code ändert den Wert in spam nicht. spam beinhaltet immer noch den Wert 'Hallo Welt!'.

Note that the integer and float data types don’t have any methods.
Beachte, dass Ganz-und Fließkommazahlen keine Methoden besitzen.

The reverse() and append() List Methods
Die Listen-Methoden reverse() und append()

The list data type also has methods. The reverse() method will reverse the order of the items in the list. Try entering spam = [1, 2, 3, 4, 5, 6, 'meow', 'woof'], and then spam.reverse() to reverse the list. Then enter spam to view the contents of the variable.
Listen besitzen ebenfalls Methoden. Die Methode reverse() kehrt die Reihenfolge der Elemente in einer Liste um. Probiere spam = [1, 2, 3, 4, 5, 6, 'miau', 'wuff'] gefolgt von spam.reverse() in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = [1, 2, 3, 4, 5, 6, 'meow', 'woof']
>>> spam = [1, 2, 3, 4, 5, 6, 'miau', 'wuff']
>>> spam.reverse()
>>> spam.reverse()
>>> spam
>>> spam
['woof', 'meow', 6, 5, 4, 3, 2, 1]
['wuff', 'miau', 6, 5, 4, 3, 2, 1]

The most common list method you’ll use is append(). This method will add the value you pass as an argument to the end of the list. Try entering the following into the interactive shell:
Die gängigste Listen-Methode, die Du verwendne wirst, ist append(). Diese Methode fügt den ihr übergebenen Wert an das Ende der Liste hinzu. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> eggs = []
>>> eier = []
>>> eggs.append('hovercraft')
>>> eier.append('Luftkissenboot')
>>> eggs
>>> eier
['hovercraft']
['Luftkissenboot']
>>> eggs.append('eels')
>>> eier.append('Aale')
>>> eggs
>>> eier
['hovercraft', 'eels']
['Luftkissenboot', 'Aale']
>>> eggs.append(42)
>>> eier.append(42)
>>> eggs
>>> eier
['hovercraft', 'eels', 42]
['Luftkissenboot', 'Aale', 42]

These methods do change the lists they are called on. They don’t return a new list. We say that these methods change the list in-place.
Diese Methoden geben keine neue Liste zurück, sondern verändern die Liste, an der sie aufgerufen werden. Man sagt diese Methoden verändern die Liste “in-place” (zu Deutsch “an der Stelle”).

The split() List Method
Die Listen-Methode split()

Line 59 is a long line of code, but it is really just a simple assignment statement. This line also uses the split() method, which is a method for the string data type like the lower() and upper() methods.
Zeile 59 ist eine lange Zeile Code, aber es handelt sich um eine einfache Zuweisung. Diese Zeile verwendet die split()-Methode von Zeichenketten.

59. words = 'ant baboon badger bat bear beaver camel cat clam cobra cougar coyote crow deer dog donkey duck eagle ferret fox frog goat goose hawk lion lizard llama mole monkey moose mouse mule newt otter owl panda parrot pigeon python rabbit ram rat raven rhino salmon seal shark sheep skunk sloth snake spider stork swan tiger toad trout turkey turtle weasel whale wolf wombat zebra'.split()
59. worte = 'aal adler alligator ameise amsel bär biber bussard chamäleon dachs delfin eichhörnchen eidechse elch elefant faultier fledermaus fuchs gans gepard gorilla hai hamster hase hirsch huhn igel jaguar kamel känguru koala leopard libelle marienkäfer maulwurf meerschweinchen möwe nachtigal nilpferd panda pfau qualle ratte regenwurm schaf schimpanse schwan schwein strauß tausendfüßer tintenfisch wachtel wal wolf zebra ziege'.split()

This assignment statement has just one long string, full of words separated by spaces. And at the end of the string is a split() method call. The split() method evaluates to a list with each word in the string as a single list item. The “split” occurs wherever a space occurs in the string.
Diese Zuweisung besteht aus einer einzigen, langen Zeichenkette, voll von Worten, die durch Leerzeichen getrennt sind. Am Ende der Zeichenkette steht ein Aufruf der split()-Methode. Diese gibt eine Liste zurück, in der jedes Wort aus der Zeichenkette einem Element entspricht. Der split (zu Deutsch “Spaltung”) tritt an Leerzeichen in der Zeichenkette auf.

It is easier to type the code using split(). If you created it as a list to begin with, you would have to type: ['ant', 'baboon', 'badger',... and so on, with quotes and commas for every word.
split() erleichtert uns das Tippen. Hätten wir von Anfang an eine Liste erstellt, so müssten wir ['aal', 'adler', 'alligator', ... eingeben, mit Anführungszeichen und Kommata für jedes Wort.

For example, try entering the following into the interactive shell:
Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> sentence = input()
>>> satz = input()
My very energetic mother just served us nachos.
Meine sehr energische Mutter hat uns gerade Nachos serviert.
>>> sentence.split()
>>> satz.split()
['My', 'very', 'energetic', 'mother', 'just', 'served', 'us', 'nachos.']
['Meine', 'sehr', 'energische', 'Mutter', hat', uns', gerade', Nachos', serviert.']

The result is a list of nine strings, one string for each of the words in the original string. The spaces are not included in any of the items in the list.
Das Ergebnis ist eine Liste mit neun Zeichenketten, eine für jedes Wort im ursprünglichen Satz. Die Leerzeichen sind in keinen Elementen der Liste enthalten.

You can also add your own words to the string on line 59, or remove any you don’t want to be in the game. Just make sure that spaces separate the words.
Du kannst gerne Deine eigenen Worte zur Zeichenkette in Zeile 59 hinzufügen, oder Worte entfernen, die Du nicht im Spiel haben möchtest. Stelle einfach sicher, dass die Worte von Leerzeichen getrennt sind.

How the Code Works
Wie der Code funktioniert

Line 61 defines the getRandomWord() function. A list argument will be passed for its wordList parameter. This function will return a single secret word from the list in wordList.
Zeile 61 definiert die zufallsWort()-Funktion. Ein Listen-Argument wird an ihren wortListe-Parameter übergeben. Diese Funktion gibt ein einzelnes, geheimes Wort aus wortListe zurück.

 61. def zufallsWort(wortListe):
 62.     # Diese Funktion gibt eine zufällige Zeichenkette aus der übergebenen Zeichenketten-Liste zurück.
 63.     wortIndex = random.randint(0, len(wortListe) - 1)
 64.     return wortListe[wortIndex]

Line 63 stores a random index for this list in the wordIndex variable. You do this by calling randint() with two arguments. The first argument is 0 (for the first possible index) and the second argument is the value that the expression len(wordList) - 1 evaluates to (for the last possible index in a wordList).
Zeile 63 speichert einen zufälligen Index für diese Liste in der Variable wortIndex ab. Dies geschieht, indem die randint()-Funktion mit zwei Argumenten aufgerufen wird. Das erste Argument ist 0 (der erste gültige Index) und das zweite Argument ist der Wert zu dem der Ausdrucks len(wortListe) - 1 evaluiert (der letzte gültige Index).

List indexes start at 0, not 1. If you have a list of three items, the index of the first item is 0, the index of the second item is 1, and the index of the third item is 2. The length of this list is 3, but the index 3 would be after the last index. This is why line 63 subtracts 1 from the length. The code on line 63 will work no matter what the size of wordList is. Now you can add or remove strings to wordList if you like.
Listen-Indizes beginnen bei 0, nicht 1. In einer Liste mit drei Elementen, befindet sich das erste Element bei Index 0, das zweite Element bei Index 1 und das dritte Element bei Index 2. Die Länge dieser Liste ist 3, aber der Index 3 würde hinter das letzte Element verweisen. Deswegen subtrahiert Zeile 63 1 von der Länge. Der Code in Zeile 63 funktioniert unabhängig von der Länge von wortListe. Jetzt kannst Du beliebig Wörter hinzufügen oder entfernen.

The wordIndex variable will be set to a random index for the list passed as the wordlist parameter. Line 64 will return the element in wordList at the integer index stored in wordIndex.
Die wortIndex-Variable wird auf einen zufälligen Index in der per wortListe übergebenen Liste gesetzt. Zeile 64 gibt das Element an Index wortIndex aus wortListe zurück.

Let’s pretend ['apple', 'orange', grape'] was passed as the argument to getRandomWord() and that randint(0, 2) returned the integer 2. That would mean that line 64 would evaluate to return wordList[2], and then evaluate to return 'grape'. This is how the getRandomWord() returns a random string in the wordList list.
Nehmen wir an ['Apfel', 'Orange', 'Weintraube'] wurde als Argument an zufallsWort() übergeben und randint(0, 2) gab 2 zurück. Dies würde bedeuten, dass Zeile 64 zu wortListe[2] evaluiert, was zu 'Weintraube' evaluiert, was zurückgegeben wird. Auf diese Weise gibt zufallsWort() zufällige Zeichenketten aus Listen zurück.

So the input to getRandomWord() is a list of strings, and the return value output is a randomly selected string from that list. This will be useful for the Hangman game to select a secret word for the player to guess.
zufallsWort() akzeptiert also eine Liste von Zeichenketten und gibt eine zufällig ausgewählte Zeichenkette aus dieser Liste zurück. Dies ist nützlich, um im Spiel Galgenmann ein geheimes, zu erratendes Wort für den Spieler auszuwählen.

Displaying the Board to the Player
Das Spielbrett anzeigen

Next, you need a function to print the hangman board on the screen. It will also display how many letters the player has correctly (and incorrectly) guessed.
Als Nächstes benötigen wir eine Funktion, um das Galgenmann-Spielbrett auf dem Bildschirm darzustellen. Es wird auch anzeigen, wieviele Buchstaben der Spieler richtig (bzw. falsch) geraten hat.

 66. def zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort):
 67.     print(GALGENMANNBILDER[len(falscheBuchstaben)])
 68.     print()

This code defines a new function named displayBoard(). This function has four parameters:
Dieser Code definiert eine neue Funktion namens zeigeSpielbrettAn(). Diese Funktion erwartet vier Parameter:

• HANGMANPICS - A list of multi-line strings that will display the board as ASCII art. (The global HANGMANPICS variable will be passed for this parameter.)
• GALGENMANNBILDER - Eine Liste von mehrzeiligen Zeichenketten, die das Spielbrett als ASCII-Kunst enthalten. (Die globale Variable GALGENMANNBILDER wird als Argument an diesen Parameter übergeben werden.) 
• missedLetters - A string of the letters the player has guessed that are not in the secret word.
• falscheBuchstaben - Eine Zeichenkette bestehend aus vom Spieler geratenen Buchstaben, die nicht Teil des Geheimwortes sind.
• correctLetters - A string of the letters the player has guessed that are in the secret word.
• richtigeBuchstaben - Eine Zeichenkette bestehend aus vom Spieler geratenen Buchstaben, die Teil des Geheimwortes sind.
• secretWord – A string of the secret word that the player is trying to guess.
• geheimWort – Eine Zeichenkette, die das geheime Wort representiert, das der Spieler zu erraten versucht.

The first print() function call will display the board. HANGMANPICS will be a list of strings for each possible board. HANGMANPICS[0] shows an empty gallows, HANGMANPICS[1] shows the head (when the player misses one letter), HANGMANPICS[2] shows a head and body (when the player misses two letters), and so on until HANGMANPICS[6] which shows the full hangman.
Der erste print()-Aufruf zeigt das Spielbrett an. GALGENMANNBILDER ist eine Liste mit Zeichenketten für jedes mögliche Spielbrett. GALGENMANNBILDER[0] zeigt einen leeren Galgen, GALGENMANNBILDER[1] zeigt den Kopf (wenn der Spieler einen Buchstaben falsch rät), GALGENMANNBILDER[2] zeigt den Kopf und Körper (wenn der Spieler zwei Buchstaben falsch rät), und so weiter bis GALGENMANNBILDER[6] schließlich den kompletten Henker zeigt.

The number of letters in missedLetters will reflect how many incorrect guesses the player has made. Call len(missedLetters) to find out this number. So, if missedLetters is 'aetr' then len('aetr') will return 4. Printing HANGMANPICS[4] will display the appropriate hangman board for 4 misses. This is what HANGMANPICS[len(missedLetters)] on line 67 evaluates to.
Die Anzahl der Buchstaben in falscheBuchstaben ist gleich der Anzahl der falschen Rateversuche des Spielers. Ein Aufruf von len(falscheBuchstaben) verrät uns diese Zahl. D.h., falls falscheBuchstaben den Wert 'aetr' enthält, gibt len('aetr') 4 zurück. GALGENMANNBILDER[4] auf dem Bildschirm auszugeben, zeigt das Spielbrett für vier falsche Rateversuche an. Dies ist genau das, was GALGENMANNBILDER[len(falscheBuchstaben)] in Zeile 67 tut.

 70.     print('Falsche Buchstaben:', end=' ')
 71.     for buchstabe in falscheBuchstaben:
 72.         print(buchstabe, end=' ')
 73.     print()

Line 70 prints the string 'Missed letters:' with a space character at the end instead of a newline. Remember that the keyword argument end=' ' uses only one = sign (like =), not two (like ==).
Zeile 70 gibt die Zeichenkette 'Falsche Buchhstaben:' auf dem Bildschirm aus, mit einem Leerzeichen am Ende, anstatt einer neuen Zeile. Wir erinnern uns, dass das Schlüsselwort-Argument end=' ' nur ein Gleichheitszeichen (=) verwendet, nicht zwei (==).

Line 71 is a new type of loop, called a for loop. A for loop often uses the range() function. Both are explained in the next two sections.
Zeile 71 führt eine neue Art von Schleife ein, genannt for-Schleife. Eine for-Schleife benutzt die range()-Funktion. Beide Konstrukte werden in den nächsten zwei Abschnitten erklärt.

The range() and list() Functions
Die Funktionen range() und list()

When called with one argument, range() will return a range object of integers from 0 up to (but not including) the argument. This range object can be converted to the more familiar list data type with the list() function. Try entering list(range(10)) into the interactive shell:
Wird range() mit einem Argument aufgerufen, so gibt die Funktion ein Wertebereich-Objekt bestehend aus Ganzzahlen von 0 bis (ausschließlich) zum Argument. Dieses Wertebereich-Objekt kann mit Hilfe der list()-Funktion in den uns vertrauten Listen-Typen konvertiert werden. Probiere list(range(10)) in den interaktiven Kommandozeileninterpreter einzugeben:

>>> list(range(10))
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list('Hello')
>>> list('Hallo')
['H', 'e', 'l', 'l', 'o']
['H', 'a', 'l', 'l', 'o']
The list() function is similar to the str() or int() functions. It just converts the object it is passed into a list. It’s easy to generate huge lists with the range() function. Try entering in list(range(10000)) into the interactive shell:
Die list()-Funktion ähnelt den Funktionen str() und int(), insofern als sie das ihr übergebene Objekt in eine Liste konvertiert. Es ist einfach riesige Listen mit der range()-Funktion zu generieren. Probiere list(range(10000)) in den interaktiven Kommandozeileninterpreter einzugeben:
>>> list(range(10000))
>>> list(range(10000))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,...
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,...
      ...skipped for brevity...
      ...der Kürze halber ausgelassen...
...9989, 9990, 9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999]
...9989, 9990, 9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999]

The list is so huge, that it won’t even all fit onto the screen. But you can store the list into a variable:
Diese Liste ist so groß, dass sie nicht einmal auf den Bildschirm passt. Aber man kann sie in einer Variablen speichern:

>>> spam = list(range(10000))
>>> spam = list(range(10000))

If you pass two integer arguments to range(), the range object it returns is from the first integer argument up to (but not including) the second integer argument. Try entering list(range(10, 20)) into the interactive shell:
Übergibt man zwei Ganzzahlen an range(), gibt die Funktion ein Wertebereich-Objekt zurück, das von der ersten Ganzzahl (einschließlich) bis zu der zweiten Ganzzahl (ausschließlich) reicht. Probiere list(range(10, 20)) in den interaktiven Kommandozeileninterpreter einzugeben:

>>> list(range(10, 20))
>>> list(range(10, 20))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

The range() function is often used in for loops, which are much like the while loops you’ve already seen.
range() wird häufig in for-Schleifen benutzt, die den uns bereits bekannten while-Schleifen sehr ähneln.

for Loops
for-Schleifen

The for loop is useful for looping over a list of values. This is different from the while loop, which loops as long as a certain condition is True. A for statement begins with the for keyword, followed by a new variable name, followed by the in keyword, followed by an iterable value, and ending with a colon.
Die for-Schleife ist nützlich, um über eine Liste von Werten zu iterieren. Dies unterscheidet sich von while-Schleifen, die iterieren solange eine Bedingung erfüllt ist. Ein for-Ausdruck beginnt mit dem Schlüsselwort for, gefolgt von einem neuen Variablen-Namen, gefolgt vom Schlüsselwort in, gefolgt von einem iterierbaren Wert, und endet schließlich mit einem Doppelpunkt.

An iterable is a value of the list, range, or string data types. There are also other data types that are considered iterables which will be introduced later.
Ein iterierbarer Wert ist ein Wert des Typs Liste (list), Wertebereich (range) oder Zeichenkette (string). Es gibt einige weitere iterierbare Datentypen, auf die wir später eingehen.

Each time the program execution iterates through the loop the new variable in the for statement is assigned the value of the next item in the list.
Bei jeder Schleifen-Iteration wird der neuen Variable im for-Ausdruck ein weiteres Element aus der Liste zugewiesen.

>>> for i in range(5):
>>> for i in range(5):
...     print('i is set to ' + str(i))
...     print('i ist gleich ' + str(i))
...
...
i is set to 0
i ist gleich 0
i is set to 1
i ist gleich 1
i is set to 2
i ist gleich 2
i is set to 3
i ist gleich 3
i is set to 4
i ist gleich 4

The range object returned by range(5) is equivalent to the list [0, 1, 2, 3, 4] in a for statement. The first time the execution goes through the code in for-block, the variable i will be set to 0. On the next iteration, i will be set to 1, and so on.
Das von range(5) zurückgegebene Wertebereich-Objekt ist equivalent zu der Liste [0, 1, 2, 3, 4] in einem for-Ausdruck. Wenn sich die Programmausführung das erste Mal im for-Block befindet, hat i den Wert 0. Bei der nächsten Iteration, hat i den Wert 1, und so weiter.

The for statement automatically converts the range object returned by range() into a list, so there’s no need for list(range(5)) in the for statement. Just use range(5).
Der for-Ausdruck konvertiert das von range() zurückgegebene Wertebereich-Objekt automatisch in eine Liste, so dass man nicht extra list(range(5)) aufrufen braucht. range(5) genügt.

Lists and strings are also iterable data types. You can use them in for statements. Try entering the following into the interactive shell:
Listen und Zeichenketten können ebenfalls iteriert werden. Man kann sie in for-Ausdrücken verwenden. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> for thing in ['cats', 'pasta', 'programming', 'spam']:
>>> for ding in ['Katzen', 'Pasta', 'Programmierung', 'spam']:
...     print('I really like ' + thing)
...     print('Ich mag ' + ding + ' sehr')
...
...
I really like cats
Ich mag Katzen sehr
I really like pasta
Ich mag Pasta sehr
I really like programming
Ich mag Programmierung sehr
I really like spam
Ich mag spam sehr

>>> for i in 'Hello':
>>> for i in 'Hallo':
...     print(i)
...     print(i)
...
...
H
H
e
a
l
l
l
l
o
o

A while Loop Equivalent of a for Loop
Eine zur for-Schleife equivalente while-Schleife

The for loop is similar to the while loop, but when you only need to iterate over items in a list, using a for loop is much less code to type. This is a while loop that acts the same as the previous for loop by adding extra code:
Die for-Schleife ähnelt der while-Schleife sehr, aber wenn man nur über Element einer Liste iterieren braucht, bedeutet die for-Schleife viel weniger Tipparbeit. So würde das vorherige Codebeispiel realisiert mit einer while-Schleife aussehen:

>>> iterableVal = ['cats', 'pasta', 'programming', 'spam']
>>> iterierbarerWert = ['Katzen', 'Pasta', 'Programmierung', 'spam']
>>> index = 0
>>> index = 0
>>> while (index < len(iterableVal)):
>>> while (index < len(iterierbarerWert)):
...     thing = iterableVal[index]
...     ding = iterierbarerWert[index]
...     print('I really like ' + thing)
...     print('Ich mag ' + ding ' sehr')
...     index = index + 1
...     index = index + 1
...
...
I really like cats
Ich mag Katzen sehr
I really like pasta
Ich mag Pasta sehr
I really like programming
Ich mag Programmierung sehr
I really like spam
Ich mag spam sehr

But using the for statement automatically does this extra code and makes programming easier since you have less to type.
Die Verwendung des for-Ausdrucks erübrigt die Einführung des Extra-Codes und erspaart uns Tipparbeit.

The rest of the displayBoard() function displays the missed letters and creates the string of the secret word with all the not yet guessed letters as blanks.
Der Rest der zeigeSpielbrettAn()-Funktion zeigt die falschen Buchhstaben an und erstellt eine Zeichenkette, in der die noch nicht erratenen Buchstaben im Geheimwort durch Unterstriche ersetzt sind.

 70.     print('Falsche Buchstaben:', end=' ')
 71.     for buchstabe in falscheBuchstaben:
 72.         print(buchstabe, end=' ')
 73.     print()

The for loop on line 71 will iterate over each character in the missedLetters string and print them on the screen. Remember that the end=' ' will replace the newline character that is printed after the string with a single space character.
Die for-Schleife in Zeile 71 iteriert über jedes Zeichen in falscheBuchstaben und gibt es auf dem Bildschirm aus. Vergiss nicht, dass end=' ' die neue Zeile, die normalerweise nach einer Zeichenkette ausgegeben wird, durch ein Leerzeichen ersetzt.

For example, if missedLetters was 'ajtw' this for loop would display a j t w.
Falls zum Beispiel falscheBuchstaben den Wert 'ajtw' hätte, würde die for-Schleife a j t w ausgeben.

Slicing
Slicing

List slicing creates a new list value with a subset of another list’s items. In code, specify two indexes (the beginning and end) with a colon in the square brackets after a list. For example, try entering the following into the interactive shell:
Das englische Verb “to slice” bedeutet in Deutsch “schneiden” oder auch “in Scheiben schneiden”. Letztere Bedeutung entspricht dem Slicing in Python. Dieses erlaubt es, neue Listen aus Teilmengen anderer Listen zu erstellen. Im Code spezifiziert man zwei durch einen Doppelpunkt getrennte Indizes (Anfang und Ende) in den eckigen Klammern hinter einer Liste. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = ['apples', 'bananas', 'carrots', 'dates']
>>> spam = ['Äpfel', 'Bananen', 'Karotten', 'Daten']
>>> spam[1:3]
>>> spam[1:3]
['bananas', 'carrots']
['Bananen', 'Karotten']

The expression spam[1:3] evaluates to a list with items from index 1 up to (but not including) index 3 in spam.
Der Ausdruck spam[1:3] evaluiert zu einer Liste mit den Elmenten von Index 1 (einschließlich) bis 3 (ausschließlich) aus spam.

If you leave out the first index, Python will automatically think you want index 0 for the first index:
Lässt man den ersten Index aus, nimmt Python automatisch 0 an:

>>> spam = ['apples', 'bananas', 'carrots', 'dates']
>>> spam = ['Äpfel', 'Bananen', 'Karotten', 'Daten']
>>> spam[:2]
>>> spam[:2]
['apples', 'bananas']
['Äpfel', 'Banenen']

If you leave out the second index, Python will automatically think you want the rest of the list:
Lässt man den zweiten Index aus, nimmt Python automatisch die Länge der Liste an:

>>> spam = ['apples', 'bananas', 'carrots', 'dates']
>>> spam = ['Äpfel', 'Bananen', 'Karotten', 'Daten']
>>> spam[2:]
>>> spam[2:]
['carrots', 'dates']
['Karotten', 'Daten']

Slicing is a simple way to get a subset of the items in a list. You use slices with strings in the same way you use them with lists. Each character in the string is like an item in the list. Try entering the following into the interactive shell:
Schneiden erlaubt es uns auf einfache Weise, Teilmengen aus Listen zu extrahieren. Schnitte funktionieren mit Zeichenketten genauso wie mit Listen. Jedes Zeichen in der Zeichenkette wird wie ein Element einer Liste behandelt. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> myName = 'Zophie the Fat Cat'
>>> meinName = 'Sofie die dicke Katze'
>>> myName[4:12]
>>> meinName[4:12]
'ie the F'
'e die di'
>>> myName[:10]
>>> meinName[:10]
'Zophie the'
'Sofie die '
>>> myName[7:]
>>> meinName[7:]
'the Fat Cat'
'ie dicke Katze'

The next part of the code in Hangman uses slicing.
Der nächste Teil des Codes in Galgenmann verwendet slicing.

Displaying the Secret Word with Blanks
Das Geheimwort mit Unterstrichen darstellen

Now you want code to print the secret word, but with blank lines for the letters that have not been guessed. You can use the _ character (called the underscore character) for this. First create a string with nothing but one underscore for each letter in the secret word. Then replace the blanks for each letter in correctLetters.
Als Nächstes wollen wir das Geheimwort ausgeben, jedoch mit Unterstrichen (_) an Stelle der nicht erratenen Buchstaben. Zuerst erstellen wir eine Zeichenkette, die genauso lang ist wie das Geheimwort und nur aus Unterstrichen besteht. Danach ersetzen wir Unterstriche mit Buchstaben aus richtigeBuchstaben.

So if the secret word was 'otter' then the blanked out string would be '_____' (five _ characters). If correctLetters was the string 'rt' you would change the string to '_tt_r'. Line 75 to 79 is the code that does that.
Wäre das Geheimwort 'bieber', dann bestünde die redigierte Zeichenkette aus sechs Unterstrichen '______'. Beinhaltete richtigeBuchstaben nun die Zeichenkette 'be', so würde die redigierte Zeichenkette zu 'b_ebe_' geändert. Die Zeilen 75 bis 79 sind dafür verantwortlich.

 75.     luecken = '_' * len(geheimWort)

Line 75 creates the blanks variable full of _ underscores using string replication. Remember that the * operator can also be used on a string and an integer, so the expression '_' * 5 evaluates to '_____'. This will make sure that blanks has the same number of underscores as secretWord has letters.
Zeile 75 erstellt die redigierte Variable mittels Zeichenketten-Replikation. Der Operator * kann auf eine Zeichenkette und eine Ganzzahl angewandt werden; der Ausdruck '_' * 6 evaluiert zu '______'. Dies stellt sicher, dass luecken genauso viele Unterstriche enthält, wie geheimWort Buchstaben.

 77.  for i in range(len(geheimWort)): # Ersetze Lücken mit korrekt geratenen Buchstaben
 78.         if geheimWort[i] in richtigeBuchstaben:
 79.             luecken = luecken[:i] + geheimWort[i] + luecken[i+1:]

Line 77 has a for loop to go through each letter in secretWord and replace the underscore with the actual letter if it exists in correctLetters.
Zeile 77 definiert eine for-Schleife, die durch alle Buchstaben in geheimWort iteriert und Unterstriche durch die tatsächlichen Buchstaben ersetzt, falls sie in richtigeBuchstaben enthalten sind.

For example, pretend the value of secretWord is 'otter' and the value in correctLetters is 'tr'. You would want the string '_tt_r' displayed to the player. Let’s figure out how to create this string.
Nehmen wir an, geheimWort habe den Wert 'bieber' und richtigeBuchstaben habe den Wert 'be'. Dann sollte dem Spieler der Text 'b_ebe_' angezeigt werden. Finden wir heraus, wie man diese Zeichenkette erstellt.

Line 77’s len(secretWord) call would return 5. The range(len(secretWord)) call becomes range(5), which makes the for loop iterate over 0, 1, 2, 3, and 4.
Der Aufruf len(geheimWort) in Zeile 77 würde 6 zurückgeben. range(len(geheimWort)) wird zu range(6), sodass die for-Schleife über die Werte 0, 1, 2, 3, 4 und 5 iteriert.

Because the value of i will take on each value in [0, 1, 2, 3, 4], the code in the for loop is the same as this:
Da der i jeden der Werte in [0, 1, 2, 3, 4, 5] annehmen wird, ist die for-Schleife equivalent zu folgendem Code:

if geheimWort[0] in richtigeBuchstaben:
    luecken = luecken[:0] + geheimWort[0] + luecken[1:]

if geheimWort[1] in richtigeBuchstaben:
    luecken = luecken[:1] + geheimWort[1] + luecken[2:]
    
if geheimWort[2] in richtigeBuchstaben:
    luecken = luecken[:2] + geheimWort[2] + luecken[3:]
    
if geheimWort[3] in richtigeBuchstaben:
    luecken = luecken[:3] + geheimWort[3] + luecken[4:]
    
if geheimWort[4] in richtigeBuchstaben:
    luecken = luecken[:4] + geheimWort[4] + luecken[5:]
    
if geheimWort[5] in richtigeBuchstaben:
    luecken = luecken[:5] + geheimWort[5] + luecken[6:]

If you are confused as to what the value of something like secretWord[0] or blanks[3:] is, then look at Figure 9-2. It shows the value of the secretWord and blanks variables, and the index for each letter in the string.
Falls Du nicht sicher bist, was Ausdrücke wie geheimWort[0] oder luecken[3:] representieren, dann schaue Dir Abbildung 9-2 an. Sie zeigt die Werte der Variablen geheimWort und luecken mit den dazugehörigen Indizes.

Figure 9-2: The indexes of the blanks and secretWord strings.
Abbildung 9-2: Die Indizes der Zeichenketten luecken und geheimWort.

If you replace the list slices and the list indexes with the values that they represent, the loop code would be the same as this:
Ersetzten wir die Listen-Schnitte- und Indizes mit den Werten, die sie representieren, dann würde die Schleife wie folgt aussehen:

if 'b' in 'be': # True
    luecken = '' + 'b' + '_____' # Diese Zeile wird ausgeführt.

if 'i' in 'be': # False
    blanks = 'b' + 'i' + '____' # Diese Zeile wird übersprungen.

if 'e' in 'be': # True
    luecken = 'b_' + 'e' + '___' # Diese Zeile wird ausgeführt.

if 'b' in 'be': # True
    luecken = 'b_e' + 'b' + '__' # Diese Zeile wird ausgeführt.

if 'e' in 'be': # True
    luecken = 'b_eb' + 'e' + '_' # Diese Zeile wird ausgeführt.
    
if 'r' in 'be': # False
    luecken = 'b_ebe' + 'r' + '' # Diese Zeile wird übersprungen.

# luecken hat jetzt den Wert 'b_ebe_'

The above code examples all do the same thing when secretWord is 'otter' and correctLetters is 'tr'. The next few lines of code print the new value of blanks with spaces between each letter.
Die obigen Code-Beispiele verhalten sich alle gleich, wenn geheimWort den Wert 'bieber' und richtigeBuchstaben den Wert 'be' haben. Die folgenden Zeilen geben den neuen Wert von luecken mit Leerzeichen zwischen jedem Buchstaben auf dem Bildschirm aus.

 81.     for buchstabe in luecken: # Zeige das Geheimwort mit Leerzeichen zwischen den Buchstaben
 82.         print(buchstabe, end=' ')
 83.     print()

Get the Player’s Guess
Spielereingaben lesen

The getGuess() function will be called so that the player can enter a letter to guess. The function returns the letter the player guessed as a string. Further, getGuess() will make sure that the player types a valid letter before returning from the function.
Die rateBuchstabe()-Funktion wird aufgerufen, damit der Spieler einen Buchstaben eingeben kann. Die Funktion gibt die Eingabe des Spielers als Zeichenkette zurück. Darüber hinaus stellt sie sicher, dass der Spieler einen gültigen Buchstaben eingegeben hat, bevor sie zurückkehrt.

 85. def rateBuchstabe(bereitsGeraten):
 86.     # Stellt sicher, dass der Spieler nur einen einzelnen Buchstaben eintippt und gibt ihn zurück.

A string of the letters the player has guessed is passed as the argument for the alreadyGuessed parameter. Then the getGuess() function asks the player to guess a single letter. This single letter will be getGuess()’s return value.
Eine Zeichenkette mit den vom Spieler bereits geratenen Buchstaben wird als Argument an den Parameter bereitsGeraten übergeben. Danach bittet die rateBuchstabe()-Funktion den Spieler, einen einzelnen Buchstaben zu erraten. Dieser wird zum Rückgabewert von rateBuchstabe().

 87.     while True:
 88.         print('Rate einen Buchstaben.')
 89.         eingabe = input()
 90.         eingabe = eingabe.lower()

Line 87’s while loop will keep asking the player for a letter until they enter text that is:
Die while-Schleife in Zeile 87 fragt den Spieler solange nach seiner Eingabe, bis dieser einen Text eingibt, der folgenden Kriterien entspricht:

1.  A single letter.
1.  Es handelt sich um einen einzelnen Buchstaben.
2.  A letter they have not guessed previously.
2.  Der Spieler hat den Buchstaben noch nicht getippt.

The condition for the while loop is simply the Boolean value True. That means the only way execution will ever leave this loop is by executing a break statement (which leaves the loop) or a return statement (which leaves not just the loop but the entire function).
Als Abbruch-Bedingung an die while-Schleife wird der Wert True übergeben. Das bedeutet, dass die Programmausführung die Schleife nur dann verlassen wird, wenn sie auf eine break-Anweisung (, die die Schleife verlässt,) oder auf eine return-Anweisung (, die nicht nur die Schleife, sondern die gesamte Funktion verlässt,) trifft.

The code inside the loop asks the player to enter a letter, which is stored in the variable guess. If the player entered a capitalized letter, it will be overwritten with a to lowercase letter on line 90.
Der obige Code bittet den Spieler einen Buchstaben einzugeben, der in der Variablen eingabe gespeichert wird. Falls der Spieler einen Großbuchstaben eingibt, wird dieser vor dem Speichern in eingabe in einen Kleinbuchstaben umgewandelt.

elif (“Else If”) Statements
elif (“Else If”)-Ausdrücke

The next part of the Hangman program uses elif statements. You can think of elif “else if” statements as saying “If this is true, do this. Or else if this next condition is true, do that. Or else if none of them are true, do this last thing.”
Der nächste Abschnitt des Galgenmann-Programms benutzt elif-Ausdrücke. elif-Ausdrücke (kurz für “else if”, zu Deutsch “sonst, falls”) kann man sich wie die Formulierung “Falls dies wahr ist, tue dies. Sonst, falls die nächste Bedingung wahr ist, tue das” vorstellen.

Take a look at the following code:
Schauen wir uns folgenden Code an:

if catName == 'Fuzzball':
if katzenName == 'Struppi':
    print('Your cat is fuzzy.')
    print('Deine Katze ist struppig.')
elif catName == 'Spots':
elif katzenName == 'Flecki':
        print('Your cat is spotted.')
        print('Deine Katze ist gefleckt.')
else:
else:
    print('Your cat is not fuzzy or spotted.')
    print('Deine Katze ist weder struppig noch gefleckt.')

If the catName variable is equal to the string 'Fuzzball', then the if statement’s condition is True and the if-block tells the user that their cat is fuzzy. However, if this condition is False, then Python tries the elif (“else if”) statement’s condition next. If catName is 'Spots', then the 'Your cat is spotted.' string is printed to the screen. If both are False, then the code tells the user their cat isn’t fuzzy or spotted.
Falls die katzenName-Variable gleich der Zeichenkette 'Struppi' ist, dann ist die Bedingung der ersten if-Anweisung wahr und der if-Block sagt dem Benutzer, er habe eine struppige Katze. Falls (und nur falls(!)) jedoch die Bedingung falsch ist, testet Python die Bedingung der elif-Anweisung als Nächstes. Ist katzenName gleich 'Flecki', so wird 'Deine Katze ist gefleckt.' ausgegeben. Falls (und nur falls(!)) jedoch beide Bedingungen falsch sind, sagt der Code dem Benutzer, seine Katze sei weder struppig, noch gefleckt.

You can have as many elif statements as you want:
Es können beliebig viele elif-Anweisungen hintereinander stehen:

if catName == 'Fuzzball':
if katzenName == 'Struppi':
    print('Your cat is fuzzy.')
    print('Deine Katze ist struppig.')
elif catName == 'Spots':
elif katzenName == 'Flecki':
    print('Your cat is spotted.')
    print('Deine Katze ist gefleckt.')
elif catName == 'Chubs':
elif katzenName == 'Smoky':
    print('Your cat is chubby.')
    print('Deine Katze hat schwarze Augen.')
else:
    print('Your cat is neither fuzzy nor spotted nor chubby nor puffy.')
    print('Deine Katze ist weder struppig, noch gefleckt, noch hat sie schwarze Augen.')

When one of the elif conditions is True, its code is executed and then execution jumps to the first line past the else-block. So one and only one of the blocks in the if-elif-else statements will be executed. You can also leave off the else-block if you don’t need one, and just have if-elif statements.
Ist eine der elif-Bedingungen wahr, so wird ihr Code ausgeführt und die Programmausführung springt zur ersten Zeile nach dem else-Block. D.h. in einem if-elif-else-Ausdruck wird nur ein einziger Block ausgeführt. Der else-Block am Ende ist optional.

Making Sure the Player Entered a Valid Guess
Die Gültigkeit von Rateversuchen garantieren

 91.         if len(eingabe) != 1:
 92.             print('Bitte gib einen einzelnen Buchstaben ein.')
 93.         elif eingabe in bereitsGeraten:
 94.             print('Du hast diesen Buchstaben bereits probiert. Rate noch einmal.')
 95.         elif eingabe not in 'abcdefghijklmnopqrstuvwxyz':
 96.             print('Bitte gib einen BUCHSTABEN ein.')
 97.         else:
 98.             return eingabe

The guess variable contains player’s letter guess. The program needs to make sure they typed in a valid guess: one and only one lowercase letter. If they didn't, the execution should loop back and ask them for a letter again.
Die Variable eingabe beinhaltet den vom Spieler eingegebenen Text. Das Programm muss sicherstellen, dass dieser gültig ist: Er darf nur aus einem einzelnen Kleinbuchstaben bestehen. Hat der Spieler etwas anderes eingegeben, so sollte das Programm ihn erneut auffordern.

Line 91’s condition checks if guess is not one character long. Line 93’s condition checks if guess already exists inside the alreadyGuessed variable. Line 95’s condition checks if guess is not a lowercase letter.
Die Bedingung in Zeile 91 prüft, ob die Eingabe eine andere Länbge als eins hat. Zeile 93 überprüft, ob der Spieler den Buchstaben bereits probiert hat (ob dieser in der bereitsGeraten-Variablen enthalten ist). Zeile 95 prüft, ob es sich um ein ungültiges Zeichen (ein Zeichen, dass kein Kleinbuchstabe ist (z.B. Großbuchstaben oder andere Zeichen)) handelt.

If all of these conditions are False, then the else statement’s block executes and getGuess() returns the value in guess on line 98.
Sind alle Bedingungen falsch, wird der else-Block ausgeführt und rateBuchstabe() gibt den Wert von eingabe in Zeile 98 zurück.

Remember, only one of the blocks in if-elif-else statements will be executed.
Wir erinnern uns daran, dass nur einer der Blöcke in einem if-elif-else-Ausdruck ausgeführt wird.

Asking the Player to Play Again
Den Spieler um eine weitere Partie fragen

100. def spieleNochEinmal():
101.     # Diese Funktion True zurück, falls der Spieler noch einmal spielen möchte, False sonst.
102.     print('Möchtest Du noch einmal spielen? (ja oder nein)')
103.     return input().lower().startswith('j')

The playAgain() function has just a print() function call and a return statement. The return statement has an expression that looks complicated, but you can break it down. Here’s a step by step look at how Python evaluates this expression if the user types in YES.
Die Funktion spieleNochEinmal() besteht nur aus einem print()-Aufruf und einer return-Anweisung. Der Ausdruck in der return-Anweisung mag zunächst kompliziert erscheinen, aber man kann ihn leicht in seine Einzelteile zerlegen. Hier ist eine Schritt-für-Schritt-Veranschaulichung, wie Python den Ausdruck interpretiert (unter der Annahme, der Spieler hätte JA eingegeben):

input().lower().startswith('j')
            ▼
   'JA'.lower().startswith('j')
            ▼
           'ja'.startswith('j')
            ▼
           True

The point of the playAgain() function is to let the player type in yes or no to tell the program if they want to play another round of Hangman. The player should be able to type YES, yes, Y, or anything else that begins with a “Y” in order to mean “yes”. If the player types in YES, then the return value of input() is the string 'YES'. And 'YES'.lower() returns the lowercase version of the attached string. So the return value of 'YES'.lower() is 'yes'.
Die spieleNochEinmal()-Funktion erlaubt dem Spieler ja oder nein einzugeben, je nachdem ob dieser weiterspielen möchte oder nicht. Dabei sollte es dem Spieler möglich sein, JA, ja, j oder irgendetwas anderes, das mit 'j' beginnt, einzugeben. Gibt der Spieler JA ein, so ist der Rückgabewert von input() 'JA'. 'JA'.lower() gibt 'ja' zurück.

But there’s the second method call, startswith('y'). This function returns True if the associated string begins with the string parameter between the parentheses, and False if it doesn’t. The return value of 'yes'.startswith('y') is True.
Schließlich folgt der Methoden-Aufruf startswith('j'). Diese Funktion gibt True zurück, falls die Zeichenkette, an der sie aufgerufen wird, mit dem als Argument übergebenen Präfix beginnt, False sonst. Der Rückgabewert von 'ja'.startswith('j') ist True.

Now you have evaluated this expression! What it does is let the player type in a response, lowercases the response, checks if it begins with the letter 'y', then returns True if it does and False if it doesn’t.
Damit ist die Analyse dieses Ausdrucks abgeschlossen. Er lässt den Spieler etwas eingeben, wandelt die Eingabe in Kleinbuchstaben um und testet, ob sie mit 'j' beginnt. Ist dies der Fall, so wird True zurückgegeben, False sonst.

On a side note, there’s also an endswith(someString) string method that will return True if the string ends with the string in someString and False if it doesn’t. endswith() is sort of like the opposite of startswith().
Der Vollständigkeit halber sei hier erwähnt, dass es auch eine endswith()-Methode gibt, die True zurückgibt, falls die Zeichenkette, an der sie aufgerufen wird, mit dem als Argument übergebenen Suffix endet.

Review of the Hangman Functions
Zusammenfassung der Funktionen in Galgenmann

That’s all the functions we are creating for this game! Let’s review them:
Dies waren alle Funktionen, die wir für dieses Spiel geschrieben haben. Hier die Zusammenfassung:

• getRandomWord(wordList) will take a list of strings passed to it, and return one string from it. That is how a word is chosen for the player to guess.
• geheimWort(wortListe) akzeptiert eine Liste von Zeichenketten und gibt eine (zufällig ausgewählte) davon zurück. Auf diese Weise wird das zu erratende Wort für den Spieler ausgesucht.
• displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord) will show the current state of the board, including how much of the secret word the player has guessed so far and the wrong letters the player has guessed. This function needs four parameters passed to work correctly. HANGMANPICS is a list of strings that hold the ASCII art for each possible hangman board. correctLetters and missedLetters are strings made up of the letters that the player has guessed that are in and not in the secret word, respectively. And secretWord is the secret word the player is trying to guess. This function has no return value.
• zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort) malt das Spielbrett inklusive des (teilweise erratenen) Geheim-Wortes und den falschen Rateversuchen auf den Bildschirm. Diese Funktion akzeptiert vier Parameter. GALGENMANNBILDER ist eine Liste von Zeichenketten, die das Spielbrett in verschiedenen Etappen als ASCII-Kunst representieren. richtigeBuchstaben und falscheBuchstaben sind Zeichenketten, die aus den richtigen und falschen Rateversuchen des Spielers bestehen. geheimWort ist das geheime Wort, das der Spieler erraten muss. Diese Funktion hat keinen Rückgabewert.
• getGuess(alreadyGuessed) takes a string of letters the player has already guessed and will keep asking the player for a letter that isn’t in alreadyGuessed.) This function returns the string of the valid letter the player guessed.
• rateBuchstabe(bereitsGeraten) akzeptiert eine Zeichenkette aus Buchstaben, die der Spieler bereits getippt hat. Die Funktion fragt den Spieler solange nach einer Eingabe, bis dieser einen einzelnen Kleinbuchstaben eingibt, der nicht bereits in bereitsGeraten enthalten ist. Die Eingabe des Spielers wird zurückgegeben.
• playAgain() is a function that asks if the player wants to play another round of Hangman. This function returns True if the player does and False if the player doesn’t.
• spieleNochEinmal() fragt den Spieler, ob er eine weitere Partie Galgenmann spielen möchte. Ist dies der Fall, so gibt die Funktion True zurück, False sonst.

After the functions is the code for the main part of the program at line 106. Everything previous was just function definitions and a large assignment statement for HANGMANPICS.
Nach den Funktionen folgt in Zeile 106 der Code für das Haupt-Programm. Alles zuvor waren nur Funktions-Definitionen und eine große Zuweisung an die Variable GALGENMANNBILDER.

Setting Up the Variables
Die Variablen initialisieren

106. print('G A L G E N M A N N')
107. falscheBuchstaben = ''
108. richtigeBuchstaben = ''
109. geheimWort = zufallsWort(worte)
111. spielIstBeendet = False

Line 106 is the first print() call that executes when the game is run. It displays the title of the game. Next is assigning blank strings for missedLetters and correctLetters since the player hasn’t guessed any missed or correct letters yet.
Zeile 106 beinhaltet den ersten print()-Aufruf des gesamten Spiels. Dieser zeigt den Spieletitel an. Als Nächstes werden falscheBuchstaben und richtigeBuchstaben leere Zeichenketten zugewiesen (da der Spieler noch keine Rateversuche unternommen hat).

The getRandomWord(words) call will evaluate to a randomly selects word from the words list.
Der zufallsWort(worte)-Aufruf evaluiert zu einem zufällig ausgewählten wort aus der Liste worte.

Line 110 sets gameIsDone to False. The code will set gameIsDone to True when it wants to signal that the game is over and should ask the player if they want to play again.
Zeile 110 setzt spielIstBeendet auf False. Der Code wird diese Variable dann auf True setzen, wenn eine Runde von Galgenmann vorbei ist und der Spieler gefragt werden sollte, ob er noch eine spielen möchte.

Displaying the Board to the Player
Das Spielbrett anzeigen

112. while True:
113.     zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)

The while loop’s condition is always True, which means it will loop forever until a break statement is encountered. (This happens later on line 147.)
Die Bedingung der while-Schleife ist immer True. D.h. sie wird solange iterieren, bis eine break-Anweisung ausgeführt wird. (Dies passiert später in Zeile 147.)

Line 113 calls the displayBoard() function, passing it the list of hangman ASCII art pictures and the three variables set on lines 107, 108, and 109. Based on how many letters the player has correctly guessed and missed, this function displays the appropriate hangman board to the player.
Zeile 113 ruft die zeigeSpielbrettAn()-Funktion auf und übergibt ihr eine Liste mit ASCII-Kunst-Galgenmann-Bildern, sowie den drei in den Zeilen 107, 108 und 109 initialisierten Variablen. Abhängig von den korrekten und falschen Rateversuchen des Spielers, zeigt diese Funktion das entsprechende Spielbrett an.

Letting the Player Enter Their Guess
Benutzereingabe abfragen

115.     # Lass den Spieler einen Buchhstaben eingeben.
116.     buchstabe = rateBuchstabe(falscheBuchstaben + richtigeBuchstaben)

The getGuess() function needs all the letters in missedLetters and correctLetters combined, so line 116 concatenates the strings in these variables and passes the result as the argument. This argument is needed by getGuess() because the function has to check if the player types in a letter that they have already guessed.
Die rateBuchstabe()-Funktion benötigt die Buchstaben in falscheBuchstaben und richtigeBuchstaben, weshalb Zeile 116 beide Variablen konkateniert und das Ergebnis als Argument übergibt. Das Argument wird benötigt, weil rateBuchstabe() überprüfen muss, ob der Spieler einen Buchstaben bereits entweder erraten oder getippt hat.

Checking if the Letter is in the Secret Word
Überprüfen, ob der geratene Buchstabe im geheimen Wort enthalten ist

118.     if buchstabe in geheimWort:
119.         richtigeBuchstaben = richtigeBuchstaben + buchstabe

If the guess string exists in secretWord, then concatenate guess to the end of the correctLetters string. This string will be the new value of correctLetters.
Falls das geheime Wort den geratenen Buchstaben enthält, so wird dieser an das Ende von richtigeBuchstaben angehängt.

Checking if the Player has Won
Überprüfen, ob der Spieler gewonnen hat

121.         # Überprüfe, ob der Spieler gewonnen hat
122.         alleBuchstabenGeraten = True
123.         for i in range(len(geheimWort)):
124.             if geheimWort[i] not in richtigeBuchstaben:
125.                 alleBuchstabenGeraten = False
126.                 break

How can the program know if the player has guessed every letter in the secret word? Well, correctLetters has each letter that the player correctly guessed and secretWord is the secret word itself. But you can’t just check if correctLetters == secretWord because consider this case: if secretWord was the string 'otter' and correctLetters was the string 'orte', then correctLetters == secretWord would be False even though the player has guessed each letter in the secret word.
Wie kann das Programm wissen, dass der Spieler jeden Buchstaben des Geheimwortes richtig geraten hat? Da richtigeBuchstaben alle korrekten Rateversuche des Spielers enthält und geheimWort das geheime Wort selbst ist, liegt der Gedanke nahe, beide Variablen zu vergleichen: richtigeBuchstaben == geheimWort. Dies wäre jedoch falsch. Nehmen wir an, das geheime Wort sei 'bieber' und richtigeBuchstaben habe den Wert 'eibr'. In dem Fall würde geheimWort == richtigeBuchstaben zu False evaluieren, obwohl der Spieler jeden Buchstaben des Geheimwortes erraten hat.

The only way you can be sure the player won is to iterate over each letter in secretWord and see if it exists in correctLetters. If, and only if, every letter in secretWord exists in correctLetters will the player have won.
Die korrekte Lösung lautet, über jeden Buchstaben in geheimWort zu iterieren und zu testen, ob er in richtigeBuchstaben enthalten ist. Dann, und nur dann, hat der Spieler gewonnen.

If you find a letter in secretWord that doesn’t exist in correctLetters, you know that the player has not guessed all the letters. The new variable foundAllLetters is set to True on line 122 before the loop begins. The loop starts out assuming that all the letters in the secret word have been found. But the loop’s code on line 125 will change foundAllLetters to False the first time it finds a letter in secretWord that isn’t in correctLetters.
Stoßen wir auf einen Buchstaben in geheimWort, der nicht in richtigeBuchstaben enthalten ist, so wissen wir, dass der Spieler noch nicht alle Buchhstaben erraten hat. Die neue Variable alleBuchstabenGeraten wird in Zeile 122 auf True gesetzt. Die Schleife beginnt also mit der Annahme, dass der Spieler gewonnen habe. Stößt die Schleife jedoch auf einen  noch nicht erratenen Buchstaben, so setzt sie alleBuchstabenGeraten auf False.

127.         if alleBuchstabenGeraten:
128.             print('Ja! Das geheime Wort ist "' + geheimWort + '"! Du hast gewonnen!')
129.             spielIstBeendet = True

If all letters in the secret word have been found, the player is told they have won and gameIsDone is set to True.
Sind alle Buchstaben des Geheimwortes erraten, wird der Spieler über seinen Sieg benachrichtigt.

When the Player Guesses Incorrectly
Wenn der Spieler falsch tippt

130.     else:
131.         falscheBuchstaben = falscheBuchstaben + buchstabe

This is the start of the else-block. Remember, the code in this block will execute if the condition was False. But which condition? To find out, point your finger at the start of the else keyword and move it straight up like in Figure 9-3. You’ll see that the else keyword's indentation is the same as the if keyword's indentation on line 118.
Hier beginnt der else-Block. Der Code in diesem Block wird dann ausgeführt, wenn die Bedingung in Zeile 118 falsch war.

Figure 9-3: The else statement is matched with the if statement at the same indentation.
Abbildung 9-3: Der else-Ausdruck gehört zum if-Ausdruck mit derselben Einrückung.

So if the condition on line 118 (guess in secretWord) was False, then the execution moves into this else-block.

Wrongly guessed letters are concatenated to the missedLetters string on line 131. This is like what line 119 did for letters the player guessed correctly.
Falsch geratene Buchstaben werden in Zeile 131 an falscheBuchstaben angehängt, genauso wie dies in Zeile 119 für die richtig geratenen Buchstaben passiert.

133.         # Überprüfe, ob der Spieler zu viele Rateversuche verbraucht und damit verloren hat
134.         if len(falscheBuchstaben) == len(GALGENMANNBILDER) - 1:
135.             zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)
136.             print('Du hast zu viele Versuche gebraucht!\nNach ' + str(len(falscheBuchstaben)) + ' falsch und ' + str(len(richtigeBuchstaben)) + ' richtig geratenen Buchstaben lautet das Wort "' + geheimWort + '"')
137.             spielIstBeendet = True

Each time the player guesses wrong, the code concatenates the wrong letter to the string in missedLetters. So the length of missedLetters (or, in code, len(missedLetters)) is also the number of wrong guesses.
Jedes Mal, wenn der Spieler einen Buchstaben falsch rät, wird dieser an die Zeichenkette falscheBuchstaben angehängt. D.h. die Länge von falscheBuchstaben (in Python len(falscheBuchstaben)) ist gleich der Anzahl der falschen Rateversuche.

The HANGMANPICS list has 7 ASCII art strings. So when len(missedLetters) equals 6, you know the player has lost because the hangman picture will be finished. Remember, HANGMANPICS[0] is the first item in the list, and HANGMANPICS[6] is the last one.
Die GALGENMANNBILDER-Liste beinhaltet 7 ASCII-Kunst-Zeichenketten. Ist also len(falscheBuchstaben) gleich 6, dann hat der Spieler verloren, denn das Galgenmann-Bild ist fertig. GALGENMANNBILDER[0] bezieht sich auf das erste Element, GALGENMANNBILDER[6] auf das Letzte.

So, when the length of the missedLetters string is equal to len(HANGMANPICS) - 1 (that is, 6), the player has run out of guesses. Line 136 prints the secret word and line 137 sets the gameIsDone variable is set to True.
Ist also len(falscheBuchstaben) gleich len(GALGENMANNBILDER) - 1 (was 6 entspricht), sind dem Spieler die Rateversuche ausgegangen. Zeile 136 gibt das Geheimwort aus und Zeile 137 setzt die spielIstBeendet-Variable auf True.

139.     # Frage den Spieler, ob er noch einmal spielen möchte (aber nur, wenn das Spiel zu Ende ist).
140.     if spielIstBeendet:
141.         if spieleNochEinmal():
142.             falscheBuchstaben = ''
143.             richtigeBuchstaben = ''
144.             spielIstBeendet = False
145.             geheimWort = zufallsWort(worte)

If the player won or lost after guessing their letter, the game should ask the player if they want to play again. The playAgain() function handles getting a yes or no from the player, so it is called on line 141.
Hat der Spieler entweder gewonnen oder verloren, so sollte das Spiel ihn fragen, ob dieser noch einmal spielen möchte. Danach erkundigt sich die spieleNochEinmal()-Funktion, weshalb sie in Zeile 141 aufgerufen wird.

If the player does want to play again, the values in missedLetters and correctLetters must be reset to blank strings, gameIsDone to False, and a new secret word stored in secretWord. This way when the execution loops back to the beginning of the while loop on line 112, the board will be back to a fresh game.
Möchte der Spieler noch einmal spielen, müssen die Variablen falscheBuchstaben, richtigeBuchstaben und spielIstBeendet auf ihre Ausgangswerte zurückgesetzt und ein neues Geheimwort ausgewählt werden. Anschließend springt die Programmausführung zurück zum Anfang der while-Schleife in Zeile 112.

146.         else:
147.             break

If the player did not type in something that began with “y” when asked if they wanted to play again, then line 141’s condition would be False and the else-block executes. The break statement causes the execution to jump to the first instruction after the loop. But because there are no more instructions after the loop, the program terminates.
Entscheided sich der Spieler gegen eine neue Partie, so ist die Bedingung in Zeile 141 falsch und der else-Block wird ausgeführt. Die break-Anweisung führt zum Sprung in die erste Zeile außerhalb der Schleife. Da jedoch nach der Schleife keine Anweisungen folgen, terminiert das Programm.

Summary
Zusammenfassung

This has been a long chapter, and you’ve been introduced to several new concepts. But Hangman has been our most advanced game yet. As your games get more and more complex, it’ll be a good idea to sketch out a flow chart on paper of what happens in your program.
In diesem langen Kapitel wurden zahlreiche neue Konzepte eingeführt. Galgenmann ist unser bisher ambitioniertestes Spiel. Mit der Zeit werden Deine Programme immer komplexer. Da macht es Sinn, die Programmabläufe mit Hilfe eines Flussdiagramms zu skizieren, bevor Du Dich an die eigentliche Programmierung machst.

Lists are values that can contain other values. Methods are functions specific to a data type. Lists have append() and reverse() methods. Strings have lower(), upper(), split(), startswith(), and endswith() methods. You’ll learn about many more data types and methods in the rest of this book.
Listen sind Werte, die andere Werte enthalten können. Methoden sind an Typen gebundene Funktionen. Listen verfügen über die Methoden append() und reverse(). Zeichenketten über lower(), upper(), split(), startswith() und endswith(). Du wirst viele weitere Methoden im Rest dieses Buches kennenlernen.

The for loop is a loop that iterates over the items in a list, unlike a while loop which iterates as long as a condition is True. The elif statement lets you add an “or else if” clause to the middle of your if-else statements. The del statement can delete variables or items inside lists.
Die for-Schleife wird dazu verwendet, über die Werte in einer Liste zu iterieren, wohingegen die while-Schleife iteriert solange eine Bedingung erfüllt ist. Die del-Anweisung kann Elemente aus Listen löschen.
