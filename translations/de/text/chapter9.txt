  Kapitel 9
  GALGENMANN

In diesem Kapitel behandelte Themen:

• Mehrzeilige Zeichenketten
• Methoden
• Listen
• Die Listen-Methoden append() und reverse()
• Die Zeichenketten-Methoden lower(), upper(), split(), startswith() und endswith()
• Die Operatoren in und not in
• Die Funktionen range() und list()
• del-Ausdrücke
• for-Schleifen
• elif-Ausdrücke

Diese Kapitel führt viele neue Konzepte ein, aber keine Sorge! Wir werden mit diesen Programmier-Konzepten zuerst im interaktiven Kommandozeileninterpreter experimentieren und uns mit ihnen vertraut machen. Danach lernen wir Methoden kennen, das sind an Werte gebundene Funktionen. Wir beschäftigen uns außerdem mit einem neuen Schleifen-Typen namens for-Schleife und einem neuen Daten-Typen namens Liste. Wenn Du diese Konzepte verinnerlicht hast, gestaltet sich die Programmierung von Galgenmann gleich viel einfacher.

Quellcode zu Galgenmann

Das Spiel in diesem Kapitel ist um einiges länger als vorherige Spiele, aber vieles davon ist ASCII-Kunst für die Galgenmann-Animation. Gib folgenden Code in den Datei-Editor ein und speichere ihn als galgenmann.py ab.

galgenmann.py

  1. import random
  2. GALGENMANNBILDER = ['''
  3.
  4.   +---+
  5.   |   |
  6.       |
  7.       |
  8.       |
  9.       |
 10. =========''', '''
 11.
 12.   +---+
 13.   |   |
 14.   O   |
 15.       |
 16.       |
 17.       |
 18. =========''', '''
 19.
 20.   +---+
 21.   |   |
 22.   O   |
 23.   |   |
 24.       |
 25.       |
 26. =========''', '''
 27.
 28.   +---+
 29.   |   |
 30.   O   |
 31.  /|   |
 32.       |
 33.       |
 34. =========''', '''
 35.
 36.   +---+
 37.   |   |
 38.   O   |
 39.  /|\  |
 40.       |
 41.       |
 42. =========''', '''
 43.
 44.   +---+
 45.   |   |
 46.   O   |
 47.  /|\  |
 48.  /    |
 49.       |
 50. =========''', '''
 51.
 52.   +---+
 53.   |   |
 54.   O   |
 55.  /|\  |
 56.  / \  |
 57.       |
 58. =========''']
 59. worte = 'aal adler alligator ameise amsel bär biber bussard chamäleon dachs delfin eichhörnchen eidechse elch elefant faultier fledermaus fuchs gans gepard gorilla hai hamster hase hirsch huhn igel jaguar kamel känguru koala leopard libelle marienkäfer maulwurf meerschweinchen möwe nachtigal nilpferd panda pfau qualle ratte regenwurm schaf schimpanse schwan schwein strauß tausendfüßer tintenfisch wachtel wal wolf zebra ziege'.split()
 60.
 61. def zufallsWort(wortListe):
 62.     # Diese Funktion gibt eine zufällige Zeichenkette aus der übergebenen Zeichenketten-Liste zurück.
 63.     wortIndex = random.randint(0, len(wortListe) - 1)
 64.     return wortListe[wortIndex]
 65.
 66. def zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort):
 67.     print(GALGENMANNBILDER[len(falscheBuchstaben)])
 68.     print()
 69.
 70.     print('Falsche Buchstaben:', end=' ')
 71.     for buchstabe in falscheBuchstaben:
 72.         print(buchstabe, end=' ')
 73.     print()
 74.
 75.     luecken = '_' * len(geheimWort)
 76.
 77.     for i in range(len(geheimWort)): # Ersetze Lücken mit korrekt geratenen Buchstaben
 78.         if geheimWort[i] in richtigeBuchstaben:
 79.             luecken = luecken[:i] + geheimWort[i] + luecken[i+1:]
 80.
 81.     for buchstabe in luecken: # Zeige das Geheimwort mit Leerzeichen zwischen den Buchstaben
 82.         print(buchstabe, end=' ')
 83.     print()
 84.
 85. def rateBuchstabe(bereitsGeraten):
 86.     # Stellt sicher, dass der Spieler nur einen einzelnen Buchstaben eintippt und gibt ihn zurück.
 87.     while True:
 88.         print('Rate einen Buchstaben.')
 89.         eingabe = input()
 90.         eingabe = eingabe.lower()
 91.         if len(eingabe) != 1:
 92.             print('Bitte gib einen einzelnen Buchstaben ein.')
 93.         elif eingabe in bereitsGeraten:
 94.             print('Du hast diesen Buchstaben bereits probiert. Rate noch einmal.')
 95.         elif eingabe not in 'abcdefghijklmnopqrstuvwxyz':
 96.             print('Bitte gib einen BUCHSTABEN ein.')
 97.         else:
 98.             return eingabe
 99.
100. def spieleNochEinmal():
101.     # Diese Funktion True zurück, falls der Spieler noch einmal spielen möchte, False sonst.
102.     print('Möchtest Du noch einmal spielen? (ja oder nein)')
103.     return input().lower().startswith('j')
104.
105.
106. print('G A L G E N M A N N')
107. falscheBuchstaben = ''
108. richtigeBuchstaben = ''
109. geheimWort = zufallsWort(worte)
110. spielIstBeendet = False
111.
112. while True:
113.     zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)
114.
115.     # Lass den Spieler einen Buchhstaben eingeben.
116.     buchstabe = rateBuchstabe(falscheBuchstaben + richtigeBuchstaben)
117.
118.     if buchstabe in geheimWort:
119.         richtigeBuchstaben = richtigeBuchstaben + buchstabe
120.
121.         # Überprüfe, ob der Spieler gewonnen hat
122.         alleBuchstabenGeraten = True
123.         for i in range(len(geheimWort)):
124.             if geheimWort[i] not in richtigeBuchstaben:
125.                 alleBuchstabenGeraten = False
126.                 break
127.         if alleBuchstabenGeraten:
128.             print('Ja! Das geheime Wort ist "' + geheimWort + '"! Du hast gewonnen!')
129.             spielIstBeendet = True
130.     else:
131.         falscheBuchstaben = falscheBuchstaben + buchstabe
132.
133.         # Überprüfe, ob der Spieler zu viele Rateversuche verbraucht und damit verloren hat
134.         if len(falscheBuchstaben) == len(GALGENMANNBILDER) - 1:
135.             zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)
136.             print('Du hast zu viele Versuche gebraucht!\nNach ' + str(len(falscheBuchstaben)) + ' falsch und ' + str(len(richtigeBuchstaben)) + ' richtig geratenen Buchstaben lautet das Wort "' + geheimWort + '"')
137.             spielIstBeendet = True
138.
139.     # Frage den Spieler, ob er noch einmal spielen möchte (aber nur, wenn das Spiel zu Ende ist).
140.     if spielIstBeendet:
141.         if spieleNochEinmal():
142.             falscheBuchstaben = ''
143.             richtigeBuchstaben = ''
144.             spielIstBeendet = False
145.             geheimWort = zufallsWort(worte)
146.         else:
147.             break

Wie der Code funktioniert

  1. import random

Das Galgenmann-Programm sucht zufällig ein geheimes Wort aus einer Liste von geheimen Worten aus. Dafür benötigen wir die Funktionalität des random-Moduls, also importieren wir es.

  2. GALGENMANNBILDER = ['''
  3.
  4.   +---+
  5.   |   |
  6.       |
  7.       |
  8.       |
  9.       |
 10. =========''', '''

...der Rest des Codes ist zu groß, um ihn hier zu zeigen...

Diese eine Zuweisung erstreckt sich über die Zeilen 2 bis 58 im Code. Die Bedeutung dieses Codes wird ersichtlich, sobald wir uns mit mehrzeiligen Zeichenketten näher beschäftigt haben.

Mehrzeilige Zeichenketten

Bis jetzt waren Zeichenketten immer von einfachen Anführungszeichen umschlossen und standen in einer Zeile. Wird eine Zeichenkette jedoch von jeweils drei einfachen Anführungszeichen umschlossen, so kann sie sich über mehrere Zeilen erstrecken:

>>> fizz = '''Liebe Alice,
Ich komme am Ende des Monats zu Carols Haus zurück. Wir sehen uns dann.
Dein Freund,
Bob'''
>>> print(fizz)
Liebe Alice,
Ich komme am Ende des Monats zu Carols Haus zurück. Wir sehen uns dann.
Dein Freund,
Bob

Dies sind mehrzeilige Zeichenketten. In mehrzeiligen Zeichenketten sind Zeilenumbrüche Teil der Zeichenkette. Sie brauchen nicht durch das Escape-Zeichen \n extra kenntlich gemacht werden. Dies macht es einfacher, große Mengen an Text zu lesen.

Konstante Variablen

Der Name der Variablen GALGENMANN ist in Großbuchstaben geschrieben. Dies ist Konvention bei konstanten Variablen. Konstanten sind Variablen, deren Wert sich nach der ersten Zuweisung nie mehr ändert. Obwohl man den Wert von GALGENMANN genauso wie bei jeder anderen Variable ändern könnte, erinnert uns ihr Name, dies nicht zu tun. Es ist eine Vereinbarung zwischen Programmierern.

Wie bei allen Konventionen, braucht diese nicht befolgt zu werden. Es ist jedoch ratsam, weil es anderen Programmierern erleichtert, Deinen Code zu lesen. Sie können sich darauf verlassen, dass GALGENMANN immer den Wert haben wird, der ihr in Zeile 2 zugewiesen wurde.

Listen

Eine Liste kann mehrere Werte enthalten. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = ['Leben', 'Das Universum', 'Alles', 42]
>>> spam
['Leben', 'Das Universum', 'Alles', 42]

Die Liste spam enthält vier Werte. Die Definition beginnt mit einer öffnenden eckigen Klammer [ und endet mit einer schließenden eckigen Klammer ], ähnlich wie Zeichenketten mit Apostrophen beginnen und enden.

Kommata trennen die einzelnen Werte innerhalb einer Liste. Diese Werte bezeichnet man als Einträge.

Indizes

Probiere tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope'] in den interaktiven Kommandozeileninterpreter einzugeben um eine Liste in der Variablen tiere zu speichern. Die eckigen Klammern werden auch verwendet, um auf Elemente in der Liste zuzugreifen. Probiere tiere[0], tiere[1], tiere[2] und tiere[3] in den interaktiven Kommandozeileninterpreter einzugeben um zu sehen, wie diese Ausdrücke ausgewertet werden:

>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> tiere[0]
'Affe'
>>> tiere[1]
'Alpaka'
>>> tiere[2]
'Ameise'
>>> tiere[3]
'Antilope'

Die Zahl zwischen den eckigen Klammern ist der Index. In Python hat das erste Element in einer Liste den Index 0. Das zweite Element hat den Index 1, das dritte den Index 2, und so weiter. Weil die Indizes bei 0 und nicht bei 1 beginnen, sagt man Python sei 0-indiziert.

Listen eignen sich dafür mehrere Werte zu speichern, ohne mehrere Variablen zu verwenden. Andererseits würde der Code wie folgt aussehen:

>>> tiere1 = 'Affe'
>>> tiere2 = 'Alpaka'
>>> tiere3 = 'Ameise'
>>> tiere4 = 'Antilope'

Dieser Code wäre schwierig zu verwalten, wenn er aus hunderten oder tausenden von Zeichenketten bestünde. Eine Liste hingenen, kann beliebige Anzahlen von Werten enthalten. Über die eckigen Klammern kann auf diese Werte zugegriffen werden. Probiere tiere[0] + tiere[2] in den interaktiven Kommandozeileninterpreter einzugeben:

>>> tiere[0] + tiere[2]
'AffeAmeise'

Die Auswertung läuft wie folgt ab:

tiere[0] + tiere[2]
         ▼
'Affe'   + tiere[2]
         ▼
'Affe'   + 'Ameise'
         ▼
   'AffeAmeise'

Indizierungs-Fehler

Der Versuch auf einen Index zuzugreifen, der zu groß ist, resultiert in einem IndexError (auf Deutsch Indizierungs-Fehler) und das Programm stürzt ab. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> tiere[9999]
Traceback (most recent call last):
File "", line 1, in
tiere[99]
IndexError: list index out of range

Werte von Listen-Elementen ändern

Die eckigen Klammern können auch verwendet werden, um den Wert eines Elements in der Liste zu ändern. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> tiere[1] = 'AMEISE'
>>> tiere
['Affe', 'Alpaka', 'AMEISE', 'Antilope']

Die neue Zeichenkette 'AMEISE' überschreibt das zweite Element in der Liste tiere. tiere[1] evaluiert also zum zweiten Listen-Element in Ausdrücken, kann aber auch auf der linken Seite von Zuweisungen verwendet werden, um Werte zum zweiten Listen-Element zuzuweisen. 

Listen-Verknüpfung

Listen können mit Hilfe des Operators + zu einer Liste verknüpft werden, genauso wie Zeichenketten. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> [1, 2, 3, 4] + ['Äpfel', 'Orangen'] + ['Alice', 'Bob']
[1, 2, 3, 4, 'Äpfel', 'Orangen', 'Alice', 'Bob']
['Äpfel'] + ['Orangen'] evaluiert zu ['Äpfel', 'Orangen']. ['Äpfel'] + 'Orangen' jedoch resultiert ein einem Fehler. Eine Liste kann nicht mit einer Zeichenkette verknüpft werden. Sollen Nicht-Listen-Elemente zu einer Liste hinzugefügt werden, so verwendet man die Methode append() (später beschrieben).

Der Operator in

Der Operator in verrät Dir, ob sich ein Wert in einer Liste befindet. Der in-Operator gibt einen booleschen Wert zurück: True, falls sich der Wert in der Liste befindet, False sonst. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> 'Antilope' in tiere
True

Der Ausdruck 'Antilope' in tiere gibt True zurück, weil sich die Zeichenkette 'Antilope' in der Liste tiere befindet. Ihre Position ist Index 2.

Gibtst Du jedoch den Ausdruck 'Aal' in tiere ein, so ergibt dies False, weil die Zeichenkette 'Aal' nicht in der Liste vorkommt.

>>> tiere = ['Affe', 'Alpaka', 'Ameise', 'Antilope']
>>> 'Antilope' in tiere
True
>>> 'Aal' in tiere
False

Der Operator in funktioniert auch mit Zeichenketten. Er überprüft, ob eine Zeichenkette Teil einer anderen Zeichenkette ist. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> 'Hallo' in 'Alice sagt Hallo zu Bob.'
True

Elemente aus Listen löschen

Der del-Ausdruck löscht ein Element an einer bestimmten Position aus einer Liste. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = [2, 4, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 6, 8, 10]

Beachte, dass als Du das Element an Position 1 gelöscht hast, alle folgenden Elemente aufgerückt sind und sich ihr Index um eins verringert hat.

Du kannst den Befehl del spam[1] erneut eingeben, um weitere Elemente aus der Liste zu löschen.

>>> spam = [2, 4, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 8, 10]
>>> del spam[1]
>>> spam
[2, 10]

Der del-Ausdruck ist ein Ausdruck, er ist keine Funktion und kein Operator. Er beinhaltet keine Klammern und gibt auch keinen Wert zurück.

Listen aus Listen

Listen können selbst Listen enthalten. Nehmen wir an Du hättest eine Einkaufsliste, eine Aufgabenliste und eine Liste Deiner Lieblingskuchen. Du kannst all diese Listen in eine andere Liste einfügen. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> einkaeufe = ['Eier', 'Milch', 'Suppe', 'Aepfel', 'Brot']
>>> aufgaben = ['Sauber machen', 'Rasen maehen', 'Einkaeufe erledigen']
>>> lieblingsKuchen = ['Apfel', 'Brombeere']
>>> listeAusListen = [einkaeufe, aufgaben, lieblingsKuchen]
>>> listeAusListen
[['Eier', 'Milch', 'Suppe', 'Aepfel', 'Brot'], ['Sauber machen', 'Rasen maehen', Einkaeufe erledigen'], ['Apfel', 'Brombeere']]

Um ein Element aus einer Liste aus Listen abzufragen, benutzt man zwei Klammern-Paare: listeAusListen[1][2] würde zu 'Einkaeufe erledigen' ausgewertet werden.

Dies liegt daran, dass listeAusListen[1][2] zu ['Sauber machen', 'Rasen maehen', Einkaeufe erledigen'][2] evaluiert, was schlussendlich zu 'Einkaeufe erledigen' evaluiert:

listeAusListen[1][2]
         ▼
[['Eier', 'Milch', 'Suppe', 'Aepfel', 'Brot'], ['Sauber machen', 'Rasen maehen', Einkaeufe erledigen'], ['Apfel', 'Brombeere']][1][2]
         ▼
['Sauber machen', 'Rasen maehen', 'Einkaeufe erledigen'][2]
         ▼
'Einkaeufe erledigen'

Abbildung 9-1 ist ein weiteres Beispiel fuer eine Liste aus Listen, zusammen mit einigen Beispiel-Indizes, die auf die Elemente verweisen. Die Pfeile verweisen auf die Indizes der inneren Listen. Die Abbildung ist für eine bessere Lesbarkeit gedreht.

Methoden

Methoden sind an Werte gebundene Funktionen. Zum Beispiel besitzen alle Zeichenketten eine lower()-Methode, die eine Kopie der Zeichenkette in Kleinbuchstaben zurückgibt. Zum Beispiel gibt 'Hallo'.lower() 'hallo' zurück. lower() kann nicht alleine aufgerufen werden und man kann auch keine Argumente an lower() übergebenen (wie z.B. lower('Hallo')). Der Methoden-Aufruf muss an eine bestimmte Zeichenkette gebunden sein. Der nächste Abschnitt geht tiefer auf Zeichenketten-Methoden ein.

Abbildung 9-1: Die Indizes von einer Liste aus Listen.

Die Zeichenketten-Methoden lower() und upper()

Probiere 'Hallo Welt!'.lower() in den interaktiven Kommandozeileninterpreter einzugeben, um sich diese Methode zu veranschaulichen:

>>> 'Hallo Welt!'.lower()
'hallo welt!'

Es gibt auch eine upper()-Methode für Zeichenketten, die eine Zeichenketten in Großbuchstaben zurückgibt. Probiere 'Hallo Welt!'.upper() in den interaktiven Kommandozeileninterpreter einzugeben:

>>> 'Hallo Welt!'.upper()
'HALLO WELT!'

Da die upper()-Methode eine Zeichenkette zurückgibt, kann man an ihr ebenfalls eine Methode aufrufen. Probiere 'Hallo Welt!'.upper().lower() in den interaktiven Kommandozeileninterpreter einzugeben:

>>> 'Hallo Welt!'.upper().lower()
'hallo welt!'
'Hallo Welt!'.upper() evaluiert zu 'HALLO WELT!'. Auf dieser Zeichenkette wird die Methode lower() aufgerufen, was zu 'hallo welt!' evaluiert.

'Hallo Welt!'.upper().lower()
                    ▼
       'HALLO WELT!'.lower()
                    ▼
                'hallo welt!'

Die Reihenfolge ist wichtig. 'Hallo Welt!'.lower().upper() ist nicht dasselbe wie  'Hallo Welt!'.upper().lower():

>>> 'Hallo Welt!'.lower().upper()
'HALLO WELT!'

Die Auswertung sieht wie folgt aus:

'Hallo Welt!'.lower().upper()
                    ▼
        'hallo welt!'.lower()
                    ▼
               'HALLO WELT!'

Wenn eine Zeichenkette in einer Variablen gespeichert ist, kann man eine Zeichenketten-Methode an dieser Variablen aufrufen. Schaue Dir folgendes Beispiel an:

>>> spam = 'Hallo Welt!'
>>> spam.upper()
'HALLO WELT!'

Dieser Code ändert den Wert in spam nicht. spam beinhaltet immer noch den Wert 'Hallo Welt!'.

Beachte, dass Ganz-und Fließkommazahlen keine Methoden besitzen.

Die Listen-Methoden reverse() und append()

Listen besitzen ebenfalls Methoden. Die Methode reverse() kehrt die Reihenfolge der Elemente in einer Liste um. Probiere spam = [1, 2, 3, 4, 5, 6, 'miau', 'wuff'] gefolgt von spam.reverse() in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = [1, 2, 3, 4, 5, 6, 'miau', 'wuff']
>>> spam.reverse()
>>> spam
['wuff', 'miau', 6, 5, 4, 3, 2, 1]

Die gängigste Listen-Methode, die Du verwendne wirst, ist append(). Diese Methode fügt den ihr übergebenen Wert an das Ende der Liste hinzu. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> eier = []
>>> eier.append('Luftkissenboot')
>>> eier
['Luftkissenboot']
>>> eier.append('Aale')
>>> eier
['Luftkissenboot', 'Aale']
>>> eier.append(42)
>>> eier
['Luftkissenboot', 'Aale', 42]

Diese Methoden geben keine neue Liste zurück, sondern verändern die Liste, an der sie aufgerufen werden. Man sagt diese Methoden verändern die Liste “in-place” (zu Deutsch “an der Stelle”).

Die Listen-Methode split()

Zeile 59 ist eine lange Zeile Code, aber es handelt sich um eine einfache Zuweisung. Diese Zeile verwendet die split()-Methode von Zeichenketten.

59. worte = 'aal adler alligator ameise amsel bär biber bussard chamäleon dachs delfin eichhörnchen eidechse elch elefant faultier fledermaus fuchs gans gepard gorilla hai hamster hase hirsch huhn igel jaguar kamel känguru koala leopard libelle marienkäfer maulwurf meerschweinchen möwe nachtigal nilpferd panda pfau qualle ratte regenwurm schaf schimpanse schwan schwein strauß tausendfüßer tintenfisch wachtel wal wolf zebra ziege'.split()

Diese Zuweisung besteht aus einer einzigen, langen Zeichenkette, voll von Worten, die durch Leerzeichen getrennt sind. Am Ende der Zeichenkette steht ein Aufruf der split()-Methode. Diese gibt eine Liste zurück, in der jedes Wort aus der Zeichenkette einem Element entspricht. Der split (zu Deutsch “Spaltung”) tritt an Leerzeichen in der Zeichenkette auf.

split() erleichtert uns das Tippen. Hätten wir von Anfang an eine Liste erstellt, so müssten wir ['aal', 'adler', 'alligator', ... eingeben, mit Anführungszeichen und Kommata für jedes Wort.

Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> satz = input()
Meine sehr energische Mutter hat uns gerade Nachos serviert.
>>> satz.split()
['Meine', 'sehr', 'energische', 'Mutter', hat', uns', gerade', Nachos', serviert.']

Das Ergebnis ist eine Liste mit neun Zeichenketten, eine für jedes Wort im ursprünglichen Satz. Die Leerzeichen sind in keinen Elementen der Liste enthalten.

Du kannst gerne Deine eigenen Worte zur Zeichenkette in Zeile 59 hinzufügen, oder Worte entfernen, die Du nicht im Spiel haben möchtest. Stelle einfach sicher, dass die Worte von Leerzeichen getrennt sind.

Wie der Code funktioniert

Zeile 61 definiert die zufallsWort()-Funktion. Ein Listen-Argument wird an ihren wortListe-Parameter übergeben. Diese Funktion gibt ein einzelnes, geheimes Wort aus wortListe zurück.

 61. def zufallsWort(wortListe):
 62.     # Diese Funktion gibt eine zufällige Zeichenkette aus der übergebenen Zeichenketten-Liste zurück.
 63.     wortIndex = random.randint(0, len(wortListe) - 1)
 64.     return wortListe[wortIndex]

Zeile 63 speichert einen zufälligen Index für diese Liste in der Variable wortIndex ab. Dies geschieht, indem die randint()-Funktion mit zwei Argumenten aufgerufen wird. Das erste Argument ist 0 (der erste gültige Index) und das zweite Argument ist der Wert zu dem der Ausdrucks len(wortListe) - 1 evaluiert (der letzte gültige Index).

Listen-Indizes beginnen bei 0, nicht 1. In einer Liste mit drei Elementen, befindet sich das erste Element bei Index 0, das zweite Element bei Index 1 und das dritte Element bei Index 2. Die Länge dieser Liste ist 3, aber der Index 3 würde hinter das letzte Element verweisen. Deswegen subtrahiert Zeile 63 1 von der Länge. Der Code in Zeile 63 funktioniert unabhängig von der Länge von wortListe. Jetzt kannst Du beliebig Wörter hinzufügen oder entfernen.

Die wortIndex-Variable wird auf einen zufälligen Index in der per wortListe übergebenen Liste gesetzt. Zeile 64 gibt das Element an Index wortIndex aus wortListe zurück.

Nehmen wir an ['Apfel', 'Orange', 'Weintraube'] wurde als Argument an zufallsWort() übergeben und randint(0, 2) gab 2 zurück. Dies würde bedeuten, dass Zeile 64 zu wortListe[2] evaluiert, was zu 'Weintraube' evaluiert, was zurückgegeben wird. Auf diese Weise gibt zufallsWort() zufällige Zeichenketten aus Listen zurück.

zufallsWort() akzeptiert also eine Liste von Zeichenketten und gibt eine zufällig ausgewählte Zeichenkette aus dieser Liste zurück. Dies ist nützlich, um im Spiel Galgenmann ein geheimes, zu erratendes Wort für den Spieler auszuwählen.

Das Spielbrett anzeigen

Als Nächstes benötigen wir eine Funktion, um das Galgenmann-Spielbrett auf dem Bildschirm darzustellen. Es wird auch anzeigen, wieviele Buchstaben der Spieler richtig (bzw. falsch) geraten hat.

 66. def zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort):
 67.     print(GALGENMANNBILDER[len(falscheBuchstaben)])
 68.     print()

Dieser Code definiert eine neue Funktion namens zeigeSpielbrettAn(). Diese Funktion erwartet vier Parameter:

• GALGENMANNBILDER - Eine Liste von mehrzeiligen Zeichenketten, die das Spielbrett als ASCII-Kunst enthalten. (Die globale Variable GALGENMANNBILDER wird als Argument an diesen Parameter übergeben werden.) 
• falscheBuchstaben - Eine Zeichenkette bestehend aus vom Spieler geratenen Buchstaben, die nicht Teil des Geheimwortes sind.
• richtigeBuchstaben - Eine Zeichenkette bestehend aus vom Spieler geratenen Buchstaben, die Teil des Geheimwortes sind.
• geheimWort – Eine Zeichenkette, die das geheime Wort representiert, das der Spieler zu erraten versucht.

Der erste print()-Aufruf zeigt das Spielbrett an. GALGENMANNBILDER ist eine Liste mit Zeichenketten für jedes mögliche Spielbrett. GALGENMANNBILDER[0] zeigt einen leeren Galgen, GALGENMANNBILDER[1] zeigt den Kopf (wenn der Spieler einen Buchstaben falsch rät), GALGENMANNBILDER[2] zeigt den Kopf und Körper (wenn der Spieler zwei Buchstaben falsch rät), und so weiter bis GALGENMANNBILDER[6] schließlich den kompletten Henker zeigt.

Die Anzahl der Buchstaben in falscheBuchstaben ist gleich der Anzahl der falschen Rateversuche des Spielers. Ein Aufruf von len(falscheBuchstaben) verrät uns diese Zahl. D.h., falls falscheBuchstaben den Wert 'aetr' enthält, gibt len('aetr') 4 zurück. GALGENMANNBILDER[4] auf dem Bildschirm auszugeben, zeigt das Spielbrett für vier falsche Rateversuche an. Dies ist genau das, was GALGENMANNBILDER[len(falscheBuchstaben)] in Zeile 67 tut.

 70.     print('Falsche Buchstaben:', end=' ')
 71.     for buchstabe in falscheBuchstaben:
 72.         print(buchstabe, end=' ')
 73.     print()

Zeile 70 gibt die Zeichenkette 'Falsche Buchhstaben:' auf dem Bildschirm aus, mit einem Leerzeichen am Ende, anstatt einer neuen Zeile. Wir erinnern uns, dass das Schlüsselwort-Argument end=' ' nur ein Gleichheitszeichen (=) verwendet, nicht zwei (==).

Zeile 71 führt eine neue Art von Schleife ein, genannt for-Schleife. Eine for-Schleife benutzt die range()-Funktion. Beide Konstrukte werden in den nächsten zwei Abschnitten erklärt.

Die Funktionen range() und list()

Wird range() mit einem Argument aufgerufen, so gibt die Funktion ein Wertebereich-Objekt bestehend aus Ganzzahlen von 0 bis (ausschließlich) zum Argument. Dieses Wertebereich-Objekt kann mit Hilfe der list()-Funktion in den uns vertrauten Listen-Typen konvertiert werden. Probiere list(range(10)) in den interaktiven Kommandozeileninterpreter einzugeben:

>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list('Hallo')
['H', 'a', 'l', 'l', 'o']
Die list()-Funktion ähnelt den Funktionen str() und int(), insofern als sie das ihr übergebene Objekt in eine Liste konvertiert. Es ist einfach riesige Listen mit der range()-Funktion zu generieren. Probiere list(range(10000)) in den interaktiven Kommandozeileninterpreter einzugeben:
>>> list(range(10000))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,...
      ...der Kürze halber ausgelassen...
...9989, 9990, 9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999]

Diese Liste ist so groß, dass sie nicht einmal auf den Bildschirm passt. Aber man kann sie in einer Variablen speichern:

>>> spam = list(range(10000))

Übergibt man zwei Ganzzahlen an range(), gibt die Funktion ein Wertebereich-Objekt zurück, das von der ersten Ganzzahl (einschließlich) bis zu der zweiten Ganzzahl (ausschließlich) reicht. Probiere list(range(10, 20)) in den interaktiven Kommandozeileninterpreter einzugeben:

>>> list(range(10, 20))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

range() wird häufig in for-Schleifen benutzt, die den uns bereits bekannten while-Schleifen sehr ähneln.

for-Schleifen

Die for-Schleife ist nützlich, um über eine Liste von Werten zu iterieren. Dies unterscheidet sich von while-Schleifen, die iterieren solange eine Bedingung erfüllt ist. Ein for-Ausdruck beginnt mit dem Schlüsselwort for, gefolgt von einem neuen Variablen-Namen, gefolgt vom Schlüsselwort in, gefolgt von einem iterierbaren Wert, und endet schließlich mit einem Doppelpunkt.

Ein iterierbarer Wert ist ein Wert des Typs Liste (list), Wertebereich (range) oder Zeichenkette (string). Es gibt einige weitere iterierbare Datentypen, auf die wir später eingehen.

Bei jeder Schleifen-Iteration wird der neuen Variable im for-Ausdruck ein weiteres Element aus der Liste zugewiesen.

>>> for i in range(5):
...     print('i ist gleich ' + str(i))
...
i ist gleich 0
i ist gleich 1
i ist gleich 2
i ist gleich 3
i ist gleich 4

Das von range(5) zurückgegebene Wertebereich-Objekt ist equivalent zu der Liste [0, 1, 2, 3, 4] in einem for-Ausdruck. Wenn sich die Programmausführung das erste Mal im for-Block befindet, hat i den Wert 0. Bei der nächsten Iteration, hat i den Wert 1, und so weiter.

Der for-Ausdruck konvertiert das von range() zurückgegebene Wertebereich-Objekt automatisch in eine Liste, so dass man nicht extra list(range(5)) aufrufen braucht. range(5) genügt.

Listen und Zeichenketten können ebenfalls iteriert werden. Man kann sie in for-Ausdrücken verwenden. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> for ding in ['Katzen', 'Pasta', 'Programmierung', 'spam']:
...     print('Ich mag ' + ding + ' sehr')
...
Ich mag Katzen sehr
Ich mag Pasta sehr
Ich mag Programmierung sehr
Ich mag spam sehr

>>> for i in 'Hallo':
...     print(i)
...
H
a
l
l
o

Eine zur for-Schleife equivalente while-Schleife

Die for-Schleife ähnelt der while-Schleife sehr, aber wenn man nur über Element einer Liste iterieren braucht, bedeutet die for-Schleife viel weniger Tipparbeit. So würde das vorherige Codebeispiel realisiert mit einer while-Schleife aussehen:

>>> iterierbarerWert = ['Katzen', 'Pasta', 'Programmierung', 'spam']
>>> index = 0
>>> while (index < len(iterierbarerWert)):
...     ding = iterierbarerWert[index]
...     print('Ich mag ' + ding ' sehr')
...     index = index + 1
...
Ich mag Katzen sehr
Ich mag Pasta sehr
Ich mag Programmierung sehr
Ich mag spam sehr

Die Verwendung des for-Ausdrucks erübrigt die Einführung des Extra-Codes und erspaart uns Tipparbeit.

Der Rest der zeigeSpielbrettAn()-Funktion zeigt die falschen Buchhstaben an und erstellt eine Zeichenkette, in der die noch nicht erratenen Buchstaben im Geheimwort durch Unterstriche ersetzt sind.

 70.     print('Falsche Buchstaben:', end=' ')
 71.     for buchstabe in falscheBuchstaben:
 72.         print(buchstabe, end=' ')
 73.     print()

Die for-Schleife in Zeile 71 iteriert über jedes Zeichen in falscheBuchstaben und gibt es auf dem Bildschirm aus. Vergiss nicht, dass end=' ' die neue Zeile, die normalerweise nach einer Zeichenkette ausgegeben wird, durch ein Leerzeichen ersetzt.

Falls zum Beispiel falscheBuchstaben den Wert 'ajtw' hätte, würde die for-Schleife a j t w ausgeben.

Slicing

Das englische Verb “to slice” bedeutet in Deutsch “schneiden” oder auch “in Scheiben schneiden”. Letztere Bedeutung entspricht dem Slicing in Python. Dieses erlaubt es, neue Listen aus Teilmengen anderer Listen zu erstellen. Im Code spezifiziert man zwei durch einen Doppelpunkt getrennte Indizes (Anfang und Ende) in den eckigen Klammern hinter einer Liste. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> spam = ['Äpfel', 'Bananen', 'Karotten', 'Daten']
>>> spam[1:3]
['Bananen', 'Karotten']

Der Ausdruck spam[1:3] evaluiert zu einer Liste mit den Elmenten von Index 1 (einschließlich) bis 3 (ausschließlich) aus spam.

Lässt man den ersten Index aus, nimmt Python automatisch 0 an:

>>> spam = ['Äpfel', 'Bananen', 'Karotten', 'Daten']
>>> spam[:2]
['Äpfel', 'Banenen']

Lässt man den zweiten Index aus, nimmt Python automatisch die Länge der Liste an:

>>> spam = ['Äpfel', 'Bananen', 'Karotten', 'Daten']
>>> spam[2:]
['Karotten', 'Daten']

Schneiden erlaubt es uns auf einfache Weise, Teilmengen aus Listen zu extrahieren. Schnitte funktionieren mit Zeichenketten genauso wie mit Listen. Jedes Zeichen in der Zeichenkette wird wie ein Element einer Liste behandelt. Probiere Folgendes in den interaktiven Kommandozeileninterpreter einzugeben:

>>> meinName = 'Sofie die dicke Katze'
>>> meinName[4:12]
'e die di'
>>> meinName[:10]
'Sofie die '
>>> meinName[7:]
'ie dicke Katze'

Der nächste Teil des Codes in Galgenmann verwendet slicing.

Das Geheimwort mit Unterstrichen darstellen

Als Nächstes wollen wir das Geheimwort ausgeben, jedoch mit Unterstrichen (_) an Stelle der nicht erratenen Buchstaben. Zuerst erstellen wir eine Zeichenkette, die genauso lang ist wie das Geheimwort und nur aus Unterstrichen besteht. Danach ersetzen wir Unterstriche mit Buchstaben aus richtigeBuchstaben.

Wäre das Geheimwort 'bieber', dann bestünde die redigierte Zeichenkette aus sechs Unterstrichen '______'. Beinhaltete richtigeBuchstaben nun die Zeichenkette 'be', so würde die redigierte Zeichenkette zu 'b_ebe_' geändert. Die Zeilen 75 bis 79 sind dafür verantwortlich.

 75.     luecken = '_' * len(geheimWort)

Zeile 75 erstellt die redigierte Variable mittels Zeichenketten-Replikation. Der Operator * kann auf eine Zeichenkette und eine Ganzzahl angewandt werden; der Ausdruck '_' * 6 evaluiert zu '______'. Dies stellt sicher, dass luecken genauso viele Unterstriche enthält, wie geheimWort Buchstaben.

 77.  for i in range(len(geheimWort)): # Ersetze Lücken mit korrekt geratenen Buchstaben
 78.         if geheimWort[i] in richtigeBuchstaben:
 79.             luecken = luecken[:i] + geheimWort[i] + luecken[i+1:]

Zeile 77 definiert eine for-Schleife, die durch alle Buchstaben in geheimWort iteriert und Unterstriche durch die tatsächlichen Buchstaben ersetzt, falls sie in richtigeBuchstaben enthalten sind.

Nehmen wir an, geheimWort habe den Wert 'bieber' und richtigeBuchstaben habe den Wert 'be'. Dann sollte dem Spieler der Text 'b_ebe_' angezeigt werden. Finden wir heraus, wie man diese Zeichenkette erstellt.

Der Aufruf len(geheimWort) in Zeile 77 würde 6 zurückgeben. range(len(geheimWort)) wird zu range(6), sodass die for-Schleife über die Werte 0, 1, 2, 3, 4 und 5 iteriert.

Da der i jeden der Werte in [0, 1, 2, 3, 4, 5] annehmen wird, ist die for-Schleife equivalent zu folgendem Code:

if geheimWort[0] in richtigeBuchstaben:
    luecken = luecken[:0] + geheimWort[0] + luecken[1:]

if geheimWort[1] in richtigeBuchstaben:
    luecken = luecken[:1] + geheimWort[1] + luecken[2:]
    
if geheimWort[2] in richtigeBuchstaben:
    luecken = luecken[:2] + geheimWort[2] + luecken[3:]
    
if geheimWort[3] in richtigeBuchstaben:
    luecken = luecken[:3] + geheimWort[3] + luecken[4:]
    
if geheimWort[4] in richtigeBuchstaben:
    luecken = luecken[:4] + geheimWort[4] + luecken[5:]
    
if geheimWort[5] in richtigeBuchstaben:
    luecken = luecken[:5] + geheimWort[5] + luecken[6:]

Falls Du nicht sicher bist, was Ausdrücke wie geheimWort[0] oder luecken[3:] representieren, dann schaue Dir Abbildung 9-2 an. Sie zeigt die Werte der Variablen geheimWort und luecken mit den dazugehörigen Indizes.

Abbildung 9-2: Die Indizes der Zeichenketten luecken und geheimWort.

Ersetzten wir die Listen-Schnitte- und Indizes mit den Werten, die sie representieren, dann würde die Schleife wie folgt aussehen:

if 'b' in 'be': # True
    luecken = '' + 'b' + '_____' # Diese Zeile wird ausgeführt.

if 'i' in 'be': # False
    luecken = 'b' + 'i' + '____' # Diese Zeile wird übersprungen.

if 'e' in 'be': # True
    luecken = 'b_' + 'e' + '___' # Diese Zeile wird ausgeführt.

if 'b' in 'be': # True
    luecken = 'b_e' + 'b' + '__' # Diese Zeile wird ausgeführt.

if 'e' in 'be': # True
    luecken = 'b_eb' + 'e' + '_' # Diese Zeile wird ausgeführt.
    
if 'r' in 'be': # False
    luecken = 'b_ebe' + 'r' + '' # Diese Zeile wird übersprungen.

# luecken hat jetzt den Wert 'b_ebe_'

Die obigen Code-Beispiele verhalten sich alle gleich, wenn geheimWort den Wert 'bieber' und richtigeBuchstaben den Wert 'be' haben. Die folgenden Zeilen geben den neuen Wert von luecken mit Leerzeichen zwischen jedem Buchstaben auf dem Bildschirm aus.

 81.     for buchstabe in luecken: # Zeige das Geheimwort mit Leerzeichen zwischen den Buchstaben
 82.         print(buchstabe, end=' ')
 83.     print()

Spielereingaben lesen

Die rateBuchstabe()-Funktion wird aufgerufen, damit der Spieler einen Buchstaben eingeben kann. Die Funktion gibt die Eingabe des Spielers als Zeichenkette zurück. Darüber hinaus stellt sie sicher, dass der Spieler einen gültigen Buchstaben eingegeben hat, bevor sie zurückkehrt.

 85. def rateBuchstabe(bereitsGeraten):
 86.     # Stellt sicher, dass der Spieler nur einen einzelnen Buchstaben eintippt und gibt ihn zurück.

Eine Zeichenkette mit den vom Spieler bereits geratenen Buchstaben wird als Argument an den Parameter bereitsGeraten übergeben. Danach bittet die rateBuchstabe()-Funktion den Spieler, einen einzelnen Buchstaben zu erraten. Dieser wird zum Rückgabewert von rateBuchstabe().

 87.     while True:
 88.         print('Rate einen Buchstaben.')
 89.         eingabe = input()
 90.         eingabe = eingabe.lower()

Die while-Schleife in Zeile 87 fragt den Spieler solange nach seiner Eingabe, bis dieser einen Text eingibt, der folgenden Kriterien entspricht:

1.  Es handelt sich um einen einzelnen Buchstaben.
2.  Der Spieler hat den Buchstaben noch nicht getippt.

Als Abbruch-Bedingung an die while-Schleife wird der Wert True übergeben. Das bedeutet, dass die Programmausführung die Schleife nur dann verlassen wird, wenn sie auf eine break-Anweisung (, die die Schleife verlässt,) oder auf eine return-Anweisung (, die nicht nur die Schleife, sondern die gesamte Funktion verlässt,) trifft.

Der obige Code bittet den Spieler einen Buchstaben einzugeben, der in der Variablen eingabe gespeichert wird. Falls der Spieler einen Großbuchstaben eingibt, wird dieser vor dem Speichern in eingabe in einen Kleinbuchstaben umgewandelt.

elif (“Else If”)-Ausdrücke

Der nächste Abschnitt des Galgenmann-Programms benutzt elif-Ausdrücke. elif-Ausdrücke (kurz für “else if”, zu Deutsch “sonst, falls”) kann man sich wie die Formulierung “Falls dies wahr ist, tue dies. Sonst, falls die nächste Bedingung wahr ist, tue das” vorstellen.

Schauen wir uns folgenden Code an:

if katzenName == 'Struppi':
    print('Deine Katze ist struppig.')
elif katzenName == 'Flecki':
        print('Deine Katze ist gefleckt.')
else:
    print('Deine Katze ist weder struppig noch gefleckt.')

Falls die katzenName-Variable gleich der Zeichenkette 'Struppi' ist, dann ist die Bedingung der ersten if-Anweisung wahr und der if-Block sagt dem Benutzer, er habe eine struppige Katze. Falls (und nur falls(!)) jedoch die Bedingung falsch ist, testet Python die Bedingung der elif-Anweisung als Nächstes. Ist katzenName gleich 'Flecki', so wird 'Deine Katze ist gefleckt.' ausgegeben. Falls (und nur falls(!)) jedoch beide Bedingungen falsch sind, sagt der Code dem Benutzer, seine Katze sei weder struppig, noch gefleckt.

Es können beliebig viele elif-Anweisungen hintereinander stehen:

if katzenName == 'Struppi':
    print('Deine Katze ist struppig.')
elif katzenName == 'Flecki':
    print('Deine Katze ist gefleckt.')
elif katzenName == 'Smoky':
    print('Deine Katze hat schwarze Augen.')
else:
    print('Deine Katze ist weder struppig, noch gefleckt, noch hat sie schwarze Augen.')

Ist eine der elif-Bedingungen wahr, so wird ihr Code ausgeführt und die Programmausführung springt zur ersten Zeile nach dem else-Block. D.h. in einem if-elif-else-Ausdruck wird nur ein einziger Block ausgeführt. Der else-Block am Ende ist optional.

Die Gültigkeit von Rateversuchen garantieren

 91.         if len(eingabe) != 1:
 92.             print('Bitte gib einen einzelnen Buchstaben ein.')
 93.         elif eingabe in bereitsGeraten:
 94.             print('Du hast diesen Buchstaben bereits probiert. Rate noch einmal.')
 95.         elif eingabe not in 'abcdefghijklmnopqrstuvwxyz':
 96.             print('Bitte gib einen BUCHSTABEN ein.')
 97.         else:
 98.             return eingabe

Die Variable eingabe beinhaltet den vom Spieler eingegebenen Text. Das Programm muss sicherstellen, dass dieser gültig ist: Er darf nur aus einem einzelnen Kleinbuchstaben bestehen. Hat der Spieler etwas anderes eingegeben, so sollte das Programm ihn erneut auffordern.

Die Bedingung in Zeile 91 prüft, ob die Eingabe eine andere Länbge als eins hat. Zeile 93 überprüft, ob der Spieler den Buchstaben bereits probiert hat (ob dieser in der bereitsGeraten-Variablen enthalten ist). Zeile 95 prüft, ob es sich um ein ungültiges Zeichen (ein Zeichen, dass kein Kleinbuchstabe ist (z.B. Großbuchstaben oder andere Zeichen)) handelt.

Sind alle Bedingungen falsch, wird der else-Block ausgeführt und rateBuchstabe() gibt den Wert von eingabe in Zeile 98 zurück.

Wir erinnern uns daran, dass nur einer der Blöcke in einem if-elif-else-Ausdruck ausgeführt wird.

Den Spieler um eine weitere Partie fragen

100. def spieleNochEinmal():
101.     # Diese Funktion True zurück, falls der Spieler noch einmal spielen möchte, False sonst.
102.     print('Möchtest Du noch einmal spielen? (ja oder nein)')
103.     return input().lower().startswith('j')

Die Funktion spieleNochEinmal() besteht nur aus einem print()-Aufruf und einer return-Anweisung. Der Ausdruck in der return-Anweisung mag zunächst kompliziert erscheinen, aber man kann ihn leicht in seine Einzelteile zerlegen. Hier ist eine Schritt-für-Schritt-Veranschaulichung, wie Python den Ausdruck interpretiert (unter der Annahme, der Spieler hätte JA eingegeben):

input().lower().startswith('j')
            ▼
   'JA'.lower().startswith('j')
            ▼
           'ja'.startswith('j')
            ▼
           True

Die spieleNochEinmal()-Funktion erlaubt dem Spieler ja oder nein einzugeben, je nachdem ob dieser weiterspielen möchte oder nicht. Dabei sollte es dem Spieler möglich sein, JA, ja, j oder irgendetwas anderes, das mit 'j' beginnt, einzugeben. Gibt der Spieler JA ein, so ist der Rückgabewert von input() 'JA'. 'JA'.lower() gibt 'ja' zurück.

Schließlich folgt der Methoden-Aufruf startswith('j'). Diese Funktion gibt True zurück, falls die Zeichenkette, an der sie aufgerufen wird, mit dem als Argument übergebenen Präfix beginnt, False sonst. Der Rückgabewert von 'ja'.startswith('j') ist True.

Damit ist die Analyse dieses Ausdrucks abgeschlossen. Er lässt den Spieler etwas eingeben, wandelt die Eingabe in Kleinbuchstaben um und testet, ob sie mit 'j' beginnt. Ist dies der Fall, so wird True zurückgegeben, False sonst.

Der Vollständigkeit halber sei hier erwähnt, dass es auch eine endswith()-Methode gibt, die True zurückgibt, falls die Zeichenkette, an der sie aufgerufen wird, mit dem als Argument übergebenen Suffix endet.

Zusammenfassung der Funktionen in Galgenmann

Dies waren alle Funktionen, die wir für dieses Spiel geschrieben haben. Hier die Zusammenfassung:

• geheimWort(wortListe) akzeptiert eine Liste von Zeichenketten und gibt eine (zufällig ausgewählte) davon zurück. Auf diese Weise wird das zu erratende Wort für den Spieler ausgesucht.
• zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort) malt das Spielbrett inklusive des (teilweise erratenen) Geheim-Wortes und den falschen Rateversuchen auf den Bildschirm. Diese Funktion akzeptiert vier Parameter. GALGENMANNBILDER ist eine Liste von Zeichenketten, die das Spielbrett in verschiedenen Etappen als ASCII-Kunst representieren. richtigeBuchstaben und falscheBuchstaben sind Zeichenketten, die aus den richtigen und falschen Rateversuchen des Spielers bestehen. geheimWort ist das geheime Wort, das der Spieler erraten muss. Diese Funktion hat keinen Rückgabewert.
• rateBuchstabe(bereitsGeraten) akzeptiert eine Zeichenkette aus Buchstaben, die der Spieler bereits getippt hat. Die Funktion fragt den Spieler solange nach einer Eingabe, bis dieser einen einzelnen Kleinbuchstaben eingibt, der nicht bereits in bereitsGeraten enthalten ist. Die Eingabe des Spielers wird zurückgegeben.
• spieleNochEinmal() fragt den Spieler, ob er eine weitere Partie Galgenmann spielen möchte. Ist dies der Fall, so gibt die Funktion True zurück, False sonst.

Nach den Funktionen folgt in Zeile 106 der Code für das Haupt-Programm. Alles zuvor waren nur Funktions-Definitionen und eine große Zuweisung an die Variable GALGENMANNBILDER.

Die Variablen initialisieren

106. print('G A L G E N M A N N')
107. falscheBuchstaben = ''
108. richtigeBuchstaben = ''
109. geheimWort = zufallsWort(worte)
111. spielIstBeendet = False

Zeile 106 beinhaltet den ersten print()-Aufruf des gesamten Spiels. Dieser zeigt den Spieletitel an. Als Nächstes werden falscheBuchstaben und richtigeBuchstaben leere Zeichenketten zugewiesen (da der Spieler noch keine Rateversuche unternommen hat).

Der zufallsWort(worte)-Aufruf evaluiert zu einem zufällig ausgewählten wort aus der Liste worte.

Zeile 110 setzt spielIstBeendet auf False. Der Code wird diese Variable dann auf True setzen, wenn eine Runde von Galgenmann vorbei ist und der Spieler gefragt werden sollte, ob er noch eine spielen möchte.

Das Spielbrett anzeigen

112. while True:
113.     zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)

Die Bedingung der while-Schleife ist immer True. D.h. sie wird solange iterieren, bis eine break-Anweisung ausgeführt wird. (Dies passiert später in Zeile 147.)

Zeile 113 ruft die zeigeSpielbrettAn()-Funktion auf und übergibt ihr eine Liste mit ASCII-Kunst-Galgenmann-Bildern, sowie den drei in den Zeilen 107, 108 und 109 initialisierten Variablen. Abhängig von den korrekten und falschen Rateversuchen des Spielers, zeigt diese Funktion das entsprechende Spielbrett an.

Benutzereingabe abfragen

115.     # Lass den Spieler einen Buchhstaben eingeben.
116.     buchstabe = rateBuchstabe(falscheBuchstaben + richtigeBuchstaben)

Die rateBuchstabe()-Funktion benötigt die Buchstaben in falscheBuchstaben und richtigeBuchstaben, weshalb Zeile 116 beide Variablen konkateniert und das Ergebnis als Argument übergibt. Das Argument wird benötigt, weil rateBuchstabe() überprüfen muss, ob der Spieler einen Buchstaben bereits entweder erraten oder getippt hat.

Überprüfen, ob der geratene Buchstabe im geheimen Wort enthalten ist

118.     if buchstabe in geheimWort:
119.         richtigeBuchstaben = richtigeBuchstaben + buchstabe

Falls das geheime Wort den geratenen Buchstaben enthält, so wird dieser an das Ende von richtigeBuchstaben angehängt.

Überprüfen, ob der Spieler gewonnen hat

121.         # Überprüfe, ob der Spieler gewonnen hat
122.         alleBuchstabenGeraten = True
123.         for i in range(len(geheimWort)):
124.             if geheimWort[i] not in richtigeBuchstaben:
125.                 alleBuchstabenGeraten = False
126.                 break

Wie kann das Programm wissen, dass der Spieler jeden Buchstaben des Geheimwortes richtig geraten hat? Da richtigeBuchstaben alle korrekten Rateversuche des Spielers enthält und geheimWort das geheime Wort selbst ist, liegt der Gedanke nahe, beide Variablen zu vergleichen: richtigeBuchstaben == geheimWort. Dies wäre jedoch falsch. Nehmen wir an, das geheime Wort sei 'bieber' und richtigeBuchstaben habe den Wert 'eibr'. In dem Fall würde geheimWort == richtigeBuchstaben zu False evaluieren, obwohl der Spieler jeden Buchstaben des Geheimwortes erraten hat.

Die korrekte Lösung lautet, über jeden Buchstaben in geheimWort zu iterieren und zu testen, ob er in richtigeBuchstaben enthalten ist. Dann, und nur dann, hat der Spieler gewonnen.

Stoßen wir auf einen Buchstaben in geheimWort, der nicht in richtigeBuchstaben enthalten ist, so wissen wir, dass der Spieler noch nicht alle Buchhstaben erraten hat. Die neue Variable alleBuchstabenGeraten wird in Zeile 122 auf True gesetzt. Die Schleife beginnt also mit der Annahme, dass der Spieler gewonnen habe. Stößt die Schleife jedoch auf einen  noch nicht erratenen Buchstaben, so setzt sie alleBuchstabenGeraten auf False.

127.         if alleBuchstabenGeraten:
128.             print('Ja! Das geheime Wort ist "' + geheimWort + '"! Du hast gewonnen!')
129.             spielIstBeendet = True

Sind alle Buchstaben des Geheimwortes erraten, wird der Spieler über seinen Sieg benachrichtigt.

Wenn der Spieler falsch tippt

130.     else:
131.         falscheBuchstaben = falscheBuchstaben + buchstabe

Hier beginnt der else-Block. Der Code in diesem Block wird dann ausgeführt, wenn die Bedingung in Zeile 118 falsch war.

Abbildung 9-3: Der else-Ausdruck gehört zum if-Ausdruck mit derselben Einrückung.

So if the condition on line 118 (guess in secretWord) was False, then the execution moves into this else-block.

Falsch geratene Buchstaben werden in Zeile 131 an falscheBuchstaben angehängt, genauso wie dies in Zeile 119 für die richtig geratenen Buchstaben passiert.

133.         # Überprüfe, ob der Spieler zu viele Rateversuche verbraucht und damit verloren hat
134.         if len(falscheBuchstaben) == len(GALGENMANNBILDER) - 1:
135.             zeigeSpielbrettAn(GALGENMANNBILDER, falscheBuchstaben, richtigeBuchstaben, geheimWort)
136.             print('Du hast zu viele Versuche gebraucht!\nNach ' + str(len(falscheBuchstaben)) + ' falsch und ' + str(len(richtigeBuchstaben)) + ' richtig geratenen Buchstaben lautet das Wort "' + geheimWort + '"')
137.             spielIstBeendet = True

Jedes Mal, wenn der Spieler einen Buchstaben falsch rät, wird dieser an die Zeichenkette falscheBuchstaben angehängt. D.h. die Länge von falscheBuchstaben (in Python len(falscheBuchstaben)) ist gleich der Anzahl der falschen Rateversuche.

Die GALGENMANNBILDER-Liste beinhaltet 7 ASCII-Kunst-Zeichenketten. Ist also len(falscheBuchstaben) gleich 6, dann hat der Spieler verloren, denn das Galgenmann-Bild ist fertig. GALGENMANNBILDER[0] bezieht sich auf das erste Element, GALGENMANNBILDER[6] auf das Letzte.

Ist also len(falscheBuchstaben) gleich len(GALGENMANNBILDER) - 1 (was 6 entspricht), sind dem Spieler die Rateversuche ausgegangen. Zeile 136 gibt das Geheimwort aus und Zeile 137 setzt die spielIstBeendet-Variable auf True.

139.     # Frage den Spieler, ob er noch einmal spielen möchte (aber nur, wenn das Spiel zu Ende ist).
140.     if spielIstBeendet:
141.         if spieleNochEinmal():
142.             falscheBuchstaben = ''
143.             richtigeBuchstaben = ''
144.             spielIstBeendet = False
145.             geheimWort = zufallsWort(worte)

Hat der Spieler entweder gewonnen oder verloren, so sollte das Spiel ihn fragen, ob dieser noch einmal spielen möchte. Danach erkundigt sich die spieleNochEinmal()-Funktion, weshalb sie in Zeile 141 aufgerufen wird.

Möchte der Spieler noch einmal spielen, müssen die Variablen falscheBuchstaben, richtigeBuchstaben und spielIstBeendet auf ihre Ausgangswerte zurückgesetzt und ein neues Geheimwort ausgewählt werden. Anschließend springt die Programmausführung zurück zum Anfang der while-Schleife in Zeile 112.

146.         else:
147.             break

Entscheided sich der Spieler gegen eine neue Partie, so ist die Bedingung in Zeile 141 falsch und der else-Block wird ausgeführt. Die break-Anweisung führt zum Sprung in die erste Zeile außerhalb der Schleife. Da jedoch nach der Schleife keine Anweisungen folgen, terminiert das Programm.

Zusammenfassung

In diesem langen Kapitel wurden zahlreiche neue Konzepte eingeführt. Galgenmann ist unser bisher ambitioniertestes Spiel. Mit der Zeit werden Deine Programme immer komplexer. Da macht es Sinn, die Programmabläufe mit Hilfe eines Flussdiagramms zu skizieren, bevor Du Dich an die eigentliche Programmierung machst.

Listen sind Werte, die andere Werte enthalten können. Methoden sind an Typen gebundene Funktionen. Listen verfügen über die Methoden append() und reverse(). Zeichenketten über lower(), upper(), split(), startswith() und endswith(). Du wirst viele weitere Methoden im Rest dieses Buches kennenlernen.

Die for-Schleife wird dazu verwendet, über die Werte in einer Liste zu iterieren, wohingegen die while-Schleife iteriert solange eine Bedingung erfüllt ist. Die del-Anweisung kann Elemente aus Listen löschen.
