	Kapitel 7
	DEN DEBUGGER BENUTZEN

In diesem Kapitel behandelte Themen:

•   3 unterschiedliche Fehlertypen
•   Der IDLE-Debugger
•   Stepping: Into, Over und Out
•   Go und Quit
•   Breakpoints

Bugs!

"Zu zwei Gelegenheiten wurde ich gefragt: 'Sagen Sie, Mr. Babbage, wenn Sie der Maschine die falschen Zahlen füttern, spuckt sie dann die richtige Antwort aus?' Ich bin nicht in der Lage, die Verwirrung zu begreifen, die so eine Frage verursacht."
-Charles Babbage, Begründer des Konzepts des programmierbaren Computers im 19. Jahrhundert

Wenn du einen falschen Befehl eingibst, gibt dir der Computer nicht das richtige Programm aus. Ein Computerprogramm tut immer was du ihm befiehlst, aber was das Programm tut ist nicht unbedingt was du wolltest. Computerprogramme können Fehler haben. Bugs treten dann auf, wenn der Programmierer nicht vorsichtig darüber nachgedacht hat, was das Programm genau macht. Es gibt drei Fehlertypen, die in deinem Programm auftreten können:

•   Syntaxfehler sind ein Fehlertyp, der durch Rechtschreibfehler entsteht. Wenn der [Python-Interpreter] einen Syntaxfehler sieht, liegt es daran, dass dein Code nicht in der korrekten Python-Sprache geschrieben ist. Ein einziger Syntaxfehler genügt, um zu verhindern, dass ein Python-Programm ausgeführt wird.
•   [Laufzeitfehler] sind Bugs die auftreten, während das Programm läuft. Das Programm läuft bis zu der Zeile im Code, die den Fehler enthält, und beendet sich dann mit einer Fehlermeldung (das nennt man einen Absturz). Der Python-Interpreter zeigt eine Ablaufmeldung mit der Zeile an, in der das Problem auftritt.
•   Semantische Fehler sind am schwierigsten zu beheben. Diese Bugs lassen ein Programm nicht abstürzen, aber es tut trotzdem nicht, was der Programmierer will. Wenn ein Programmierer zum Beispiel will, dass die Variable total die Summe der Werte der Variablen a, b und c enthält, aber in den code total = a * b * c schreibt, ist der Wert in total falsch. Das könnte später das Programm zum Absturz bringen, aber es ist nicht sofort offensichtlich, wo der semantische But auftritt.

Bugs in einem Programm zu finden kann schwierig sein, wenn man sie überhaupt bemerkt! Wenn du dein Programm laufen lässt, fällt dir vielleicht auf, dass Funktionen nicht aufgerufen werden, wenn sie sollten, oder vielleicht werden sie zu oft aufgerufen. Du könntest die Bedingung eines while-Loops falsch schreiben, so dass der Loop die falsche Anzahl von Durchläufen macht. (Ein Loop in einem Programm, der nie zu Ende geht, wird auch "infinite loop" oder unendlicher Loop genannt. Um so ein Programm zu beenden, kannst du in der interaktiven Shell Strg+C drücken.) Das sind alles Fehler, die in deinem Code auftreten können, wenn du nicht aufpasst.

Geh einfach mal in die interaktive Shell und programmiere einen undendlichen Loop, indem du diesen Code eingibst (du musst zweimal EINGABE drücken, damit die Shell weiß, dass du mit der Eingabe im while-Block fertig bist):

>>> while True:
...		print('Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!')
...

Halte jetzt die Strg-Taste gedrückt und drücke C, um das Programm anzuhalten. Die interaktive Shell wird jetzt so aussehen:

Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!
Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!
Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!
Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!
Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!
Traceback (most recent call last):
	File "<pyshell#1>", line 1, in <module>
		while True: print('Drücke Strg-C, um diesen unendlichen Loop abzubrechen!!!')
KeyboardInterrupt

Der Debugger

Es kann schwierig sein, herauszufinden, wie dein Code einen Bug verursachen könnte. Die Programmzeilen werden sehr schnell abgearbeitet und die Werte in den Variablen verändern sich oft. Ein Debugger ist ein Programm, der dir hilft, deinen Code Zeile für Zeile in der gleichen Reihenfolge durchzugehen (auch Stepping genannt), in der Python sie ausführt. Der Debugger zeigt dir auch, welche Werte bei welchem Schritt in welchen Variablen gespeichert sind.

Den Debugger starten

Öffne das [Dragon Realm]-Spiel, das du im letzten Kapitel geschrieben hast, in IDLE. Nachdem du die [dragon.py]-Datei geöffnet hast, klicke im Debug-Menü auf Debugger, um das Debug-Kontrollfenster aufzurufen (Abbildung 7-1).

Abbildung 7-1: Das Debug-Kontrollfenster.

Abbildung 7-2: Das [Dragon Realm]-Spiel im Debugger laufen lassen.

Wenn du das [Dragon Realm]-Spiel jetzt mit F5 startest, aktiviert sich der IDLE-Debugger. Das nennt man ein Programm "im Debugger" laufen lassen. Klicke die [Source-] und [Globals-]-Kontrollkästchen im Debug-Kontrollfenster an.

Wenn du Python-Programme im Debugger laufen lässt, stoppt das Programm, bevor es die erste Anweisung ausführt. Wenn du auf die Fensterleiste des [Dateieditors]klickst (und im Debug-Kontrollfenster die [Source-] und [Globals-]-Kontrollkästchen aktiviert hast), ist die erste Anweisung grau hinterlegt. Das Debug-Kontrollfenster zeigt, dass die Ausführung auf Zeile 1 steht, die in diesem Fall random importiert.

Stepping

Der Debugger erlaubt es dir, eine Anweisung nach der anderen auszuführen. Das wird Stepping genannt. Klicke auf den [Step]-Button, um eine einzelne Anweisung auszuführen. Python führt jetzt die Anweisung aus, random zu importieren, und hält dann wieder an, bevor die nächste Anweisung ausgeführt wird. Das Debug-Kontrollfenster zeigt jetzt, dass die Ausführung auf Zeile 2 steht, in der time importiert wird. Klicke auf den [Quit]-Button, um das Programm für den Augenblick zu beenden.

Hier ist eine Zusammenfassung dessen, was passiert, wenn du auf den [Step]-Button klickst, während das [Dragon Realm]-Spiel im Debugger läuft. Drücke F5, um [Dragon Realm] neu zu starten und befolge diese Anweisungen:

1.	Klicke den [Step]-Button zweimal, um die beiden import-Zeilen auszuführen.
2.	Klicke den [Step]-Button dreimal, um die drei def-Statements auszuführen.
3. 	Klicke den [Step]-Button nochmal, um die playAgain-Variable zu definieren.
4.	Klicke [Go], um den Rest des Programms auszuführen, oder klicke [Quit], um das Programm zu beenden.

Das Debug-Kontrollfenster zeigt dir, welche Zeile gleich ausgeführt wird, wenn du den [Step]-Button im Debug-Kontrollfenster klickst. Der Debugger hat Zeile 3 übersprungen, weil sie leer ist. Beachte, dass du im Debugger nur vorwärts gehen kannst, du kannst nicht zurück gehen.

Globals-Bereich

Der Globals-Bereich im Debug-Kontrollfenster zeigt alle globalen Variablen an. Wie du dich bestimmt erinnerst, sind globale Variablen jene Variablen, die außerhalb von Funktionen definiert werden (also im globalen Geltungsbereich[Scope]).

Wenn die drei def-Statements ausgeführt werden, tauchen sie im Globals-Bereich des Debug-Kontrollfenster auf.

Der Text neben den Funktionsnamen im Globals-Bereich wird etwa so aussehen: "<function checkCave at 0x012859B0>". 