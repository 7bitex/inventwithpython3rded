    Capítulo 6
    REINO DE DRAGONES

Temas Tratados En Este Capítulo:
•   El módulo time.
•   La función time.sleep().
•   La palabra reservada return.
•   Creando nuestras propias funciones con la palabra reservada def.
•   Los operadores Booleanos and, or y not.
•   Tablas de verdad
•   Entorno de variables (Global y Local)
•   Parámetros y Argumentos
•   Diagramas de Flujo

Introducción a las Funciones

Ya hemos usado dos funciones en nuestros programas anteriores: input() y print(). En los programas anteriores, hemos llamado a estas funciones para ejecutar el código dentro de ellas. En este capítulo, escribiremos nuestras propias funciones para que sean llamadas por programas. Una función es como un mini-programa dentro de nuestro programa. Muchas veces en un programa queremos ejecutar exactamente el mismo código múltiples veces. En lugar de escribir el código varias veces, podemos poner el código dentro de una función y llamar a la función varias veces. Esto tiene el beneficio adicional de que si cometemos un error, sólo tendremos que corregirlo en un lugar del código.
El juego que crearemos para presentar las funciones se llama "Reino de Dragones", y permite al jugador elegir entre dos cuevas, en una de las cuales encontrará un tesoro y en la otra su perdición.

Cómo Jugar a "Reino de Dragones"

En este juego, el jugador está en una tierra llena de dragones. Todos los dragones viven en cuevas junto a sus grandes montones de tesoros encontrados. Algunos dragones son amigables, y compartirán sus tesoros contigo. Otros son codiciosos y hambrientos, y se comerán a cualquiera que entre a su cueva. El jugador se encuentra frente a dos cuevas, una con un dragón amigable y la otra con un dragón hambriento. El jugador tiene que elegir entre las dos.
Abre una nueva ventana del editor de archivos haciendo clic en el menú Archivo, luego haz clic en Nueva Ventana. En la ventana vacía que aparece escribe el código fuente y guárdalo como dragon.py. Luego ejecuta el programa pulsando F5.

Prueba de Ejecución de Reino de Dragones

Estás en una tierra llena de dragones. Frente a tí
hay dos cuevas. En una de ellas, el dragón es generoso y amigable
y compartirá su tesoro contigo. El otro dragón
es codicioso y está hambriento, y te devorará inmediatamente.
¿En qué cueva quieres entrar? (1 ó 2)
1
Te aproximas a la cueva...
Es oscura y espeluznante...
¡Un gran dragon aparece súbitamente frente a tí! Abre sus fauces y...
¡Te engulle de un bocado!
¿Quieres jugar de nuevo? (sí or no)
no

El Código Fuente de Reino de Dragones

Algo a tener en cuenta mientras lees el código a continuación: Los bloques debajo de las líneas def definen una función, pero el código en ese bloque no se ejecuta hasta que la función es llamada. El código no ejecuta cada línea de este programa en orden descendente. Esto será explicado en detalle más adelante en este capítulo.

¡NOTA IMPORTANTE! Los programas de este libro sólo podrán ejecutarse sobre Python 3, no Python 2. Al iniciar la ventana IDLE, dirá algo como “Python 3.4.0” en la parte superior. Si tienes Python 2 instalado, es posible instalar también Python 3 a la vez. Para descargar Python 3, dirígete a https://python.org/download/.
Si obtienes errores luego de copiar este código, compáralo con el código del libro usando la herramienta diff online en http://invpy.com/diff/dragón.

dragón.py
 1. import random
 2. import time
 3.
 4. def mostrarIntroducción():
 5.     print('Estás en una tierra llena de dragones. Frente a tí')
 6.     print('hay dos cuevas. En una de ellas, el dragón es generoso y amigable')
 7.     print('y compartirá su tesoro contigo. El otro dragón')
 8.     print('es codicioso y está hambriento, y te devorará inmediatamente.')
 9.     print()
10.
11. def elegirCueva():
12.     cueva = ''
13.     while cueva != '1' and cueva != '2':
14.         print('¿En qué cueva quieres entrar? (1 ó 2)')
15.         cueva = input()
16.
17.     return cueva
18.
19. def explorarCueva(cuevaElegida):
20.     print('Te aproximas a la cueva...')
21.     time.sleep(2)
22.     print('Es oscura y espeluznante...')
23.     time.sleep(2)
24.     print('¡Un gran dragon aparece súbitamente frente a tí! Abre sus fauces y...')
25.     print()
26.     time.sleep(2)
27.
28.     cuevaAmigable = random.randint(1, 2)
29.
30.     if cuevaElegida == str(cuevaAmigable):
31.          print('¡Te da su tesoro!')
32.     else:
33.          print('¡Te engulle de un bocado!')
34.
35. jugarDeNuevo = 'sí'
36. while jugarDeNuevo == 'sí' or jugarDeNuevo == 's':
37.
38.     mostrarIntroducción()
39.
40.     númeroDeCueva = elegirCueva()
41.
42.     explorarCueva(númeroDeCueva)
43.
44.     print('¿Quieres jugar de nuevo? (sí or no)')
45.     jugarDeNuevo = input()

Cómo Funciona el Código

Veamos el código fuente en más detalle.

 1. import random
 2. import time

El programa importa dos módulos. El módulo random proveerá la función random.randint() como lo hizo en el juego “Adivina el Número”. También precisarás funciones relacionadas con tiempo, que están incluidas en el módulo time, de modo que también importaremos este módulo.

Sentencias def

 4. def mostrarIntroducción():
 5.     print('Estás en una tierra llena de dragones. Frente a tí')
 6.     print('hay dos cuevas. En una de ellas, el dragón es generoso y amigable')
 7.     print('y compartirá su tesoro contigo. El otro dragón')
 8.     print('es codicioso y está hambriento, y te devorará inmediatamente.')
 9.     print()

La línea 4 es una sentencia def. La sentencia def crea, es decir, define, una nueva función que puede ser llamada más adelante en el programa. Luego de haber definido esta función, puedes llamarla de la misma forma en que llamas a otras funciones. Cuando llamas a esta función, el código dentro del bloque def se ejecuta.
La Figura 6-1 muestra las partes de una sentencia def. Comienza con la palabra reservada def seguida por un nombre de función con paréntesis y luego dos puntos. El bloque a continuación de la sentencia def se llama el bloque def.

Figura 6-1: Las partes de una sentencia def.

Recuerda, la sentencia def no ejecuta el código. Sólo define qué código se ejecutará cuando llames a la función. Cuando la ejecución llega a una sentencia def, omite lo que sigue hasta la primera línea a continuación del bloque def.
Pero cuando la función mostrarIntroducción() es llamada (como en la línea 38), la ejecución entra a la función mostrarIntroducción()  y se posiciona en la primera línea del bloque def.

38.     mostrarIntroducción()

Todas las llamadas a print() se ejecutan, y se muestra la introducción “Estás en una tierra llena de dragones...”.

Dónde Colocar las Definiciones de Funciones

La sentencia def y el bloque def de una función deben aparecer antes de llamar a la función. Esto es igual que cuando tienes que asignarle un valor a una variable antes de usar la variable. Si colocas la llamada a la función antes que la definición de la función, obtendrás un error. Mira este código:

decirAdios()

def decirAdios():
    print('¡Adios!')

Si tratas de ejecutarlo, Python te dará un mensaje de error como este:

Traceback (most recent call last):
  File "C:\Python34\spam.py", line 1, in <module>
sayGoodbye()
NameError: name 'decirAdios' is not defined

Para arreglar esto, coloca la definición de la función antes de llamar a la función:

def decirAdios():
    print('¡Adios!')

decirAdios()

Definiendo la Función elegirCueva()

11. def elegirCueva():

Aquí estás definiendo otra función llamada elegirCueva(). El código de esta función pregunta al jugador a qué cueva quiere entrar, 1 ó 2.

12.     cueva = ''
13.     while cueva != '1' and cueva != '2':

Este código necesita asegurar que el jugador haya respondido 1 ó 2, y no otra cosa. Un bucle aquí seguirá preguntando al jugador hasta que escriba alguna de estas dos respuestas válidas.
La línea 12 crea una nueva variable llamada cueva y guarda en ella una cadena vacía. Luego un bucle while comienza en la línea 13. La condición contiene un nuevo operador que no has visto antes llamado and. Igual que los signos - o * son operadores matemáticos y los signos == o != son operadores de comparación, el operador and es un operador Booleano.

Operadores Booleanos

Boolean logic deals with things that are either True or False. Boolean operators compare two Boolean values and evaluate to a single Boolean value. The and Boolean operator combines two Boolean values to produce a new Boolean value.
Think of the sentence, “Cats have whiskers and dogs have tails.” “Cats have whiskers” is true and “dogs have tails” is also true, so the entire sentence “Cats have whiskers and dogs have tails” is true.
But the sentence, “Cats have whiskers and dogs have wings” would be false. Even though “cats have whiskers” is true, dogs do not have wings, so “dogs have wings” is false. In Boolean logic, things can only be entirely true or entirely false. Because of the word “and”, the entire sentence is only true if both parts are true. If one or both parts are false, then the entire sentence is false.
The and and or Operators
The and operator in Python is the same. If the Boolean values on both sides of the and keyword are True, then the expression with the and operator evaluates to True. If either of the Boolean values are False, or both of the Boolean values are False, then the expression evaluates to False.
Try entering the following expressions with the and operator into the interactive shell:

>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False
False
>>> 10 < 20 and 'Hello' == 'Hello'
True

The or operator is similar to the and operator, except it will evaluate to True if either of the two Boolean values are True. The only time the or operator evaluates to False is if both of the Boolean values are False.
Try entering the following into the interactive shell:

>>> True or True
True
>>> True or False
True
>>> False or True
True
>>> False or False
False
>>> 10 > 20 or 20 > 10
True

The not Operator

The not operator only works on one value, instead of combining two values. The not operator evaluates to the opposite Boolean value. The expression not True will evaluate to False and not False will evaluate to True.
Try entering the following into the interactive shell:

>>> not True
False
>>> not False
True
>>> not 'black' == 'white'
True

Truth Tables

If you ever forget how the Boolean operators work, you can look at these charts, which are called truth tables:

Table 6-1: The and operator's truth table.
A       And B       Is  Entire statement
True    And True    Is  True
True    And False   Is  False
False   And True    Is  False
False   And False   Is  False

Table 6-2: The or operator's truth table.
A       And B       Is  Entire statement
True    And True    Is  True
True    And False   Is  False
False   And True    Is  False
False   And False   Is  False

Table 6-3: The not operator's truth table.
not A   is  Entire statement
not True    is  False
not False   is  True

Evaluating Boolean Operators

Look at line 13 again:

13.     while cave != '1' and cave != '2':

The condition has two parts connected by the and Boolean operator. The condition is True only if both parts are True.
The first time the while statement’s condition is checked, cave is set to the blank string, ''. The blank string is not equal to the string '1', so the left side evaluates to True. The blank string is also not equal to the string '2', so the right side evaluates to True.
So the condition then turns into True and True. Because both Boolean values are True, the condition finally evaluates to True. So the program execution enters the while-block.
This is what the evaluation of the condition looks like (if the value of cave is the blank string):

while cave != '1' and cave != '2':
                   ▼
while  ''  != '1' and cave != '2':
                   ▼
while     True    and cave != '2':
                   ▼
while     True    and  ''  != '2':
                   ▼
while     True    and     True:
                   ▼
while             True:

Getting the Player’s Input

13.     while cave != '1' and cave != '2':
14.         print('Which cave will you go into? (1 or 2)')
15.         cave = input()

Line 14 asks the player which cave they choose. Line 15 lets the player type the response and hit ENTER. This response is stored in cave. After this code is executed, the execution loops back to the top of the while statement and rechecks the condition.
If the player typed in 1 or 2, then cave will either be '1' or '2'. This makes the condition False, and the program execution will continue past the while loop. For example, if the user entered '1' then the evaluation would look like this:

while cave != '1' and cave != '2':
                   ▼
while  '1' != '1' and cave != '2':
                   ▼
while     False   and cave != '2':
                   ▼
while     False   and  '1' != '2':
                   ▼
while     False   and     True:
                   ▼
while            False:

But if the player typed 3 or 4 or HELLO, that response would be invalid. The condition will still be True and enters the while-block to ask the player again. The program will keep asking until the player types 1 or 2. This will guarantee that once the execution moves on, the cave variable contains a valid response.

Return Values

17.     return cave

This is a return statement, which only appears inside def-blocks. Remember how the input() function returns a string value that the player typed in? The elegirCueva() function will also return a value. Line 17 returns the string that is stored in cave, either '1' or '2'.
Once the return statement executes, the program execution jumps immediately out of the def-block. (This is like how the break statement will make the execution jump out of a while-block.) The program execution moves back to the line with the function call. The function call itself will evaluate to the return value.
Skip down and look at line 40 for a moment:

40.     caveNumber = elegirCueva()

When the elegirCueva() is later called by the program on line 40, the return value is stored in the caveNumber variable. The while loop guarantees that elegirCueva() will only return either '1' or '2' as its return value.
So when line 17 returns a string, the function call on line 40 evaluates to this string, which is then stored in caveNumber.

Global Scope and Local Scope

Your program’s variables are forgotten after the program terminates. These variables created while the execution is inside a function call are the same. The variables are created when the function is called and forgotten when the function returns.
Not only that, but when execution is inside the function, you cannot change the variables outside of the function, including variables inside other functions. This is because these variables exist in a different “scope”. All variables exist in either the global scope or a function call’s local scope.
The scope outside of all functions is called the global scope. The scope inside of a function (for the duration of a particular function call) is called a local scope. The entire program has only one global scope, and each function has a local scope of its own.
Variables defined in the global scope can be read outside and inside functions, but can only be modified outside of all functions. Variables created in a function call can only be read or modified during that function call.
You can read the value of global variables from the local scope, but attempting to change a global variable from the local scope won’t work. What Python actually does in that case is create a local variable with the same name as the global variable. You could, for example, have a local variable named spam at the same time as having a global variable named spam. Python will consider these to be two different variables.
Look at this example to see what happens when you try to change a global variable from inside a local scope. The comments explain what is going on:

def bacon():
    # We create a local variable named "spam"
    # instead of changing the value of the global
    # variable "spam":
    spam = 99
    # The name "spam" now refers to the local
    # variable only for the rest of this
    # function:
    print(spam)    # 99

spam = 42 # A global variable named "spam":
print(spam) # 42
bacon() # Call the bacon() function:
# The global variable was not changed in funky():
print(spam)    # 42

When run, this code will output the following:

42
99
42

Where a variable is created determines what scope it is in. When the Dragon Realm program first executes the line:

12.     cave = ''

...the variable cave is created inside the elegirCueva() function. This means it is created in the elegirCueva() function’s local scope. It will be forgotten when elegirCueva() returns, and will be recreated if elegirCueva() is called a second time. The value of a local variable isn’t remembered in between function calls.

Defining the checkCave() Function

19. def checkCave(chosenCave):

The next function the program defines is named checkCave(). Notice that the text chosenCave in between the parentheses. This is a parameter: a local variable that is assigned the argument passed in when this function is called.
Remember how for some function calls like str() or randint(), you would pass an argument in between the parentheses:

>>> str(5)
'5'
>>> random.randint(1, 20)
14

You will also pass an argument when you call checkCave(). This argument is stored in a new variable named chosenCave. These variables are also called parameters.

Parameters

Parameters are local variables created when a function is called. For example, here is a short program that demonstrates defining a function with a parameter:

def sayHello(name):
    print('Hello, ' + name + '. Your name has ' + str(len(name)) + 'letters.')

sayHello('Alice')
sayHello('Bob')
spam = 'Carol'
sayHello(spam)

If you run this program, it would look like this:

Hello, Alice. Your name has 5 letters.
Hello, Bob. Your name has 3 letters.
Hello, Carol. Your name has 5 letters.

When you call sayHello(), the argument is assigned to the name parameter. Parameters are just ordinary local variables. Like all local variables, the values in parameters will be forgotten when the function call returns.

Displaying the Game Results

Back to the game’s source code:

20.     print('You approach the cave...')
21.     time.sleep(2)

Remember that calling the function random.randint() required you execute import random first? In the Dragon Realm game, you imported the time module on line 2. The time module has a function called sleep() that pauses the program. This function will pause the program for a few seconds. Line 21 passes the integer value 2 so that time.sleep() will pause the program for 2 seconds.

22.     print('It is dark and spooky...')
23.     time.sleep(2)

Here the code prints some more text and waits for another 2 seconds. These short pauses add suspense to the game, instead of displaying the text all at once. In the previous chapter’s Jokes program, you called the input() function to pause until the player pressed the ENTER key. Here, the player doesn’t have to do anything except wait a couple seconds.

24.     print('A large dragon jumps out in front of you! He opens his jaws and...')
25.     print()
26.     time.sleep(2)

What happens next? And how does the program decide? This is explained in the next section.

Deciding Which Cave has the Friendly Dragon

28.     friendlyCave = random.randint(1, 2)

The program randomly choses which cave had the friendly dragon in it. Line 28 calls the random.randint() function which will return either 1 or 2. This integer value is stored in friendlyCave.

30.     if chosenCave == str(friendlyCave):
31.          print('Gives you his treasure!')

Line 30 checks if the player’s chosen cave in the chosenCave variable ('1' or '2') is equal to the       friendly dragon cave.
The value in chosenCave is a string because input() returns strings. But the value in friendlyCave is an integer because random.randint() returns integers. You can’t compare strings and integers with the == sign, because they will always be not equal. '1' doesn’t equal 1 and '2' doesn’t equal 2.
So friendlyCave is passed to str() function, which returns the string value of friendlyCave. This way the values will be the same data type and can be meaningfully compared to each other. This code could also have been used:

    if int(chosenCave) == friendlyCave:

The above if statement’s condition would compare the integer value returned by the int() function to the integer value in friendlyCave. This code would also work.
If the condition is True, line 31 tells the player they have won the treasure.

32.     else:
33.          print('Gobbles you down in one bite!')

Line 32 is an else statement. The else keyword always comes after the if-block. The else-block executes if the if statement’s condition was False. Think of it as the program’s way of saying, “If this condition is true then execute the if-block or else execute the else-block.”
Remember to put the colon (the : sign) after the else keyword.

Where the Main Part Begins

35. playAgain = 'yes'
36. while playAgain == 'yes' or playAgain == 'y':

Line 35 is the first line that isn’t a def statement or inside a def-block. This line is where the main part of the program begins. The previous def statements merely defined the functions. It didn’t run the code inside of the functions.
Line 35 and 36 are setting up a loop that the rest of the game code fits in. At the end of the game, the player can enter if they want to play again. If they do, the execution enters the while loop to run the entire game all over again. If they don’t, the while statement’s condition will be False and the execution will move on to the end of the program and terminate.
The first time the execution comes to this while statement, line 35 will have just assigned 'yes' to the playAgain variable. That means the condition will be True.

Calling the Functions in the Program

38.     mostrarIntroducción()

Line 38 calls the mostrarIntroducción() function. This isn’t a Python function, it is your function that you defined earlier on line 4. When this function is called, the program execution jumps to the first line in the mostrarIntroducción() function on line 5. When all the lines in the function are done, the execution jumps back to line 38 and continues moving down.

40.     caveNumber = elegirCueva()

Line 40 also calls a function that you defined. Remember that the elegirCueva() function lets the player type in the cave they choose to go into. When the line 17’s return cave executes, the program execution jumps back to line 40, and the elegirCueva() call evaluates to the return value. This return value is stored in a new variable named caveNumber. Then the program execution moves on to line 42.

42.     checkCave(caveNumber)

This line calls your checkCave() function, passing the value in caveNumber as an argument. Not only does execution jump to line 20, but the value in caveNumber is copied to the parameter chosenCave inside the checkCave() function. This is the function that will display either 'Gives you his treasure!' or 'Gobbles you down in one bite!' depending on the cave the player chose to go in.

Asking the Player to Play Again

44.     print('Do you want to play again? (yes or no)')
45.     playAgain = input()

Whether the player won or lost, they are asked if they want to play again. The variable playAgain stores the string that the player typed in. Line 45 is the last line of the while-block, so the program jumps back to line 36 to check the condition: playAgain == 'yes' or playAgain == 'y'
If the player typed in the string 'yes' or 'y', then the execution would enter the loop again at line 38.
If the player typed in 'no' or 'n' or something silly like 'Abraham Lincoln', then the condition would be False. The program execution continues on to the line after the while-block. But since there are no more lines after the while-block, the program terminates.
One thing to note: the string 'YES' is not equal to the string 'yes'. If the player typed in the string 'YES', then the while statement’s condition would evaluate to False and the program would still terminate. Later programs in this book will show you how to avoid this problem.
You've just completed your second game! In Dragon Realm, you used a lot of what you learned in the “Guess the Number” game and picked up a few new tricks. If you didn't understand some of the concepts in this program, then read the summary at the end of this chapter. Or go over each line of the source code again, and try changing the source code and see how the program changes.
In the next chapter you won't create a game, but instead learn how to use a feature of IDLE called the debugger.

Designing the Program

Dragon Realm is a simple game. The other games in this book will be a bit more complicated. It sometimes helps to write down everything you want your game or program to do before you start writing code. This is called “designing the program.”
For example, it may help to draw a flow chart. A flow chart is a picture that shows every possible action that can happen in the game, and which actions lead to which other actions. Figure 6-2 is a flow chart for Dragon Realm.

Figure 6-2: Flow chart for the Dragon Realm game.

To see what happens in the game, put your finger on the “Start” box. Then follow one arrow from the box to another box. Your finger is like the program execution. The program terminates when your finger lands on the “End” box.
When you get to the “Check for friendly or hungry dragon” box, you can go to the “Player wins” box or the “Player loses” box. This branching point shows how the program can do different things. Either way, both paths will end up at the “Ask to play again” box.

Summary

In the “Dragon Realm” game, you created your own functions. Functions are a mini-program within your program. The code inside the function runs when the function is called. By breaking up your code into functions, you can organize your code into smaller and easier to understand sections.
Arguments are values passed to the function’s code when the function is called. The function call itself evaluates to a value called the return value.
You also learned about variable scopes. Variables created inside of a function exist in the local scope, and variables created outside of all functions exist in the global scope. Code in the global scope cannot make use of local variables. If a local variable has the same name as a variable in the global scope, Python considers it a separate variable and assigning new values to the local variable won’t change the value in the global variable.
Variable scopes might seem complicated, but they are useful for organizing functions as separate pieces of code from the rest of the program. Because each function has its own local scope, you can be sure that the code in one function won’t cause bugs in other functions.
Almost every program uses functions because they are so useful. By understanding how functions work, you can save ourselves a lot of typing and make bugs easier to fix.
