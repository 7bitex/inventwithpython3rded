    Capítulo 17
    GRÁFICOS Y ANIMACIÓN

Temas Tratados En Este Capítulo:

•   Instalando Pygame
•   Colores y Fuentes en Pygame
•   Gráficos distorsionados y Anti-Aliasing
•   Atributos
•   Los Tipos de Datos pygame.font.Font, pygame.Surface, pygame.Rect y pygame.PixelArray
•   Función Constructor
•   Las Funciones de Dibujo de Pygame
•   El Método blit() para Objetos Surface
•   Eventos
•   Animación

Hasta ahora, todos nuestros juegos han usado sólo texto. El texto es presentado en la pantalla como salida, y el jugador escribe texto mediante el teclado como entrada. Usar sólo texto hace que programar sea fácil de aprender. Pero en este capítulo crearemos juegos más emocionantes con gráficos y sonidos avanzados usando el módulo Pygame.

Los capítulos 17, 18 y 19 te enseñan a usar Pygame para crear juegos con gráficos, animación, entrada mediante el ratón y sonido. En estos capítulos escribiremos código fuente para programas simples que no son juegos pero demuestran los conceptos de Pygame que iremos aprendiendo. El juego en el capítulo 20 usará todos estos conceptos juntos para crear un juego.

Instalando Pygame

Pygame no viene con Python. Igual que Python, Pygame puede descargarse gratis. En un navegador, ve a la URL http://invpy.org/downloadpygame y descarga el archivo de instalación de Pygame para tu sistema operativo y versión de Python.

Abre el archivo de instalación luego de descargarlo, y sigue las instrucciones hasta concluir la instalación de Pygame. Para comprobar que Pygame esté correctamente instalado, escribe lo siguiente en la consola interactiva:

>>> import pygame

Si no aparece nada luego de haber pulsado la tecla INTRO, significa que Pygame se ha instalado correctamente. Si aparece el error ImportError: No module named pygame, intenta volver a instalar Pygame (y asegúrate de haber escrito import pygame correctamente).

Figura 17-1: El sitio web pygame.org.

El sitio web Pygame en http://pygame.org contiene información acerca de cómo usar Pygame, así como también otros juegos hechos con Pygame. La Figura 17-1 muestra el sitio Pygame.

Hola Mundo en Pygame

El primer programa Pygame es un nuevo programa “¡Hola Mundo!” como el que has creado al principio de este libro. Esta vez, usarás Pygame para hacer que aparezca “¡Hola mundo!” en una ventana gráfica en lugar de ser sólo texto.

Pygame no funciona bien con la consola interactiva. Por esta razón, es posible escribir programas Pygame pero no se puede enviar instrucciones una a la vez a Pygame a través de la consola interativa.

Los programas de Pygame tampoco utilizan la función input(). No hay entrada y salida de texto. En su lugar, el programa muestra su salida en una ventana dibujando gráficos y texto en la ventana. La entrada de un programa de Pygame proviene del teclado y el ratón a través de cosas llamadas eventos. Los eventos se explican en el próximo capítulo.

Código Fuente de Hola Mundo

Escribe el siguiente código en el editor de archivos, y guárdalo como pygameHolaMundo.py. Si obtienes errores luego de escribir el código, compara lo que has escrito con el código del libro usando la herramienta diff online en http://invpy.com/diff/pygameHolaMundo.

pygameHolaMundo.py

 1. import pygame, sys
 2. from pygame.locals import *
 3. 
 4. # configurar pygame
 5. pygame.init()
 6. 
 7. # configurar la ventana
 8. superficieVentana = pygame.display.set_mode((500, 400), 0, 32)
 9. pygame.display.set_caption('¡Hola mundo!')
10. 
11. # configurar los colores
12. NEGRO = (0, 0, 0)
13. BLANCO = (255, 255, 255)
14. ROJO = (255, 0, 0)
15. VERDE = (0, 255, 0)
16. AZUL = (0, 0, 255)
17. 
18. # configurar fuentes
19. fuenteBásica = pygame.font.SysFont(None, 48)
20. 
21. # configurar el texto
22. texto = fuenteBásica.render('¡Hola mundo!', True, BLANCO, AZUL)
23. textRect = texto.get_rect()
24. textRect.centerx = superficieVentana.get_rect().centerx
25. textRect.centery = superficieVentana.get_rect().centery
26. 
27. # pintar un fondo blanco sobre la ventana
28. superficieVentana.fill(BLANCO)
29. 
30. # dibujar un polígono verde sobre la superficie
31. pygame.draw.polygon(superficieVentana, VERDE, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))
32. 
33. # dibujar algunas líneas azules sobre la superficie
34. pygame.draw.line(superficieVentana, AZUL, (60, 60), (120, 60), 4)
35. pygame.draw.line(superficieVentana, AZUL, (120, 60), (60, 120))
36. pygame.draw.line(superficieVentana, AZUL, (60, 120), (120, 120), 4)
37. 
38. # dibujar un círculo azul sobre la superficie
39. pygame.draw.circle(superficieVentana, AZUL, (300, 50), 20, 0)
40. 
41. # dibujar una elipse roja sobre la superficie
42. pygame.draw.ellipse(superficieVentana, ROJO, (300, 250, 40, 80), 1)
43. 
44. # dibujar el rectángulo de fondo para el texto sobre la superficie
45. pygame.draw.rect(superficieVentana, ROJO, (textRect.left - 20, textRect.top - 20, textRect.width + 40, textRect.height + 40))
46. 
47. # obtener un arreglo de píxeles de la superficie
48. arregloDePíxeles = pygame.PixelArray(superficieVentana)
49. arregloDePíxeles[480][380] = NEGRO
50. del arregloDePíxeles
51. 
52. # dibujar el texto sobre la superficie
53. superficieVentana.blit(texto, textRect)
54. 
55. # dibujar la ventana sobre la pantalla
56. pygame.display.update()
57. 
58. # ejecutar el bucle del juego
59. while True:
60.     for event in pygame.event.get():
61.         if event.type == QUIT:
62.             pygame.quit()
63.             sys.exit()

Ejecutando el Programa Hola Mundo

Al ejecutar este programa, deberías ver aparecer una nueva ventana como la de la Figura 17-2.

Lo bueno de usar una ventana en lugar de una consola es que el texto puede aparecer en cualquier lugar de la ventana, no sólo a continuación del último texto que se ha mostrado. El texto puede ser de cualquier tamaño y color. La ventana es como un lienzo de pintura en blanco, y puedes dibujarle encima lo que quieras.

Importando el Módulo Pygame

Recorramos estas líneas de código y veamos lo que hacen.

 1. import pygame, sys
 2. from pygame.locals import *

Figura 17-2: El programa “Hola Mundo”.

Primero necesitas importar el módulo pygame para poder llamar a las funciones de Pygame. Puedes importar varios módulos en la misma línea separando los nombres de los mismos con comas. La línea 1 importa los módulos pygame y sys.

La segunda línea importa el módulo pygame.locals. Este módulo contiene muchas variables constantes que usarás con Pygame, tales como QUIT or K_ESCAPE (explicadas más adelante). Sin embargo, usando la fórmula from moduleName import * puedes importar el módulo pygame.locals de forma que no sea necesario escribir pygame.locals delante de cada una de las constantes del módulo.

Si usaras from sys import * en lugar de import sys en tu programa, tendrías que llamar a exit() en lugar de sys.exit() en tu código. Pero la mayoría de las veces es mejor usar el nombre completo de la función para tener claro en qué módulo se encuentra la función.

La Función pygame.init()

 4. # configurar pygame
 5. pygame.init()

Todos los programas de Pygame deben llamar a la función pygame.init() luego de haber importado el módulo pygame, pero antes de llamar a cualquier otra función de Pygame. Esto realiza los pasos necesarios para la inicialización de Pygame.

Tuplas

Los valores de tuplas son similares a las listas, excepto que utilizan paréntesis en lugar de corchetes. Además, como las cadenas, las tuplas no pueden ser modificadas. Por ejemplo, prueba escribir lo siguiente en la consola interactiva:

>>> spam = ('Vida', 'Universo', 'Todo', 42)
>>> spam[0]
'Vida'
>>> spam[3]
42
>>> spam[1:3]
('Universo', 'Todo')

Las Funciones pygame.display.set_mode() y pygame.display.set_caption()

 7. # configurar la ventana
 8. superficieVentana = pygame.display.set_mode((500, 400), 0, 32)
 9. pygame.display.set_caption('¡Hola mundo!')

La línea 8 crea una ventana GUI al llamar al método set_mode() en el módulo pygame.display. (El módulo display es un módulo contenido dentro del módulo pygame. ¡El módulo pygame tiene hasta sus propios módulos!)

Un píxel es el punto más pequeño en la pantalla de tu computadora. Cada píxel puede iluminarse con cualquier color. Todos los píxeles de tu pantalla trabajan juntos para mostrar todas las imágenes que ves. Para crear una ventana de 500 píxeles de ancho por 400 píxeles de alto, se usa la tupla (500, 400) como el primer parámetro de pygame.display.set_mode().

Se usan tres parámetros para el método set_mode(). El primero es una tupla de dos enteros para el ancho y alto de la ventana, en píxeles. El segundo y tercer parámetro son opciones avanzadas que no trataremos en este libro. Sólo pasa 0 y 32 respectivamente.

La función set_mode() devuelve un objeto pygame.Surface (al cual aquí llamaremos objeto Surface por brevedad). Objeto es sólo otro nombre para un valor de un tipo de datos que tiene métodos asociados. Por ejemplo, las cadenas son objetos en Python porque tienen datos (la cadena en sí misma) y métodos (tales como lower() y split()). El objeto Surface representa la ventana.

Las variables guardan referencias a objetos igual que podrían guardar referencias a listas y diccionarios. La sección Referencias en el capítulo 10 explica lo que son las referencias.

Colores RGB

11. # configurar los colores
12. NEGRO = (0, 0, 0)
13. BLANCO = (255, 255, 255)
14. ROJO = (255, 0, 0)
15. VERDE = (0, 255, 0)
16. AZUL = (0, 0, 255)

Tabla 17-1: Colores y sus valores RGB.
Color    Valores RGB
Negro    (  0,   0,   0)
Azul     (  0,   0, 255)
Gris     (128, 128, 128)
Verde    (  0, 128,   0)
Lima     (  0, 255,   0)
Púrpura  (128,   0, 128)
Rojo     (255,   0,   0)
Turquesa (  0, 128, 128)
Blanco   (255, 255, 255)
Amarillo (255, 255,   0)

Hay tres colores primarios de luz: rojo, verde y azul. Combinando diferentes cantidades de estos tres colores (que es lo que hace tu pantalla hace) puedes formar cualquier otro color. En Pygame, las estructuras de datos que representan un color son tuplas de tres enteros. Se las llama valores de Color RGB.

El primer valor en la tupla es la cantidad de rojo en el color. Un valor de 0 significa que no hay rojo en este color, y un valor de 255 significa que está presente la máxima cantidad de rojo en el color. Los valores segundo y tercero corresponden a la cantidad de verde y azul respectivamente. Estos enteros forman una tupla RGB.

Por ejemplo, la tupla (0, 0, 0) no tiene nada de rojo, verde o azul. El color resultante es negro puro. La tupla (255, 255, 255) tiene el máximo de rojo, verde y azul, resultando en blanco.

La tupla (255, 0, 0) representa el máximo de rojo pero nada de verde o azul, luego el color resultante es rojo. Similarmente, (0, 255, 0) es verde y (0, 0, 255) es azul.

Puedes mezclar la cantidad de rojo, verde y azul para obtener cualquier matiz de cualquier color. La Tabla 17-1 tiene algunos colores comunes y sus valores RGB. La página web http://invpy.com/colors muestra otros valores de tuplas para diferentes colores.

Fuentes, y la Función pygame.font.SysFont()

18. # configurar fuentes
19. fuenteBásica = pygame.font.SysFont(None, 48)

Figura 17-3: Ejemplos de diferentes fuentes.

Una fuente es un conjunto completo de letras, números, símbolos y caracteres dibujados en el mismo estilo. La Figura 17-3 muestra la misma oración escrita en diferentes fuentes.

En nuestros juegos anteriores, sólo hicimos que Python imprimiera texto. El color, tamaño y fuente que se usaba para mostrar este texto estaba completamente determinado por tu sistema operativo. El programa Python no podía cambiar la fuente. Sin embargo, Pygame puede dibujar texto en cualquier fuente de tu computadora.

La línea 19 crea un objeto pygame.font.Font (llamado objeto Font para abreviar) llamando a la función pygame.font.SysFont(). El primer parámetro es el nombre de la fuente, pero le pasaremos el valor None para usar la fuente del sistema por defecto. El segundo parámetro es el tamaño de la fuente (que se mide en unidades llamadas puntos).

El Método render() para Objetos Font

21. # configurar el texto
22. texto = fuenteBásica.render('¡Hola mundo!', True, BLANCO, AZUL)
23. textRect = texto.get_rect()

Figura 17-4: Una vista aumentada de una línea sin antialiasing y otra con antialiasing.

El objeto Font que has guardado en la variable fuenteBásica tiene un método llamado render(). Este método devolverá un objeto Surface con el texto dibujado sobre él. El primer parámetro de render() es la cadena de texto a dibujar. El segundo parámetro es un Booleano para indicar si quieres utilizar antialiasing.

En la línea 22, pasa True para usar antialiasing. El antialiasing difumina ligeramente tu texto para que se vea más suave. La Figura 17-4 muestra (con píxeles agrandados) cómo se ve una línea con y sin antialiasing.

Atributos

24. textRect.centerx = superficieVentana.get_rect().centerx
25. textRect.centery = superficieVentana.get_rect().centery

El tipo de datos pygame.Rect (llamado Rect para abreviar) representa áreas rectangulares con un cierto tamaño y posición asociados. Para crear un nuevo objeto llama a la función pygame.Rect(). Los parámetros son enteros para las coordenadas XY de la esquina superior izquierda, seguidos por el ancho y el alto, todos en píxeles.

El nombre de la función con los parámetros se ve así: pygame.Rect(izquierda, arriba, ancho, alto)

De la misma forma que los métodos son funciones asociadas con un objeto, los atributos son variables asociadas con un objeto. El tipo de datos Rect tiene muchos atributos que describen el rectángulo que representa. La Tabla 17-2 es una lista de atributos de un objeto Rect llamado myRect.

Lo genial de los objetos Rect es que si modificas alguno de estos atributos, el resto de ellos se modificará automáticamente. Por ejemplo, si creas un objeto Rect que tiene 20 píxeles de ancho y 20 de alto, cuya esquina superior izquierda está en las coordenadas (30, 40), entonces la coordenada X del lado derecho si fijará automáticamente en 50 (porque 20 + 30 = 50).

Sin embargo, si cambias el atributo left con la línea myRect.left = 100, entonces Pygame cambiará automáticamente el atributo right a 120 (porque 20 + 100 = 120). Todos los otros atributos para este objeto Rect también se actualizan.

Los Métodos get_rect() para Objetos pygame.font.Font y pygame.Surface

Nota que tanto el objeto Font (guardado en la variable texto en la línea 23) como el objeto Surface (guardado en la variable superficieVentana en la línea 24) tienen un método llamado get_rect(). Técnicamente, estos son dos métodos diferentes. Pero los programadores de Pygame les han dado el mismo nombre porque ambos hacen lo mismo y devuelven objetos Rect que representan el tamaño y posición del objeto Font o Surface en cuestión.

El módulo que importas es pygame, y dentro del módulo pygame están los módulos font y surface. Dentro de estos módulos están los tipos de datos Font y Surface. Los programadores de Pygame han decidido que los módulos empezaran con minúscula y los tipos de datos con mayúscula. Esto hace más fácil distinguir los tipos de datos de los módulos.

Funciones Constructor

Crea un objeto pygame.Rect llamando a la función pygame.Rect(). La función pygame.Rect() tiene el mismo nombre que el tipo de datos pygame.Rect. Las funciones que tienen el mismo nombre que su tipo de datos y crean objetos o valores de este tipo de datos se denominan funciones constructor.

El Método fill() para Objetos Surface

27. # pintar un fondo blanco sobre la ventana
28. superficieVentana.fill(BLANCO)

Queremos llenar toda la superficie almacenada en superficieVentana con el color blanco. La función fill() cubrirá completamente la superficie con el color que le pases como parámetro. (En este caso, la variable BLANCO corresponde al valor (255, 255, 255).

Algo importante a saber acerca de Pygame es que la ventana en la pantalla no cambiará cuando llames al método o a cualquiera de las otras funciones de dibujo. Éstas cambiarán al objeto Surface, pero el objeto Surface no será dibujado en la pantalla hasta que se llame a la función pygame.display.update().

Esto es porque modificar el objeto Surface en la memoria de la computadora es mucho más rápido que modificar la imagen en la pantalla. Es mucho más eficiente dibujar sobre la pantalla una vez luego de que todas las funciones hayan dibujado sobre el objeto Surface.

Las Funciones de Dibujo de Pygame

La función pygame.draw.polygon()

30. # dibujar un polígono verde sobre la superficie
31. pygame.draw.polygon(superficieVentana, VERDE, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))

Un polígono es una forma cuyos múltiples lados son líneas rectas. Círculos y elipses no son polígonos. La Figura 17-5 tiene algunos ejemplos de polígonos.

Tabla 17-2: Atributos Rect
pygame.Rect Atributo   Descripción
myRect.left Valor entero de la coordenada X del lado izquierdo del rectángulo.
myRect.right    Valor entero de la coordenada X del lado derecho del rectángulo.
myRect.top  Valor entero de la coordenada Y del lado superior del rectángulo.
myRect.bottom   Valor entero de la coordenada Y del lado inferior del rectángulo.
myRect.centerx  Valor entero de la coordenada X del centro del rectángulo.
myRect.centery  Valor entero de la coordenada Y del centro del rectángulo.
myRect.width    Valor entero del ancho del rectángulo.
myRect.height   Valor entero de la altura del rectángulo.
myRect.size Una tupla de dos enteros: (width, height)
myRect.topleft  Una tupla de dos enteros: (left, top)
myRect.topright Una tupla de dos enteros: (right, top)
myRect.bottomleft   Una tupla de dos enteros: (left, bottom)
myRect.bottomright  Una tupla de dos enteros: (right, bottom)
myRect.midleft  Una tupla de dos enteros: (left, centery)
myRect.midright Una tupla de dos enteros: (right, centery)
myRect.midtop   Una tupla de dos enteros: (centerx, top)
myRect.midbottom    Una tupla de dos enteros: (centerx, bottom)

Figura 17-5: Ejemplos de Polígonos.

La función pygame.draw.polygon() puede dibujar cualquier forma de polígono que le pases. Los parámetros, en orden, son:

•   El objeto Surface sobre el que se dibujará el polígono.
•   El color del polígono.
•   Una tupla de tuplas que representa las coordenadas XY de los puntos a dibujar en orden. La última tupla se conectará automáticamente con la primera para cerrar la forma.
•   Opcionalmente, un entero para el ancho de las líneas del polígono. Sin esto, el polígono será rellenado del color de la línea.

La línea 31 dibuja un pentágono verde en el objeto Surface.

La función pygame.draw.line()

33. # dibujar algunas líneas azules sobre la superficie
34. pygame.draw.line(superficieVentana, AZUL, (60, 60), (120, 60), 4)
35. pygame.draw.line(superficieVentana, AZUL, (120, 60), (60, 120))
36. pygame.draw.line(superficieVentana, AZUL, (60, 120), (120, 120), 4)

Los parámetros, en orden, son:

•   El objeto Surface sobre el que se dibujará la línea.
•   El color de la línea.
•   Una tupla de dos enteros para las coordenadas XY de un extremo de la línea.
•   Una tupla de dos enteros para las coordenadas XY del otro extremo de la línea.
•   Opcionalmente, un entero para el ancho de la línea.

Si pasas 4 para el ancho, la línea tendrá 4 píxeles de ancho. Si no especificas este parámetro, tomará el valor por defecto de 1. Las tres llamadas a pygame.draw.line() en las líneas 34, 35 y 36 dibujan la “Z” azul en el objeto Surface.

La Función pygame.draw.circle()

38. # dibujar un círculo azul sobre la superficie
39. pygame.draw.circle(superficieVentana, AZUL, (300, 50), 20, 0)

Los parámetros, en orden, son:

•   El objeto Surface sobre el que se dibujará el círculo.
•   El color del círculo.
•   Una tupla de dos enteros para las coordenadas XY del centro del círculo.
•   Un entero para el radio (es decir, el tamaño) del círculo.
•   Opcionalmente, un entero para el ancho. Un ancho de 0 significa que el círculo será rellenado.

La línea 39 dibuja un círculo azul en el objeto Surface.

La Función pygame.draw.ellipse()

41. # dibujar una elipse roja sobre la superficie
42. pygame.draw.ellipse(superficieVentana, ROJO, (300, 250, 40, 80), 1)

La función pygame.draw.ellipse() es similar a la función pygame.draw.circle(). Los parámetros, en orden, son:

•   El objeto Surface sobre el que se dibujará la elipse.
•   El color de la elipse.
•   Una tupla de cuatro enteros para los bordes izquierdo y superior, ancho y altura de la elipse.
•   Opcionalmente, un entero para el ancho. Un ancho de 0 significa que la elipse será rellenada.

La línea 42 dibuja una elipse roja en el objeto Surface Surface.

La Función pygame.draw.rect()

44. # dibujar el rectángulo de fondo para el texto sobre la superficie
45. pygame.draw.rect(superficieVentana, ROJO, (textRect.left - 20, textRect.top - 20, textRect.width + 40, textRect.height + 40))

La función pygame.draw.rect() dibuja un rectángulo. El tercer parámetro es una tupla de cuatro enteros para los bordes izquierdo y superior, ancho y altura del rectángulo. En lugar de una tupla de cuatro enteros para el tercer parámetro, también puedes pasarle un objeto Rect.

En la línea 45, quieres que el rectángulo que dibujas esté 20 píxeles alrededor del rectángulo de texto. Es por esto que los bordes inquierdo y superior del rectángulo corresponden a los bordes izquierdo y superior de textRect menos 20. (Recuerda, restas porque las coordenadas disminuyen cuando te mueves hacia arriba y hacia la izquierda.) Y el ancho y la altura corresponden al ancho y a la altura de textRect más 40 (para compensar por el desplazamiento adicional de 20 píxeles de los bordes izquierdo y superior).

El Tipo de Datos pygame.PixelArray

47. # obtener un arreglo de píxeles de la superficie
48. arregloDePíxeles = pygame.PixelArray(superficieVentana)
49. arregloDePíxeles[480][380] = NEGRO

La línea 48 crea un objeto pygame.PixelArray (llamado objeto PixelArray por brevedad). El objeto PixelArray es una lista de listas de tuplas de colores que representa el objeto Surface que le pasas.

La línea 48 pasa superficieVentana a pygame.PixelArray(), de modo que asignar NEGRO a arregloDePíxeles[480][380] en la línea 49 cambiará el color del píxel en las coordenadas (480, 380) a negro. Pygame modificará automáticamente el objeto superficieVentana con este cambio.

El primer índice en el objeto PixelArray es para la coordenada X. El segundo índice es para la coordenada Y. Los objetos PixelArray facilitan cambiar el color de píxeles individuales a un color específico.

50. del arregloDePíxeles

Crear un objeto PixelArray a partir de un objeto Surface bloquea al objeto Surface. Esto significa que no puede llamarse a la función blit() (descripta a continuación) sobre ese objeto Surface. Para desbloquear el objeto Surface, debes borrar el objeto PixelArray con el operador del. Si olvidas borrar el objeto PixelArray, recibirás un mensaje de error con el texto pygame.error: Surfaces must not be locked during blit.

El Método blit() Para Objetos Surface

52. # dibujar el texto sobre la superficie
53. superficieVentana.blit(texto, textRect)

El método blit() dibujará los contenidos de un objeto Surface sobre otro objeto Surface. La línea 53 imprime el objeto Surface "¡Hola mundo!" como texto y lo dibuja sobre el objeto Surface guardado en la variable superficieVentana.

El segundo parámetro de blit() especifica dónde en la superficie de superficieVentana se dibuja el texto. En este caso se pasa el objeto Rect que devuelve la llamada a text.get_rect() en la línea 23.

La Función pygame.display.update()

55. # dibujar la ventana sobre la pantalla
56. pygame.display.update()

En Pygame, nada se dibuja realmente sobre la pantalla hasta que se llama a la función pygame.display.update(). Esto es porque dibujar sobre la pantalla es lento comparado con dibujar sobre objetos Surface en la memoria de la computadora. No queremos actualizar la pantalla después de cada llamada a una función de dibujo, sino actualizar la pantalla una sola vez después de haber llamado a todas las funciones de dibujo.

Eventos y el Bucle del Juego

En juegos anteriores, todos los programas imprimían todo inmediatamente hasta que llegaban a una llamada a la función input(). En este punto, el programa se detenía y esperaba a que el usuario escribiera algo y presionara INTRO. Pero los programas de Pygame se ejecutan constantemente a través de un bucle llamado el bucle del juego. En este programa, todas las líneas de código en el bucle de juego se ejecutan alrededor de cien veces por segundo.

El bucle de juego es un bucle que constantemente busca nuevos eventos, actualiza el estado de la ventana y dibuja la ventana en la pantalla. Los eventos son objetos del tipo de datos pygame.event.Event, los cuales son generados por Pygame cada vez que el usuario pulsa una tecla, hace clic o mueve el ratón, o hace que ocurra algún otro evento. (Estos eventos se listan en la Tabla 18-1.)

58. # ejecutar el bucle del juego
59. while True:

La línea 59 es el comienzo del bucle del juego. La condición para la sentencia while se fija en True de modo que el bucle continúe para siempre. El único caso en que el bucle se detiene es si un evento causa que el programa termine.

La Función pygame.event.get()

60.     for event in pygame.event.get():
61.         if event.type == QUIT:

Llamar a pygame.event.get() recupera cualquier nuevo objeto pygame.event.Event (llamado objeto Event por brevedad) que haya sido generado desde la última llamada a pygame.event.get(). Estos eventos son devueltos como una lista de objetos Event. Todos los objetos Event tienen un atributo llamado type que nos dice de qué tipo de evento se trata. (En este capítulo sólo describiremos al tipo de evento QUIT. Los otros tipos de eventos serán cubiertos en el próximo capítulo.)

La línea 60 tiene un bucle for que itera sobre cada objeto Event en la lista devuelta por pygame.event.get(). Si el atributo type es igual a la variable constante QUIT, entonces sabes que el usuario ha cerrado la ventana y quiere terminar el programa.

Pygame genera el evento QUIT (el cual es importado del módulo pygame.locals module) cuando el usuario hace clic en el botón cerrar (usualmente una x) de la ventana del programa. También se genera si la computadora está apagándose e intenta terminar todos los programas en ejecución. Sin importar la razón por la que se haya generado el evento QUIT, deberíamos terminar el programa.

La Función pygame.quit()

62.             pygame.quit()
63.             sys.exit()

Si el evento QUIT se ha generado, el programa debe llamar a ambas funciones pygame.quit() y sys.exit().

Este ha sido el simple programa “¡Hola mundo!” de Pygame. Hemos cubierto muchos nuevos temas con los que no habíamos tenido que lidiar en nuestros juegos anteriores. A pesar de que el código es más complicado, los programas Pygame pueden ser mucho más divertidos que los juegos de consola de texto. Aprendamos a continuación cómo crear juegos con gráficos animados que se mueven.

Animación

En este programa tenemos varios bloques diferentes rebotando contra los bordes de la ventana. Los bloques son de diferentes colores y tamaños, y se mueven sólo en trayectorias diagonales. Para animar los bloques (es decir, hacer que parezca que se están moviendo) desplazaremos los bloques unos pocos píxeles en cada iteración del bucle del juego. Esto hará parecer que los bloques se están moviendo alrededor de la pantalla.

Código Fuente del Programa Animación

Type the following program into the file editor and save it as animation.py. If you get errors after typing this code in, compare the code you typed to the book’s code with the online diff tool at http://invpy.com/diff/animation.

animación.py

 1. import pygame, sys, time
 2. from pygame.locals import *
 3. 
 4. # Establece pygame
 5. pygame.init()
 6. 
 7. # Establece la ventana
 8. ANCHOVENTANA = 400
 9. ALTOVENTANA = 400
10. windowSurface = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA), 0, 32)
11. pygame.display.set_caption('Animación')
12. 
13. # Establece las variables de dirección
14. ABAJOIZQUIERDA = 1
15. ABAJODERECHA = 3
16. ARRIBAIZQUIERDA = 7
17. ARRIBADERECHA = 9
18. 
19. VELOCIDADMOVIMIENTO = 4
20. 
21. # Establece los colores
22. NEGRO = (0, 0, 0)
23. ROJO = (255, 0, 0)
24. VERDE = (0, 255, 0)
25. AZUL = (0, 0, 255)
26. 
27. # Establece la estructura de datos de los bloques.
28. b1 = {'rect':pygame.Rect(300, 80, 50, 100), 'color':ROJO, 'dir':ARRIBADERECHA}
29. b2 = {'rect':pygame.Rect(200, 200, 20, 20), 'color':VERDE, 'dir':ARRIBAIZQUIERDA}
30. b3 = {'rect':pygame.Rect(100, 150, 60, 60), 'color':AZUL, 'dir':ABAJOIZQUIERDA}
31. bloques = [b1, b2, b3]
32. 
33. # Corre el ciclo de juego
34. while True:
35.     # Busca un evento QUIT.
36.     for evento in pygame.event.get():
37.         if evento.type == QUIT:
38.             pygame.quit()
39.             sys.exit()
40. 
41.     # Dibuja el fondo negro sobre la superficie
42.     windowSurface.fill(NEGRO)
43. 
44.     for b in bloques:
45.         # mueve la estructura de datos de bloques
46.         if b['dir'] == ABAJOIZQUIERDA:
47.             b['rect'].left -= VELOCIDADMOVIMIENTO
48.             b['rect'].top += VELOCIDADMOVIMIENTO
49.         if b['dir'] == ABAJODERECHA:
50.             b['rect'].left += VELOCIDADMOVIMIENTO
51.             b['rect'].top += VELOCIDADMOVIMIENTO
52.         if b['dir'] == ARRIBAIZQUIERDA:
53.             b['rect'].left -= VELOCIDADMOVIMIENTO
54.             b['rect'].top -= VELOCIDADMOVIMIENTO
55.         if b['dir'] == ARRIBADERECHA:
56.             b['rect'].left += VELOCIDADMOVIMIENTO
57.             b['rect'].top -= VELOCIDADMOVIMIENTO
58. 
59.         # Verifica si el bloque se movió fuera de la ventana
60.         if b['rect'].top < 0:
61.             # el bloque se movió por arriba de la ventana
62.             if b['dir'] == ARRIBAIZQUIERDA:
63.                 b['dir'] = ABAJOIZQUIERDA
64.             if b['dir'] == ARRIBADERECHA:
65.                 b['dir'] = ABAJODERECHA
66.         if b['rect'].bottom > ALTOVENTANA:
67.             # el bloque se movió por debajo de la ventana
68.             if b['dir'] == ABAJOIZQUIERDA:
69.                 b['dir'] = ARRIBAIZQUIERDA
70.             if b['dir'] == ABAJODERECHA:
71.                 b['dir'] = ARRIBADERECHA
72.         if b['rect'].left < 0:
73.             # el bloque se movió por la izquierda de la ventana
74.             if b['dir'] == ABAJOIZQUIERDA:
75.                 b['dir'] = ABAJODERECHA
76.             if b['dir'] == ARRIBAIZQUIERDA:
77.                 b['dir'] = ARRIBADERECHA
78.         if b['rect'].right > ANCHOVENTANA:
79.             # el bloque se movió por la derecha de la ventana
80.             if b['dir'] == ABAJODERECHA:
81.                 b['dir'] = ABAJOIZQUIERDA
82.             if b['dir'] == ARRIBADERECHA:
83.                 b['dir'] = ARRIBAIZQUIERDA
84. 
85.         # Dibuja el bloque en la superficie
86.         pygame.draw.rect(windowSurface, b['color'], b['rect'])
87. 
88.     # Dibuja la ventana en la pantalla
89.     pygame.display.update()
90.     time.sleep(0.02)

Figura 17-6: Una captura de pantalla alterada del programa Animación.

Cómo Funciona el Programa Animación

En este programa veremos tres bloques de diferentes colores moviéndose y rebotando contra las paredes. Para hacer esto, primero necesitamos considerar cómo queremos que los bloques se muevan.

Moving and Bouncing the Blocks

Each block will move in one of four diagonal directions. When the block hits the side of the window, it should bounce off the side and move in a new diagonal direction. The blocks will bounce as shown Figure 17-7.

The new direction that a block moves after it bounces depends on two things: which direction it was moving before the bounce and which wall it bounced off of. There are a total of eight possible ways a block can bounce: two different ways for each of the four walls.

For example, if a block is moving down and right, and then bounces off of the bottom edge of the window, we want the block’s new direction to be up and right.

We can represent the blocks with a Rect object to represent the position and size of the block, a tuple of three integers to represent the color of the block, and an integer to represent which of the four diagonal directions the block is currently moving.

On each iteration in the game loop, adjust the X and Y position of the block in the Rect object. Also, in each iteration draw all the blocks on the screen at their current position. As the program execution iterates over the game loop, the blocks will gradually move across the screen so that it looks like they are smoothly moving and bouncing around on their own.

Figure 17-7: The diagram of how blocks will bounce.

Creating and Setting Up Pygame and the Main Window

 1. import pygame, sys, time
 2. from pygame.locals import *
 3. 
 4. # Establece pygame
 5. pygame.init()
 6. 
 7. # Establece la ventana
 8. ANCHOVENTANA = 400
 9. ALTOVENTANA = 400
10. windowSurface = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA), 0, 32)

In this program, you’ll see that the size of the window’s width and height is used for more than just the call to set_mode(). Use constant variables so that if you ever want to change the size of the window, you only have to change lines 8 and 9. Since the window width and height never change during the program’s execution, a constant variable is a good idea.

11. pygame.display.set_caption('Animación')

Line 11 sets the window’s caption to 'Animation' by calling pygame.display.set_caption().

Setting Up Constant Variables for Direction

13. # Establece las variables de dirección
14. ABAJOIZQUIERDA = 1
15. ABAJODERECHA = 3
16. ARRIBAIZQUIERDA = 7
17. ARRIBADERECHA = 9

We will use the keys on the number pad of the keyboard to remind us which belongs to which direction. This is similar to the Tic Tac Toe game. 1 is down and left, 3 is down and right, 7 is up and left, and 9 is up and right. However, it may be hard to remember this, so instead use constant variables instead of these integer values.

You could have used any value you wanted for these directions instead of using a constant variable. For example, you could use the string 'downleft' to represent the down and left diagonal direction. However, if you ever mistype the 'downleft' string (for example, as 'fownleft'), Python would not recognize that you meant to type 'downleft' instead of 'downleft'. This bug would cause your program to behave strangely, but the program would not crash.

But if you use constant variables, and accidentally type the variable name FOWNLEFT instead of the name DOWNLEFT, Python would notice that there’s no such variable named FOWNLEFT and crash the program with an error. This would still be a pretty bad bug, but at least you would know about it immediately and could fix it.

19. VELOCIDADMOVIMIENTO = 4

Use a constant variable to determine how fast the blocks should move. A value of 4 here means that each block will move 4 pixels on each iteration through the game loop.

Setting Up Constant Variables for Color

21. # Establece los colores
22. NEGRO = (0, 0, 0)
23. ROJO = (255, 0, 0)
24. VERDE = (0, 255, 0)
25. AZUL = (0, 0, 255)

Lines 22 to 25 set up constant variables for the colors. Remember, Pygame uses a tuple of three integer values for the amounts of red, green, and blue called an RGB value. The integers are from 0 to 255.

The use of constant variables is for readability. The computer doesn’t care if you use a variable named GREEN for the color green. It is easier to know that GREEN stands for the color green, rather than (0, 255, 0).

Setting Up The Block Data Structures

27. # Establece la estructura de datos de los bloques.
28. b1 = {'rect':pygame.Rect(300, 80, 50, 100), 'color':ROJO, 'dir':ARRIBADERECHA}

Set up a dictionary as a data structure that represents each block. (Chapter 9½ introduced dictionaries.) The dictionary will have the keys of 'rect' (with a Rect object for a value), 'color' (with a tuple of three integers for a value), and 'dir' (with one of the direction constant variables for a value).

The variable b1 will store one of these block data structures. This block has its top left corner located at an X-coordinate of 300 and Y-coordinate of 80. It has a width of 50 pixels and a height of 100 pixels. Its color is red and its direction is set to UPRIGHT.

29. b2 = {'rect':pygame.Rect(200, 200, 20, 20), 'color':VERDE, 'dir':ARRIBAIZQUIERDA}
30. b3 = {'rect':pygame.Rect(100, 150, 60, 60), 'color':AZUL, 'dir':ABAJOIZQUIERDA}

Line 29 and 30 creates two more similar data structures for blocks that are different sizes, positions, colors, and directions.

31. bloques = [b1, b2, b3]

Line 31 put all of these data structures in a list, and store the list in a variable named blocks.

The blocks variable stores a list. blocks[0] would be the dictionary data structure in b1. blocks[0]['color'] would be the 'color' key in b1, so the expression blocks[0]['color'] would evaluate to (255, 0, 0). This way you can refer to any of the values in any of the block data structures by starting with blocks.

Running the Game Loop

33. # Corre el ciclo de juego
34. while True:
35.     # Busca un evento QUIT.
36.     for evento in pygame.event.get():
37.         if evento.type == QUIT:
38.             pygame.quit()
39.             sys.exit()

Inside the game loop, the blocks will move around the screen in the direction that they are going and bounce if they have hit a side. There is also code to draw all of the blocks to the superficieVentana surface and call pygame.display.update().

The for loop to check all of the events in the list returned by pygame.event.get() is the same as in our “Hello World!” program.

41.     # Dibuja el fondo negro sobre la superficie
42.     windowSurface.fill(NEGRO)

First, line 42 fills the entire surface with black so that anything previously drawn on the surface is erased.

Moving Each Block

44.     for b in bloques:

Next, the code must update the position of each block, so iterate over the blocks list. Inside the loop, you’ll refer to the current block as simply b so it will be easy to type.

45.         # mueve la estructura de datos de bloques
46.         if b['dir'] == ABAJOIZQUIERDA:
47.             b['rect'].left -= VELOCIDADMOVIMIENTO
48.             b['rect'].top += VELOCIDADMOVIMIENTO
49.         if b['dir'] == ABAJODERECHA:
50.             b['rect'].left += VELOCIDADMOVIMIENTO
51.             b['rect'].top += VELOCIDADMOVIMIENTO
52.         if b['dir'] == ARRIBAIZQUIERDA:
53.             b['rect'].left -= VELOCIDADMOVIMIENTO
54.             b['rect'].top -= VELOCIDADMOVIMIENTO
55.         if b['dir'] == ARRIBADERECHA:
56.             b['rect'].left += VELOCIDADMOVIMIENTO
57.             b['rect'].top -= VELOCIDADMOVIMIENTO

The new value to set the left and top attributes to depends on the block’s direction. If the direction of the block (which is stored in the 'dir' key) is either DOWNLEFT or DOWNRIGHT, you want to increase the top attribute. If the direction is UPLEFT or UPRIGHT, you want to decrease the top attribute.

If the direction of the block is DOWNRIGHT or UPRIGHT, you want to increase the left attribute. If the direction is DOWNLEFT or UPLEFT, you want to decrease the left attribute.

Change the value of these attributes by the integer stored in MOVESPEED. MOVESPEED stores how many pixels over blocks move on each iteration of the game loop, and was set on line19.

Checking if the Block has Bounced

59.         # Verifica si el bloque se movió fuera de la ventana
60.         if b['rect'].top < 0:
61.             # el bloque se movió por arriba de la ventana
62.             if b['dir'] == ARRIBAIZQUIERDA:
63.                 b['dir'] = ABAJOIZQUIERDA
64.             if b['dir'] == ARRIBADERECHA:
65.                 b['dir'] = ABAJODERECHA

After lines 44 to 57 move the block, check if the block has gone past the edge of the window. If it has, you want to “bounce” the block. In the code this means set a new value for the block’s 'dir' key. The block will move in the new direction on the next iteration of the game loop. This makes it look like the block has bounced off the side of the window.

On line 60’s if statement, the block has moved past the top edge of the window if the block’s Rect object’s top attribute is less than 0. In that case, change the direction based on what direction the block was moving (either UPLEFT or UPRIGHT).

Changing the Direction of the Bouncing Block

Look at the bouncing diagram earlier in this chapter. To move past the top edge of the window, the block had to either be moving in the UPLEFT or UPRIGHT directions. If the block was moving in the UPLEFT direction, the new direction (according to the bounce diagram) will be DOWNLEFT. If the block was moving in the UPRIGHT direction, the new direction will be DOWNRIGHT.

66.         if b['rect'].bottom > ALTOVENTANA:
67.             # el bloque se movió por debajo de la ventana
68.             if b['dir'] == ABAJOIZQUIERDA:
69.                 b['dir'] = ARRIBAIZQUIERDA
70.             if b['dir'] == ABAJODERECHA:
71.                 b['dir'] = ARRIBADERECHA

Lines 66 to 71 handles if the block has moved past the bottom edge of the window. They check if the bottom attribute (not the top attribute) is greater than the value in WINDOWHEIGHT. Remember that the Y-coordinates start at 0 at the top of the window and increase to WINDOWHEIGHT at the bottom.

The rest of the code changes the direction based on what the bounce diagram in Figure 17-7 says.

72.         if b['rect'].left < 0:
73.             # el bloque se movió por la izquierda de la ventana
74.             if b['dir'] == ABAJOIZQUIERDA:
75.                 b['dir'] = ABAJODERECHA
76.             if b['dir'] == ARRIBAIZQUIERDA:
77.                 b['dir'] = ARRIBADERECHA
78.         if b['rect'].right > ANCHOVENTANA:
79.             # el bloque se movió por la derecha de la ventana
80.             if b['dir'] == ABAJODERECHA:
81.                 b['dir'] = ABAJOIZQUIERDA
82.             if b['dir'] == ARRIBADERECHA:
83.                 b['dir'] = ARRIBAIZQUIERDA

Lines 78 to 83 are similar to lines 72 to 77, but checks if the left side of the block has moved to the left of the left edge of the window. Remember, the X-coordinates start at 0 on the left edge of the window and increase to WINDOWWIDTH on the right edge of the window.

Drawing the Blocks on the Window in Their New Positions

85.         # Dibuja el bloque en la superficie
86.         pygame.draw.rect(windowSurface, b['color'], b['rect'])

Now that the blocks have moved, they should be drawn in their new positions on the superficieVentana surface by calling the pygame.draw.rect() function. Pass superficieVentana because it is the Surface object to draw the rectangle on. Pass the b['color'] because it is the color of the rectangle. Pass b['rect'] because it is the Rect object with the position and size of the rectangle to draw.

Line 86 is the last line of the for loop. If you wanted to add new blocks, you only have to modify the blocks list on line 31 and the rest of the code still works.

Drawing the Window on the Screen

88.     # Dibuja la ventana en la pantalla
89.     pygame.display.update()
90.     time.sleep(0.02)

After each of the blocks in the blocks list has been drawn, call pygame.display.update() so that the superficieVentana surface is draw on the screen.

After this line, the execution loops back to the start of the game loop and begin the process all over again. This way, the blocks are constantly moving a little, bouncing off the walls, and being drawn on the screen in their new positions.

The call to the time.sleep() function is there because the computer can move, bounce, and draw the blocks so fast that if the program ran at full speed, all the blocks would look like a blur. (Try commenting out the time.sleep(0.02) line and running the program to see this.)

This call to time.sleep() will stop the program for 0.02 seconds, or 20 milliseconds.

Drawing Trails of Blocks

Comment out line 42 (the superficieVentana.fill(BLACK) line) by adding a # to the front of the line. Now run the program.

Without the call to superficieVentana.fill(BLACK), you don’t black out the entire window before drawing the rectangles in their new position. The trails of rectangles appear because the old rectangles drawn in previous iterations through the game loop aren’t blacked out anymore.

Remember that the blocks are not really moving. On each iteration through the game loop, the code redraws the entire window with new blocks that are located a few pixels over each time.

Summary

This chapter has presented a whole new way of creating computer programs. The previous chapters’ programs would stop and wait for the player to enter text. However, in our animation program, the program is constantly updating the data structures of things without waiting for input from the player.

Remember in our Hangman and Tic Tac Toe games we had data structures that would represent the state of the board, and these data structures would be passed to a drawBoard() function to be displayed on the screen. Our animation program is similar. The blocks variable holds a list of data structures representing blocks to be drawn to the screen, and these are drawn to the screen inside the game loop.

But without calls to input(), how do we get input from the player? In our next chapter, we will cover how programs can know when the player presses keys on the keyboard. We will also learn of a concept called collision detection.
