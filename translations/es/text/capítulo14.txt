    Capítulo 14
    CIFRADO CÉSAR

Temas Tratados En Este Capítulo:

•   Criptografía y cifrados
•   Encriptar y desencriptar
•   Texto cifrado, texto simple, claves y símbolos
•   El Cifrado César
•   Valores ordinales ASCII
•   Las funciones chr() y ord()
•   El método de cadena isalpha()
•   Los métodos de cadena isupper() & islower()
•   Criptoanálisis
•   El método de fuerza bruta

El programa de este capítulo no es realmente un juego, pero es un programa divertido. Este programa traduce texto normal en un código secreto. También puede convertir mensajes en el código secreto a texto normal. Sólo alguien que conozca este código secreto podrá entender nuestros mensajes secretos.

Como este programa manipula texto para convertirlo en mensajes secretos, aprenderás varios nuevos métodos y funciones para manipular cadenas. También aprenderás cómo los programas pueden hacer matemática con cadenas de texto así como lo hacen con números.

Criptografía

La ciencia de escribir códigos secretos se llama criptografía. Por miles de años la criptografía ha permitido crear mensajes secretos que sólo el emisor y el receptor podían entender, incluso en caso de que alguien capturase al mensajero y leyese el mensaje codificado. Los sistemas secretos de codificación se llaman cifrados. El cifrado que usa el programa de este capítulo se llama Cifrado César.

En criptografía, llamamos texto plano al mensaje que queremos codificar. El texto plano podría ser algo como esto:

¡Hola! Las llaves de la casa te esperan escondidas bajo la maceta.

El proceso de convertir el texto plano en el mensaje codificado se llama cifrado o encriptación. El texto cifrado también se llama criptograma. El criptograma da un aspecto de ser letras aleatorias, y no es posible entender el texto plano original simplemente mirando el criptograma. Aquí está el criptograma correspondiente a la encriptación del ejemplo anterior:

¡Yfcr! Crj ccrmvj uv cr trjr kv vjgvire vjtfeuzurj sraf cr drtvkr.

Pero si conoces el sistema de cifrado usado para encriptar el mensaje, puedes desencriptar el criptograma y convertirlo en el texto plano. (Desencriptar es lo opuesto a encriptar.)

Muchos cifrados también usan claves. Las claves son valores secretos que permiten desencriptar los criptogramas que fueron encriptados usando un cifrado específico. Piensa en el cifrado como si fuera la cerradura de una puerta. Sólo puedes abrirla con una llave particular.

Si estás interesado en escribir programas de criptografía, puedes leer mi otro libro, “Hacking Secret Ciphers with Python” ("Descifrando Códigos Secretos con Python"). Es gratis y puedes descargarlo de http://inventwithpython.com/hacking.

El Cifrado César

La clave para el Cifrado César será un número entre 1 y 26. A menos que conozcas la clave (es decir, conozcas el número usado para encriptar el mensaje), no podrás desencriptar el código secreto.

El Cifrado César fue uno de los primeros sistemas de cifrado que se inventaron. Con este cifrado, para encriptar un mensaje se toma cada letra del mismo (en criptografía, estas letras se llaman símbolos porque pueden ser letras, números o cualquier otro signo) y se la reemplaza con una letra "desplazada". Si desplazas la letra A un espacio, obtienes la letra B. Si desplazas la A dos espacios, obtienes la letra C. La Figura 14-1 es una ilustración de letras desplazadas tres espacios.

Figura 14-1: Letras desplazadas tres espacios. Aquí B se transforma en E.

Para obtener cada letra desplazada, dibuja una fila de casilleros con cada letra del alfabeto. Luego dibuja una segunda fila de casilleros debajo de ella, pero comienza un cierto número (este número es la clave) de casilleros hacia la derecha. Luego de la última letra, vuelve a comenzar con la primera. Aquí hay un ejemplo con las letras desplazadas tres espacios.

Figura 14-2: El alfabeto completo desplazado tres espacios.

El número de espacios que te desplazas es la clave en el Cifrado César. El ejemplo anterior muestra las traducciones de cada letra para la clave 3.

Si encriptas el texto plano "Adios" con una clave 3, entonces:

•   La “A” se convierte en “D”.
•   La letra “d” se convierte en “g”.
•   La letra “i” se convierte en “l”.
•   La letra “o” se convierte en “r”.
•   La letra “s” se convierte en “v”.

El criptograma de "Adios" con clave 3 resulta "Dglrv".

Los caracteres que no correspondan a letras no serán alterados. Para desencriptar "Dglrv" con la clave 3, partimos de la fila inferior de casilleros y volvemos hacia arriba:

•   La letra “D” se convierte en “A”.
•   La letra “g” se convierte en “d”.
•   La letra “l” se convierte en “i”.
•   La letra “r” se convierte en “o”.
•   La letra “v” se convierte en “s”.

ASCII, y Usando Números por Letras

¿Cómo implementamos este cambio de letras en un programa? Podemos hacer esto representando cada letra como un número llamado ordinal, y luego sumando o restando a este número para formar un nuevo ordinal (y una nueva letra). ASCII (que se pronuncia "asqui" y corresponde a las siglas en inglés de Código Estándar Americano para el Intercambio de Información) es un código que relaciona cada caracter con un número entre 32 y 126.

Las mayúsculas de la "A" a la "Z" reciben números ASCII entre 65 y 90. Las minúsculas de "a" a "z" reciben los números ASCII entre 97 y 122. Los caracteres numéricos de "0" a "9" reciben números ASCII de 48 a 57. La Tabla 14-1 muestra todos los caracteres y ordinales ASCII.

Las computadoras modernas usan UTF-8 en lugar de ASCII. Pero UTF-8 es compatible con ASCII, de modo que los ordinales UTF-8 para los caracteres ASCII son los mismos que los ordinales ASCII.

Tabla 14-1: La Tabla ASCII
32  (espacio) 48  0   64  @   80  P   96  `   112 p
33  !   49  1   65  A   81  Q   97  a   113 q
34  "   50  2   66  B   82  R   98  b   114 r
35  #   51  3   67  C   83  S   99  c   115 s
36  $   52  4   68  D   84  T   100 d   116 t
37  %   53  5   69  E   85  U   101 e   117 u
38  &   54  6   70  F   86  V   102 f   118 v
39  '   55  7   71  G   87  W   103 g   119 w
40  (   56  8   72  H   88  X   104 h   120 x
41  )   57  9   73  I   89  Y   105 i   121 y
42  *   58  :   74  J   90  Z   106 j   122 z
43  +   59  ;   75  K   91  [   107 k   123 {
44  ,   60  <   76  L   92  \   108 l   124 |
45  -   61  =   77  M   93  ]   109 m   125 }
46  .   62  >   78  N   94  ^   110 n   126 ~
47  /   63  ?   79  O   95  _   111 o

Entonces, si quisieras desplazar la "A" tres espacios, deberías hacer lo siguiente:

•   Convertir “A” en un ordinal (65).
•   Sumar 3 a 65, para obtener 68.
•   Reconvertir el ordinal 68 a la letra correspondiente (“D”).

Las funciones chr() y ord() pueden convertir de ordinales a caracteres y viceversa.

Las Funciones chr() y ord()

La función chr() (se pronuncia "char", abreviatura de "caracter") toma un ordinal entero y devuelve una cadena de un único caracter. La función ord() (abreviatura de "ordinal") toma una cadena de un solo caracter y devuelve su valor ordinal entero. Intenta ingresar lo siguiente en la consola interactiva:

>>> chr(65)
'A'
>>> ord('A')
65
>>> chr(65+8)
'I'
>>> chr(52)
'4'
>>> chr(ord('F'))
'F'
>>> ord(chr(68))
68

En la tercera línea, chr(65+8) se evalúa a chr(73). Si miras la tabla ASCII, puedes ver que 73 es el ordinal para la letra mayúscula "I".

En la quinta línea, chr(ord('F')) se evalúa a chr(70) que a su vez se evalúa a 'F'. Las funciones ord() y chr() son opuestas entre sí.

Prueba de Ejecución de Cifrado César

Aquí hay una prueba de ejecución del programa Cifrado César, encriptando un mensaje:
¿Deseas encriptar o desencriptar un mensaje?
encriptar
Ingresa tu mensaje:
El cielo sobre el puerto era el color del televisor, sintonizando un canal muerto.
Ingresa el número de clave (1-26)
13
Tu texto traducido es:
Ry pvryb fboer ry chregb ren ry pbybe qry gryrivfbe, fvagbavmnaqb ha pnany zhregb.
Ahora ejecuta el programa y desencripta el texto que acabas de encriptar.
¿Deseas encriptar o desencriptar un mensaje?
desencriptar
Ingresa tu mensaje:
Ry pvryb fboer ry chregb ren ry pbybe qry gryrivfbe, fvagbavmnaqb ha pnany zhregb.
Ingresa el número de clave (1-26)
13
Tu texto traducido es:
El cielo sobre el puerto era el color del televisor, sintonizando un canal muerto.
Si no desencriptas con la clave correcta, el texto desencriptado será basura:
¿Deseas encriptar o desencriptar un mensaje?
desencriptar
Ingresa tu mensaje:
Ry pvryb fboer ry chregb ren ry pbybe qry gryrivfbe, fvagbavmnaqb ha pnany zhregb.
Ingresa el número de clave (1-26)
15
Tu texto traducido es:
Cj agcjm qmzpc cj nscprm cpy cj amjmp bcj rcjctgqmp, qglrmlgxylbm sl aylyj kscprm.

Código Fuente de Cifrado César

Aquí está el código fuente para el programa Cifrado César. Luego de escribir este código, guarda el archivo como cifrado.py. Si obtienes errores, compara el código que has escrito con el código fuente del libro usando la herramienta diff online en http://invpy.com/diff/cifrado.

cifrado.py

 1. # Cifrado Cesar
 2. 
 3. TAM_MAX_CLAVE = 26
 4. 
 5. def obtenerModo():
 6.     while True:
 7.         print('¿Deseas encriptar o desencriptar un mensaje?')
 8.         modo = input().lower()
 9.         if modo in 'encriptar e desencriptar d'.split():
10.             return modo
11.         else:
12.             print('Ingresa "encriptar" o "e" o "desencriptar" o "d"')
13. 
14. def obtenerMensaje():
15.     print('Ingresa tu mensaje:')
16.     return input()
17. 
18. def obtenerClave():
19.     clave = 0
20.     while True:
21.         print('Ingresa el número de clave (1-%s)' % (TAM_MAX_CLAVE))
22.         clave = int(input())
23.         if (clave >= 1 and clave <= TAM_MAX_CLAVE):
24.             return clave
25. 
26. def obtenerMensajeTraducido(modo, mensaje, clave):
27.     if modo[0] == 'd':
28.         clave = -clave
29.     traduccion = ''
30. 
31.     for simbolo in mensaje:
32.         if simbolo.isalpha():
33.             num = ord(simbolo)
34.             num += clave
35. 
36.             if simbolo.isupper():
37.                 if num > ord('Z'):
38.                     num -= 26
39.                 elif num < ord('A'):
40.                     num += 26
41.             elif simbolo.islower():
42.                 if num > ord('z'):
43.                     num -= 26
44.                 elif num < ord('a'):
45.                     num += 26
46. 
47.             traduccion += chr(num)
48.         else:
49.             traduccion += simbolo
50.     return traduccion
51. 
52. modo = obtenerModo()
53. mensaje = obtenerMensaje()
54. clave = obtenerClave()
55. 
56. print('Tu texto traducido es:')
57. print(obtenerMensajeTraducido(modo, mensaje, clave))

Cómo Funciona el Código

Los procesos de encriptación y desencripción son inversos el uno del otro, y aún así utilizan en gran medida el mismo código. Veamos cómo funciona cada línea.

 1. # Cifrado Cesar
 2. 
 3. TAM_MAX_CLAVE = 26

La primera línea es simplemente un comentario. TAM_MAX_CLAVE es una constante que almacena al entero 26. TAM_MAX_CLAVE nos recuerda que en este programa, la clave usada para el cifrado debe estar comprendida entre 1 y 26.

Decidiendo si Encriptar o Desencriptar

 5. def obtenerModo():
 6.     while True:
 7.         print('¿Deseas encriptar o desencriptar un mensaje?')
 8.         modo = input().lower()
 9.         if modo in 'encriptar e desencriptar d'.split():
10.             return modo
11.         else:
12.             print('Ingresa "encriptar" o "e" o "desencriptar" o "d"')

La función obtenerModo() permite al usuario elegir si quieren entrar al modo de cifrado o descifrado del programa. El valor devuelto de input() y lower() se almacena en modo. La condición de la sentencia if comprueba si la cadena almacenada en modo existe en la lista devuelta por 'encriptar e desencriptar d'.split().

Esta lista es ['encriptar', 'e', 'desencriptar', 'd'], pero es más fácil para el programador escribir 'encriptar e desencriptar d'.split() y no tener que escribir todas esas comas y comillas. Usa la forma que sea más fácil para tí; ambas son evaluadas al mismo valor de lista.

Esta función devolverá la cadena en modo siempre que modo sea igual a 'encriptar', 'e', 'desencriptar' o 'd'. Entonces, obtenerModo() devolverá la cadena 'e' o la cadena 'd' (pero el usuario puede escribir "e", "encriptar", "d" o "desencriptar".)

Obteniendo el Mensaje del Jugador

14. def obtenerMensaje():
15.     print('Ingresa tu mensaje:')
16.     return input()

La función obtenerMensaje simplemente obtiene el mensaje a encriptar o desencriptar del usuario y devuelve este valor.

Obteniendo la Clave del Jugador

18. def obtenerClave():
19.     clave = 0
20.     while True:
21.         print('Ingresa el número de clave (1-%s)' % (TAM_MAX_CLAVE))
22.         clave = int(input())
23.         if (clave >= 1 and clave <= TAM_MAX_CLAVE):
24.             return clave

La función obtenerClave permite al jugador escribir la clave que desea usar para encriptar o desencriptar el mensaje. El bucle while asegura que la función se mantenga ciclando hasta que el usuario ingrese una clave válida.

Una clave válida es aquella que está comprendida entre los valores enteros 1 y 26 (recuerda que TAM_MAX_CLAVE tendrá siempre el valor 26 porque es constante). La función devuelve entonces esta clave. La línea 22 establece la clave como la versión entera de lo que el jugador haya escrito, de modo que obtenerClave() devuelve un entero.

Encriptar o Desencriptar el Mensaje con la Clave Dada

26. def obtenerMensajeTraducido(modo, mensaje, clave):
27.     if modo[0] == 'd':
28.         clave = -clave
29.     traduccion = ''

obtenerMensajeTraducido() realiza la encriptación y desencriptación. Tiene tres parámetros:

•   modo elige entre los modos de encriptación y desencriptación.
•   mensaje es el texto plano (o criptograma) a encriptar (o desencriptar).
•   clave es la clave numérica a usar para este cifrado.

La línea 27 comprueba si la primera letra en la variable modo es la cadena 'd'. En ese caso, el programa entra en modo de desencriptación. La única diferencia entre los modos de desencriptación y encriptación es que para desencriptar un mensaje se usa la versión negativa de la clave. Si clave fuera el entero 22, entonces en modo de desencriptación clave se transforma en -22. Explicaremos la razón de esto más adelante.

traduccion es la cadena que contiene al resultado, es decir, el criptograma (ei estás encriptando) o el texto plano (si estás desencriptando). Comienza como una cadena vacía a cuyo final se van añadiendo caracteres encriptados o desencriptados.

El Método de Cadena isalpha()

El método de cadena isalpha() devolverá True si la cadena es una letra mayúscula o minúscula entre A y Z. Si la cadena contiene algún caracter no alfabético, entonces isalpha() devolverá False. Prueba ingresar lo siguiente en la consola interactiva:

>>> 'Hola'.isalpha()
True
>>> 'Cuarenta y dos'.isalpha()
False
>>> 'Cuarentaydos'.isalpha()
True
>>> '42'.isalpha()
False
>>> ''.isalpha()
False

Como puedes observar, 'Cuarenta y dos'.isalpha() devuelve False porque 'Cuarenta y dos' incluye dos espacios, los cuales son caracteres no alfabéticos. 'Cuarentaydos'.isalpha() devuelve True porque no contiene espacios.

'42'.isalpha() devuelve False porque ni '4' ni '2' son letras. isalpha() sólo devuelve True si la cadena no está vacía y está compuesta únicamente por letras.

El método isalpha() se usa en las siguientes líneas del programa.

31.     for simbolo in mensaje:
32.         if simbolo.isalpha():
33.             num = ord(simbolo)
34.             num += clave

El bucle for de la línea 31 itera sobre cada letra (en criptografía se llaman símbolos) de la cadena del mensaje. En cada iteración sobre este bucle, simbolo tendrá el valor de una letra en el mensaje.

La línea 32 está presente porque sólo las letras serán encriptadas o desencriptadas. Los números, signos de puntuación y todo lo demás conservará su forma original. La variable num almacenará el valor ordinal entero de la letra en la variable simbolo. La línea 34 "desplaza" entonces el valor de num en el número de casilleros correspondiente a la clave.

Los Métodos de Cadena isupper() e islower()

Los métodos de cadena isupper() e islower() (los cuales utilizamos en las líneas 36 y 41) funcionan de forma similar a los métodos isdigit() e isalpha().

isupper() devuelve True si la cadena sobre la cual es llamado contiene al menos una letra mayúscula y ninguna minúscula.
islower() devuelve True si la cadena sobre la cual es llamado contiene al menos una letra minúscula y ninguna mayúscula. De otro modo estos métodos devuelven False.

Prueba ingresar lo siguiente en la consola interactiva:

>>> 'HOLA'.isupper()
True
>>> 'hola'.isupper()
False
>>> 'hola'.islower()
True
>>> 'Hola'.islower()
False
>>> 'CUIDADO DETRAS DE TI!'.isupper()
True
>>> '42'.isupper()
False
>>> '42'.islower()
False
>>> ''.isupper()
False
>>> ''.islower()
False

Encriptando o Desencriptando Cada Letra

36.             if simbolo.isupper():
37.                 if num > ord('Z'):
38.                     num -= 26
39.                 elif num < ord('A'):
40.                     num += 26

La línea 36 comprueba si el símbolo es una letra mayúscula. Si lo es, hay dos casos especiales a tener en cuenta. Qué ocurriría si el símbolo fuese 'Z' y la clave 4? En este caso, el valor de num aquí sería el caracter '^' (El ordinal de '^' es 94). Pero ^ no es ninguna letra. Y nosotros queremos que el criptograma "reinicie la vuelta" por el principio del alfabeto.

Comprobamos si num tiene un valor mayor que el valor ordinal de "Z". Si es así, restamos 26 a num (porque hay 26 letras en total). Luego de hacer esto, el valor de num es 68. 68 es el valor ordinal correcto ya que corresponde a "D".

41.             elif simbolo.islower():
42.                 if num > ord('z'):
43.                     num -= 26
44.                 elif num < ord('a'):
45.                     num += 26

Si el símbolo es una letra minúscula, el programa ejecuta un código que es similar a las líneas 36 a 40. la única diferencia es que utiliza ord('z') y ord('a') en lugar de ord('Z') y ord ('A').

En modo desencriptación, la clave es negativa. El caso especial sería si num -= 26 es menor que el valor ASCII de "a". En ese caso, sumamos 26 a num para que "reinicie la vuelta" por el final del alfabeto.

47.             traduccion += chr(num)
48.         else:
49.             traduccion += simbolo

La línea 47 concatena el caracter encriptado/desencriptado a la cadena traducida.

Si el símbolo no es una letra mayúscula o minúscula, la línea 49 concatena el símbolo original a la cadena traducida. Por lo tanto, espacios, números, signos de puntuación y otros caracteres no serán encriptados o desencriptados.

50.     return traduccion

The last line in the getTranslatedMessage() function returns the translated string.

The Start of the Program

52. modo = obtenerModo()
53. mensaje = obtenerMensaje()
54. clave = obtenerClave()
55. 
56. print('Tu texto traducido es:')

The start of the program calls each of the three functions defined previously to get the mode, message, and key from the user. These three values are passed to getTranslatedMessage() whose return value (the translated string) is printed to the user.

Brute Force

That’s the entire Caesar Cipher. However, while this cipher may fool some people who don’t understand cryptography, it won’t keep a message secret from someone who knows cryptanalysis. While cryptography is the science of making codes, cryptanalysis is the science of breaking codes.

Do you wish to encrypt or decrypt a message?
encrypt
Enter your message:
Doubts may not be pleasant, but certainty is absurd.
Enter the key number (1-26)
8
Your translated text is:
Lwcjba uig vwb jm xtmiaivb, jcb kmzbiqvbg qa ijaczl.
The whole point of cryptography is that so if someone else gets their hands on the encrypted message, they cannot figure out the original unencrypted message from it. Let’s pretend we are the code breaker and all we have is the encrypted text:
Lwcjba uig vwb jm xtmiaivb, jcb kmzbiqvbg qa ijaczl.

Brute force is the technique of trying every possible key until you find the correct one. Because there are only 26 possible keys, it would be easy for a cryptanalyst to write a hacking program than decrypts with every possible key. Then they could look for the key that decrypts to plain English. Let’s add a brute force feature to the program.

Adding the Brute Force Mode

First, change lines 7, 9, and 12 (which are in the getMode() function) to look like the following (the changes are in bold):

 5. def getMode():
 6.     while True:
 7.         print('Do you wish to encrypt or decrypt or brute force a message?')
 8.         mode = input().lower()
 9.         if mode in 'encrypt e decrypt d brute b'.split():
10.             return mode[0]
11.         else:
12.             print('Enter either "encrypt" or "e" or "decrypt" or "d" or "brute" or "b".')

This code will let the user select “brute force” as a mode. Modify and add the following changes to the main part of the program:

52. mode = getMode()
53. message = getMessage()
54. if mode[0] != 'b':
55.     key = getKey()
56.
57. print('Your translated text is:')
58. if mode[0] != 'b':
59.     print(getTranslatedMessage(mode, message, key))
60. else:
61.     for key in range(1, MAX_KEY_SIZE + 1):
62.         print(key, getTranslatedMessage('decrypt', message, key))

These changes ask the user for a key if they are not in “brute force” mode. The original getTranslatedMessage() call is made and the translated string is printed.

However, if the user is in “brute force” mode then getTranslatedMessage() loop that iterates from 1 all the way up to MAX_KEY_SIZE (which is 26). Remember that when the range() function returns a list of integers up to, but not including, the second parameter, which is why you have + 1. This program will print every possible translation of the message (including the key number used in the translation). Here is a sample run of this modified program:

Do you wish to encrypt or decrypt or brute force a message?
brute
Enter your message:
Lwcjba uig vwb jm xtmiaivb, jcb kmzbiqvbg qa ijaczl.
Your translated text is:
1 Kvbiaz thf uva il wslhzhua, iba jlyahpuaf pz hizbyk.
2 Juahzy sge tuz hk vrkgygtz, haz ikxzgotze oy ghyaxj.
3 Itzgyx rfd sty gj uqjfxfsy, gzy hjwyfnsyd nx fgxzwi.
4 Hsyfxw qec rsx fi tpiewerx, fyx givxemrxc mw efwyvh.
5 Grxewv pdb qrw eh sohdvdqw, exw fhuwdlqwb lv devxug.
6 Fqwdvu oca pqv dg rngcucpv, dwv egtvckpva ku cduwtf.
7 Epvcut nbz opu cf qmfbtbou, cvu dfsubjouz jt bctvse.
8 Doubts may not be pleasant, but certainty is absurd.
9 Cntasr lzx mns ad okdzrzms, ats bdqszhmsx hr zartqc.
10 Bmszrq kyw lmr zc njcyqylr, zsr acpryglrw gq yzqspb.
11 Alryqp jxv klq yb mibxpxkq, yrq zboqxfkqv fp xyproa.
12 Zkqxpo iwu jkp xa lhawowjp, xqp yanpwejpu eo wxoqnz.
13 Yjpwon hvt ijo wz kgzvnvio, wpo xzmovdiot dn vwnpmy.
14 Xiovnm gus hin vy jfyumuhn, von wylnuchns cm uvmolx.
15 Whnuml ftr ghm ux iextltgm, unm vxkmtbgmr bl tulnkw.
16 Vgmtlk esq fgl tw hdwsksfl, tml uwjlsaflq ak stkmjv.
17 Uflskj drp efk sv gcvrjrek, slk tvikrzekp zj rsjliu.
18 Tekrji cqo dej ru fbuqiqdj, rkj suhjqydjo yi qrikht.
19 Sdjqih bpn cdi qt eatphpci, qji rtgipxcin xh pqhjgs.
20 Rciphg aom bch ps dzsogobh, pih qsfhowbhm wg opgifr.
21 Qbhogf znl abg or cyrnfnag, ohg pregnvagl vf nofheq.
22 Pagnfe ymk zaf nq bxqmemzf, ngf oqdfmuzfk ue mnegdp.
23 Ozfmed xlj yze mp awpldlye, mfe npceltyej td lmdfco.
24 Nyeldc wki xyd lo zvokckxd, led mobdksxdi sc klcebn.
25 Mxdkcb vjh wxc kn yunjbjwc, kdc lnacjrwch rb jkbdam.
26 Lwcjba uig vwb jm xtmiaivb, jcb kmzbiqvbg qa ijaczl.

After looking over each row, you can see that the 8th message isn’t garbage, but plain English! The cryptanalyst can deduce that the original key for this encrypted text must have been 8. This brute force would have been difficult to do back in the days of Caesars and the Roman Empire, but today we have computers that can quickly go through millions or even billions of keys in a short time.

Summary

Computers are good at doing mathematics. When we create a system to translate some piece of information into numbers (such as we do with text and ordinals or with space and coordinate systems), computer programs can process these numbers quickly and efficiently.

But while our Caesar cipher program here can encrypt messages that will keep them secret from people who have to figure it out with pencil and paper, it won’t keep it secret from people who know how to get computers to process information for them. (Our brute force mode proves this.)

A large part of figuring out how to write a program is figuring out how to represent the information you want to manipulate as values that Python can understand.

The next chapter will present Reversi (also known as Othello). The AI that plays this game will be much more advanced than the AI that played Tic Tac Toe in chapter 9. In fact, the AI is so good most of the time you’ll be unable to beat it!
