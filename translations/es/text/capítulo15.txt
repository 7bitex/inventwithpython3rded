  Capítulo 15
  REVERSI

Temas Tratados En Este Capítulo:
• La Función bool()
• Cómo Jugar a Reversi

En este capítulo, crearemos un juego llamado Reversi (también llamado Othello). Reversi es un juego de mesa que se juega sobre una grilla, de modo que tendremos que usar un sistema de coordenadas Cartesiano con coordenadas XY. Es un juego para dos jugadores. En nuestra versión del juego la computadora tendrá una IA más avanzada que la que hemos creado para el Ta Te Ti. De hecho, esta IA es tan buena que probablemente te gane todas las partidas que juegues. (¡Al menos yo pierdo cada vez que juego contra ella!)

Reversi tiene un tablero de 8 x 8 y baldosas que son negras de un lado y blancas del otro (nuestro juego las reemplazará por O's y X's). El tablero inicial se ve como la Figura 15-1. El jugador negro y el jugador blanco toman turnos para colocar una nueva baldosa de su color. Cualquier baldosa del oponente que se encuentre entre la nueva baldosa y las otras baldosas de ese color es convertida. El objetivo del juego es tener tantas baldosas de tu color como sea posible. Por ejemplo, la Figura 15-2 es como se vería si el jugador blanco colocara una nueva baldosa blanca en el espacio 5, 6.

Figura 15-1: El tablero inicial en Reversi tiene dos baldosas blancas y dos negras.  Figura 15-2: El jugador blanco coloca una nueva baldosa.

La baldosa negra en 5, 5 está entre la nueva baldosa blanca y la baldosa blanca existente en 5, 4. Esa baldosa blanca es volteada y se convierte en una nueva baldosa blanca, haciendo que el tablero se vea como en la Figura 15-3. El jugador negro hace a continuación una movida similar, colocando una baldosa negra en 4, 6 la cual voltea la baldosa blanca en 4, 5. Esto resulta en una disposición del tablero como se muestra en la Figura 15-4.

Figura 15-3: La movida del jugador blanco convierte una de las baldosas negras.  Figura 15-4: El jugador negro coloca una nueva baldosa, la cual convierte una de las baldosas blancas.

Las baldosas en todas las direcciones son convertidas en tanto se encuentren entre la nueva baldosa del jugador y sus baldosas existentes. En la Figura 15-5, el jugador blanco coloca una baldosa en 3, 6 y convierte baldosas en ambas direcciones (indicadas por las líneas). El resultado se muestra en la Figura 15-6.

Figura 15-5: La segunda movida del jugador blanco en 3, 6 convertirá dos baldosas negras.  Figura 15-6: El tablero luego de la segunda movida del jugador blanco.

Cada jugador puede rápidamente convertir muchas baldosas en el tablero en uno o dos movimientos. Los jugadores deben hacer siempre jugadas que capturen al menos una baldosa. El juego termina cuando ningún jugador puede seguir moviendo, o el tablero está completamente lleno. Gana el jugador con más baldosas de su color.

La IA que crearemos para este juego simplemente intentará jugar en las esquinas. Si no es posible jugar en una esquina, la computadora seleccionará la jugada que convierta más baldosas.

Prueba de Ejecución de Reversi

¡Bienvenido a Reversi!
¿Deseas ser X ó O?
x
El jugador comenzará.
    1   2   3   4   5   6   7   8
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
1 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
2 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
3 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
4 |   |   |   | X | O |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
5 |   |   |   | O | X |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
6 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
7 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
8 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
Tienes 2 puntos. La computadora tiene 2 puntos.
Ingresa tu jugada, salir para terminar el juego, o pistas para activar/desactivar las pistas.
53
    1   2   3   4   5   6   7   8
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
1 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
2 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
3 |   |   |   |   | X |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
4 |   |   |   | X | X |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
5 |   |   |   | O | X |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
6 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
7 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
8 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
Tienes 4 puntos. La computadora tiene 1 puntos.
Presiona enter para ver la jugada de la computadora.

...omitido por brevedad...

    1   2   3   4   5   6   7   8
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
1 | O | O | O | O | O | O | O | O |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
2 | O | O | O | O | O | O | O | O |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
3 | O | O | O | O | O | O | O | O |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
4 | O | O | X | O | O | O | O | O |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
5 | O | O | O | X | O | X | O | X |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
6 | O | X | O | X | X | O | O |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
7 | O | X | X | O | O | O | O | O |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
8 | O | X | X | O |   |   | X |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
Tienes 12 puntos. La computadora tiene 48 puntos.
Ingresa tu jugada, salir para terminar el juego, o pistas para activar/desactivar las pistas.
86
X ha obtenido 15 puntos. O ha obtenido 46 puntos.
Has perdido. La computadora te ha vencido por 31 puntos.
¿Quieres jugar de nuevo? (sí o no)
no

Como puedes ver, la IA hizo un buen trabajo y me venció 46 a 15. Para ayudar al jugador, programaremos el juego de modo que ofrezca pistas. Si el jugador escribe 'pistas' como su jugada, se activarán o desactivarán las pistas. Cuando el modo pistas está activado, se verán marcas '.' en el tablero para todas las jugadas posibles, como se muestra a continuación: 

    1   2   3   4   5   6   7   8
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
1 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
2 |   |   |   | . |   | . |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
3 |   |   |   | O | O | O |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
4 |   |   | . | O | O | X |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
5 |   |   | . | O | O | O | X |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
6 |   |   |   | . |   | . |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
7 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
  |   |   |   |   |   |   |   |   |
8 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+

Código Fuente de Reversi

Reversi es un programa mamut comparado con nuestros juegos anteriores. ¡Tiene más de 300 líneas! Pero no te preocupes, muchas de estas líneas son comentarios o líneas en blanco para separar el código y hacerlo más legible.

Como hemos hecho con los otros programas, primero crearemos varias funciones para llevar a cabo tareas relacionadas con Reversi que serán llamadas por la sección principal. Aproximadamente las primeras 250 líneas de código son para estas funciones auxiliares, y las últimas 50 líneas de código implementan el juego Reversi en sí.

Si obtienes errores luego de escribir este código, compara el código que has escrito con el código del libro usando la herramienta diff online en http://invpy.com/diff/reversi.

reversi.py

  1. # Reversi
  2. 
  3. import random
  4. import sys
  5. 
  6. def dibujarTablero(tablero):
  7.     # Esta funcion dibuja el tablero recibido. Devuelve None
  8.     LÍNEAH = '  +---+---+---+---+---+---+---+---+'
  9.     LÍNEAV = '  |   |   |   |   |   |   |   |   |'
 10. 
 11.     print('    1   2   3   4   5   6   7   8')
 12.     print(LÍNEAH)
 13.     for y in range(8):
 14.         print(LÍNEAV)
 15.         print(y+1, end=' ')
 16.         for x in range(8):
 17.             print('| %s' % (tablero[x][y]), end=' ')
 18.         print('|')
 19.         print(LÍNEAV)
 20.         print(LÍNEAH)
 21. 
 22. 
 23. def reiniciarTablero(tablero):
 24.     # Deja en blanco el tablero recibido como argumento, excepto la posición inicial
 25.     for x in range(8):
 26.         for y in range(8):
 27.             tablero[x][y] = ' '
 28. 
 29.     # Piezas iniciales:
 30.     tablero[3][3] = 'X'
 31.     tablero[3][4] = 'O'
 32.     tablero[4][3] = 'O'
 33.     tablero[4][4] = 'X'
 34. 
 35. 
 36. def obtenerNuevoTablero():
 37.     # Crea un tablero nuevo, vacío.
 38.     tablero = []
 39.     for i in range(8):
 40.         tablero.append([' '] * 8)
 41. 
 42.     return tablero
 43. 
 44. 
 45. def esJugadaVálida(tablero, baldosa, comienzox, comienzoy):
 46.     # Devuelve False si la jugada del jugador en comienzox, comienzoy es invalida
 47.     # Si es una jugada válida, devuelve una lista de espacios que pasarían a ser del jugador si moviera aquí.
 48.     if tablero[comienzox][comienzoy] != ' ' or not estáEnTablero(comienzox, comienzoy):
 49.         return False
 50. 
 51.     tablero[comienzox][comienzoy] = baldosa # coloca temporariamente la baldosa sobre el tablero.
 52. 
 53.     if baldosa == 'X':
 54.         otraBaldosa = 'O'
 55.     else:
 56.         otraBaldosa = 'X'
 57. 
 58.     baldosasAConvertir = []
 59.     for direcciónx, direccióny in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
 60.         x, y = comienzox, comienzoy
 61.         x += direcciónx # primer paso en la dirección
 62.         y += direccióny # primer paso en la dirección
 63.         if estáEnTablero(x, y) and tablero[x][y] == otraBaldosa:
 64.             # Hay una pieza perteneciente al otro jugador al lado de nustra pieza
 65.             x += direcciónx
 66.             y += direccióny
 67.             if not estáEnTablero(x, y):
 68.                 continue
 69.             while tablero[x][y] == otraBaldosa:
 70.                 x += direcciónx
 71.                 y += direccióny
 72.                 if not estáEnTablero(x, y): # sale del bucle while y continua en el bucle for.
 73.                     break
 74.             if not estáEnTablero(x, y):
 75.                 continue
 76.             if tablero[x][y] == baldosa:
 77.                 # Hay fichas a convertir. Caminar en dirección opuesta hasta llegar al casillero original, registrando todas las posiciones en el camino.
 78.                 while True:
 79.                     x -= direcciónx
 80.                     y -= direccióny
 81.                     if x == comienzox and y == comienzoy:
 82.                         break
 83.                     baldosasAConvertir.append([x, y])
 84. 
 85.     tablero[comienzox][comienzoy] = ' ' # restablecer el espacio vacío
 86.     if len(baldosasAConvertir) == 0: # Si no se convirtió ninguna baldosa, la jugada no es válida.
 87.         return False
 88.     return baldosasAConvertir
 89. 
 90. 
 91. def estáEnTablero(x, y):
 92.     # Devuelve True si las coordenadas se encuentran dentro del tablero
 93.     return x >= 0 and x <= 7 and y >= 0 and y <=7
 94. 
 95. 
 96. def obtenerTableroConJugadasVálidas(tablero, baldosa):
 97.     # Devuelve un nuevo tablero, marcando con "." las jugadas válidas que el jugador puede realizar.
 98.     réplicaTablero = obtenerCopiaTablero(tablero)
 99. 
100.     for x, y in obtenerJugadasVálidas(réplicaTablero, baldosa):
101.         réplicaTablero[x][y] = '.'
102.     return réplicaTablero
103. 
104. 
105. def obtenerJugadasVálidas(tablero, baldosa):
106.     # Devuelve una lista de listas [x,y] de jugadas válidas para el jugador en el tablero dado.
107.     jugadasVálidas = []
108. 
109.     for x in range(8):
110.         for y in range(8):
111.             if esJugadaVálida(tablero, baldosa, x, y) != False:
112.                 jugadasVálidas.append([x, y])
113.     return jugadasVálidas
114. 
115. 
116. def obtenerPuntajeTablero(tablero):
117.     # Determina el puntaje contando las piezas. Devuelve un diccionario con claves 'X' y 'O'.
118.     puntajex = 0
119.     puntajeo = 0
120.     for x in range(8):
121.         for y in range(8):
122.             if tablero[x][y] == 'X':
123.                 puntajex += 1
124.             if tablero[x][y] == 'O':
125.                 puntajeo += 1
126.     return {'X':puntajex, 'O':puntajeo}
127. 
128. 
129. def ingresarBaldosaJugador():
130.     # Permite al jugador elegir que baldosa desea ser.
131.     # Devuelve una lista con la baldosa del jugador como primer elemento y el de la computadora como segundo.
132.     baldosa = ''
133.     while not (baldosa == 'X' or baldosa == 'O'):
134.         print('¿Deseas ser X ó O?')
135.         baldosa = input().upper()
136. 
137.     #  El primer elemento en la lista es la baldosa del juegador, el segundo es la de la computadora.
138.     if baldosa == 'X':
139.         return ['X', 'O']
140.     else:
141.         return ['O', 'X']
142. 
143. 
144. def quiénComienza():
145.     # Elije al azar qué jugador comienza.
146.     if random.randint(0, 1) == 0:
147.         return 'computadora'
148.     else:
149.         return 'jugador'
150. 
151. 
152. def jugarDeNuevo():
153.     # Esta función devuelve True si el jugador quiere jugar de nuevo, de lo contrario devuelve False.
154.     print('¿Quieres jugar de nuevo? (sí o no)')
155.     return input().lower().startswith('s')
156. 
157. 
158. def hacerJugada(tablero, baldosa, comienzox, comienzoy):
159.     # Coloca la baldosa sobre el tablero en comienzox, comienzoy, y convierte cualquier baldosa del oponente.
160.     # Devuelve False si la jugada es inválida, True si es válida.
161.     baldosasAConvertir = esJugadaVálida(tablero, baldosa, comienzox, comienzoy)
162. 
163.     if baldosasAConvertir == False:
164.         return False
165. 
166.     tablero[comienzox][comienzoy] = baldosa
167.     for x, y in baldosasAConvertir:
168.         tablero[x][y] = baldosa
169.     return True
170. 
171. 
172. def obtenerCopiaTablero(tablero):
173.     # Duplica la lista del tablero y devuelve el duplicado.
174.     réplicaTablero = obtenerNuevoTablero()
175. 
176.     for x in range(8):
177.         for y in range(8):
178.             réplicaTablero[x][y] = tablero[x][y]
179. 
180.     return réplicaTablero
181. 
182. 
183. def esEsquina(x, y):
184.     # Devuelve True si la posicion es una de las esquinas.
185.     return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)
186. 
187. 
188. def obtenerJugadaJugador(tablero, baldosaJugador):
189.     # Permite al jugador tipear su jugada.
190.     # Devuelve la jugada como [x, y] (o devuelve las cadenas 'pistas' o 'salir')
191.     CIFRAS1A8 = '1 2 3 4 5 6 7 8'.split()
192.     while True:
193.         print('Ingresa tu jugada, salir para terminar el juego, o pistas para activar/desactivar las pistas.')
194.         jugada = input().lower()
195.         if jugada == 'salir':
196.             return 'salir'
197.         if jugada == 'pistas':
198.             return 'pistas'
199. 
200.         if len(jugada) == 2 and jugada[0] in CIFRAS1A8 and jugada[1] in CIFRAS1A8:
201.             x = int(jugada[0]) - 1
202.             y = int(jugada[1]) - 1
203.             if esJugadaVálida(tablero, baldosaJugador, x, y) == False:
204.                 continue
205.             else:
206.                 break
207.         else:
208.             print('Esta no es una jugada válida. Ingresa la coordenada x (1-8), luego la coordenada y (1-8).')
209.             print('Por ejemplo, 81 corresponde a la esquina superior derecha.')
210. 
211.     return [x, y]
212. 
213. 
214. def obtenerJugadaComputadora(tablero, baldosaComputadora):
215.     # Dado un tablero y la baldosa de la computadora, determinar dónde
216.     # jugar y devolver esa jugada como una lista [x, y].
217.     jugadasPosibles = obtenerJugadasVálidas(tablero, baldosaComputadora)
218. 
219.     # ordena al azar el orden de las jugadas posibles
220.     random.shuffle(jugadasPosibles)
221. 
222.     # siempre jugar en una esquina si está disponible.
223.     for x, y in jugadasPosibles:
224.         if esEsquina(x, y):
225.             return [x, y]
226. 
227.     # Recorrer la lista de jugadas posibles y recordar la que da el mejor puntaje
228.     mejorPuntaje = -1
229.     for x, y in jugadasPosibles:
230.         réplicaTablero = obtenerCopiaTablero(tablero)
231.         hacerJugada(réplicaTablero, baldosaComputadora, x, y)
232.         puntaje = obtenerPuntajeTablero(réplicaTablero)[baldosaComputadora]
233.         if puntaje > mejorPuntaje:
234.             mejorJugada = [x, y]
235.             mejorPuntaje = puntaje
236.     return mejorJugada
237. 
238. 
239. def mostrarPuntajes(baldosaJugador, baldosaComputadora):
240.     # Imprime el puntaje actual.
241.     puntajes = obtenerPuntajeTablero(tableroPrincipal)
242.     print('Tienes %s puntos. La computadora tiene %s puntos.' % (puntajes[baldosaJugador], puntajes[baldosaComputadora]))
243. 
244. 
245. 
246. print('¡Bienvenido a Reversi!')
247. 
248. while True:
249.     # Reiniciar el tablero y el juego.
250.     tableroPrincipal = obtenerNuevoTablero()
251.     reiniciarTablero(tableroPrincipal)
252.     baldosaJugador, baldosaComputadora = ingresarBaldosaJugador()
253.     mostrarPistas = False
254.     turno = quiénComienza()
255.     print(("El " if turno == "jugador" else "La ") + turno + ' comenzará.')
256. 
257.     while True:
258.         if turno == 'jugador':
259.             # Turno del jugador
260.             if mostrarPistas:
261.                 tableroConJugadasVálidas = obtenerTableroConJugadasVálidas(tableroPrincipal, baldosaJugador)
262.                 dibujarTablero(tableroConJugadasVálidas)
263.             else:
264.                 dibujarTablero(tableroPrincipal)
265.             mostrarPuntajes(baldosaJugador, baldosaComputadora)
266.             jugada = obtenerJugadaJugador(tableroPrincipal, baldosaJugador)
267.             if jugada == 'salir':
268.                 print('¡Gracias por jugar!')
269.                 sys.exit() # terminar el programa
270.             elif jugada == 'pistas':
271.                 mostrarPistas = not mostrarPistas
272.                 continue
273.             else:
274.                 hacerJugada(tableroPrincipal, baldosaJugador, jugada[0], jugada[1])
275. 
276.             if obtenerJugadasVálidas(tableroPrincipal, baldosaComputadora) == []:
277.                 break
278.             else:
279.                 turno = 'computadora'
280. 
281.         else:
282.             # Turno de la computadora
283.             dibujarTablero(tableroPrincipal)
284.             mostrarPuntajes(baldosaJugador, baldosaComputadora)
285.             input('Presiona enter para ver la jugada de la computadora.')
286.             x, y = obtenerJugadaComputadora(tableroPrincipal, baldosaComputadora)
287.             hacerJugada(tableroPrincipal, baldosaComputadora, x, y)
288. 
289.             if obtenerJugadasVálidas(tableroPrincipal, baldosaJugador) == []:
290.                 break
291.             else:
292.                 turno = 'jugador'
293. 
294.     # Mostrar el puntaje final.
295.     dibujarTablero(tableroPrincipal)
296.     puntajes = obtenerPuntajeTablero(tableroPrincipal)
297.     print('X ha obtenido %s puntos. O ha obtenido %s puntos.' % (puntajes['X'], puntajes['O']))
298.     if puntajes[baldosaJugador] > puntajes[baldosaComputadora]:
299.         print('¡Has vencido a la computadora por %s puntos! ¡Felicitaciones!' % (puntajes[baldosaJugador] - puntajes[baldosaComputadora]))
300.     elif puntajes[baldosaJugador] < puntajes[baldosaComputadora]:
301.         print('Has perdido. La computadora te ha vencido por %s puntos.' % (puntajes[baldosaComputadora] - puntajes[baldosaJugador]))
302.     else:
303.         print('¡Ha sido un empate!')
304. 
305.     if not jugarDeNuevo():
306.         break

Cómo Funciona el Código

La Estructura de Datos del Tablero de Juego

Antes de meternos en el código, entendamos la estructura de datos del tablero. Esta estructura de datos es una lista de listas, igual que la de nuestro juego anterior Sonar. La lista de listas se crea para que tablero[x][y] represente al caracter en la posición x sobre el eje X (de izquierda a derecha) y la posición y sobre el eje Y (de arriba hacia abajo).

Este caracter puede ser un espacio ' ' en blanco (para representar un casillero vacío), un punto'.' (para representar una jugada posible en el modo de pistas), o un caracter 'X' o 'O' (para representar las baldosas de los jugadores). Cada vez que veas un parámetro llamado tablero, se tratará de esta especie de lista de listas.

Importando Otros Módulos

  1. # Reversi
  3. import random
  4. import sys

La línea 2 importa el módulo random para usar sus funciones randint() y choice(). La línea 3 importa el módulo sys para usar su función exit().

Dibujando la Estructura de Datos del Tablero sobre la Pantalla

  6. def dibujarTablero(tablero):
  7.     # Esta funcion dibuja el tablero recibido. Devuelve None
  8.     LÍNEAH = '  +---+---+---+---+---+---+---+---+'
  9.     LÍNEAV = '  |   |   |   |   |   |   |   |   |'
 10. 
 11.     print('    1   2   3   4   5   6   7   8')
 12.     print(LÍNEAH)

La función dibujarTablero() imprimirá el tablero actual del juego basado en la estructura de datos en la variable tablero. Observa que cada casillero del tablero se ve así (también podría haber una cadena 'O', '.' o ' ' en lugar de 'X'):

+---+
|   |
| X |
|   |
+---+

Ya que la línea horizontal se imprime una y otra vez, la línea 8 la almacena en una variable constante llamada LÍNEAH. Esto nos ahorrará el trabajo de tener que escribir esta cadena cada vez.

También hay líneas por encima y por debajo del centro de cada casillero que son simplemente repeticiones del caracter '|' (llamado "pleca") con 3 espacios entre cada uno. Este conjunto se almacena en una constante llamada LÍNEAV.

La línea 11 contiene a la primera ejecución de la función print(), e imprime las etiquetas para el eje X a lo largo del borde superior del tablero. La línea 12 imprime la línea horizontal superior del tablero.

 13.     for y in range(8):
 14.         print(LÍNEAV)
 15.         print(y+1, end=' ')
 16.         for x in range(8):
 17.             print('| %s' % (tablero[x][y]), end=' ')
 18.         print('|')
 19.         print(LÍNEAV)
 20.         print(LÍNEAH)

El bucle for se ejecutará ocho veces, una por cada fila. La línea 15 imprime la etiqueta del eje Y sobre el lado izquierdo del tablero, y tiene como argumento la palabra clave end=' ' para terminar la línea con un espacio simple en lugar de saltar a la siguiente línea. Esto es para que otro bucle (que también se ejecuta ocho veces, una por cada espacio) imprima cada espacio (junto con el caracter 'X', 'O' o ' ' dependiendo de lo que esté almacenado en tablero[x][y].)

La llamada a la función print() dentro del bucle interno también tiene como argumento la palabra clave end=' ' al final, con lo cual se imprime un espacio en lugar de una nueva línea. Esto produce una única línea con el aspecto '| X | X | X | X | X | X | X | X ' (si cada uno de los valores de tablero[x][y] fuera 'X').

Luego de que el bucle interno ha concluido, la llamada a la función print() en la línea 18 imprime el último caracter '|' junto con una nueva línea.

El código comprendido por el bucle completo entre las líneas 14 y 20 imprime una fila completa del tablero en este formato:

|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+

Cuando el bucle for de la línea 13 imprime la fila ocho veces, se forma el tablero completo (por supuesto, algunos de los espacios en el tablero tendrán caracteres 'O' o ' ' en lugar de 'X'):

|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
| X | X | X | X | X | X | X | X |
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+

Reiniciando el Tablero de Juego

 23. def reiniciarTablero(tablero):
 24.     # Deja en blanco el tablero recibido como argumento, excepto la posición inicial
 25.     for x in range(8):
 26.         for y in range(8):
 27.             tablero[x][y] = ' '

Las líneas 25 y 26 contienen bucles anidados para asignar espacios simples a cada elemento de la estructura de datos tablero. Esto crea un tablero vacío de Reversi. La función reiniciarTablero() es parte de la rutina de comenzar un nuevo juego.

Colocando las Piezas Iniciales

 29.     # Piezas iniciales:
 30.     tablero[3][3] = 'X'
 31.     tablero[3][4] = 'O'
 32.     tablero[4][3] = 'O'
 33.     tablero[4][4] = 'X'

Al comienzo del juego, cada jugador tiene dos baldosas ya colocadas en el centro. Las líneas 30 a 33 colocan esas baldosas en el tablero vacío.

La función reiniciarTablero() no necesita devolver la variable tablero, porque tablero es una referencia a una lista. Los cambios realizados en el entorno local de la función modificará la lista original que fue pasada como argumento. (Explicado en la sección Referencias del Capítulo 10.)

Creando una Nueva Estructura de Datos Tablero

 36. def obtenerNuevoTablero():
 37.     # Crea un tablero nuevo, vacío.
 38.     tablero = []
 39.     for i in range(8):
 40.         tablero.append([' '] * 8)
 41. 
 42.     return tablero

La función obtenerNuevoTablero() crea una nueva estructura de datos tablero y la devuelve. La línea 38 crea la lista exterior y guarda una referencia a esta lista en tablero. La línea 40 crea las listas interiores usando replicación de listas. ([' ']) * 8 se evalúa al mismo valor que [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], pero hay que escribir menos.)

El bucle for de la línea 39 crea las ocho listas internas. Los espacios representan un tablero de juego completamente vacío.

Lo que la variable tablero termina siendo es una lista de ocho listas, y cada una de esas listas tiene ocho cadenas. El resultado son 64 cadenas ' ' con un caracter espacio.

Comprobando si una Jugada es Válida

 45. def esJugadaVálida(tablero, baldosa, comienzox, comienzoy):
 46.     # Devuelve False si la jugada del jugador en comienzox, comienzoy es invalida
 47.     # Si es una jugada válida, devuelve una lista de espacios que pasarían a ser del jugador si moviera aquí.
 48.     if tablero[comienzox][comienzoy] != ' ' or not estáEnTablero(comienzox, comienzoy):
 49.         return False
 51.     tablero[comienzox][comienzoy] = baldosa # coloca temporariamente la baldosa sobre el tablero.
 53.     if baldosa == 'X':
 54.         otraBaldosa = 'O'
 55.     else:
 56.         otraBaldosa = 'X'
 58.     baldosasAConvertir = []

Dada una estructura de datos tablero, la baldosa del jugador y las coordenadas XY de la jugada del jugador, esJugadaVálida() devuelve True si las reglas de Reversi permiten una jugada en esas coordenadas y False en caso contrario.

La línea 48 comprueba si las coordenadas XY están fuera del tablero, o si el espacio no está vacío. estáEnTablero() es una función definida más adelante en el programa que se asegura de que el valor de ambas coordenadas X e Y esté comprendido entre 0 y 7.

El próximo paso es colocar temporariamente la baldosa del jugador sobre el tablero. Esta baldosa será removida (volviendo a asignar ' ' al espacio del tablero antes de volver de la función).

La baldosa del jugador (tanto el jugador humano como la computadora) se guarda en la variable baldosa, pero esta función necesitará saber la baldosa del otro jugador. Si la baldosa del jugador es 'X' entonces obviamente la baldosa del otro jugador será 'O' y viceversa.

Finalmente, si la coordenada XY ingresada corresponde a una jugada válida, la función esJugadaVálida() devuelve una lista de todas las baldosas del oponente que serán invertidas con esta jugada.

 59.     for direcciónx, direccióny in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:

El bucle for itera a través de una lista de listas que representan direcciones en las que puedes moverte en el tablero de juego. El tablero es un sistema de coordenadas cartesianas con direcciones X e Y. Hay ocho direcciones en las que puedes moverte: arriba, abajo, izquierda, derecha y las cuatro diagonales. Cada una de las ocho listas de dos elementos en la lista de la línea 59 se usa para moverse en una de estas direcciones. El programa se mueve en una dirección sumando el primer valor en la lista de dos elementos a la coordenada X, y el segundo valor a la coordenada Y.

Como la coordenada X aumenta a medida que te desplazas hacia la derecha, puedes "moverte" a la derecha sumando 1 a la coordenada X. Entonces, la lista [1, 0] suma 1 a la coordenada X y 0 a la coordenada Y, resultando en un "movimiento" hacia la derecha. Moverse a la izquierda es lo opuesto: en este caso restas 1 (es decir, sumas -1) a la coordenada X.

Pero para moverte en diagonal necesitarás sumar o restar a ambas coordenadas. Por ejemplo, sumar 1 a la coordenada X para moverte hacia la derecha y a su vez sumar -1 a la coordenada Y para moverte hacia arriba resulta en un movimiento en diagonal hacia arriba y a la derecha.

Comprobando Cada Una de las Ocho Direcciones

Aquí hay un diagrama para hacerte más fácil recordar qué lista de dos elementos representa cada dirección:

Figura 15-7: Cada lista de dos elementos representa una de las ocho direcciones.

 59.     for direcciónx, direccióny in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
 60.         x, y = comienzox, comienzoy
 61.         x += direcciónx # primer paso en la dirección
 62.         y += direccióny # primer paso en la dirección

La línea 60 asigna a las variables x e y el mismo valor que comienzos y comienzoy, respectivamente, utilizando asignación múltiple. A continuación se modifican las variables x e y para "moverse" en la dirección determinada por direcciónx y direccióny. Las variables comienzox y comienzoy no se modificarán de modo que el programa pueda recordar desde qué espacio comenzó el movimiento.

 63.         if estáEnTablero(x, y) and tablero[x][y] == otraBaldosa:
 64.             # Hay una pieza perteneciente al otro jugador al lado de nustra pieza
 65.             x += direcciónx
 66.             y += direccióny
 67.             if not estáEnTablero(x, y):
 68.                 continue

Recuerda que para que esta movida sea válida, el primer paso en esta dirección debe 1) pertenecer al tablero y 2) estar ocupado por una baldosa del otro jugador. De otro modo no hay ninguna baldosa del oponente para convertir, y una jugada válida debe convertir al menos una baldosa. Si no se cumplen estas dos condiciones, la condición de la línea 63 no es True y la ejecución vuelve a la sentencia for correspondiente a la próxima dirección.

Pero si el primer espacio contiene una baldosa del otro jugador, entonces el programa debe seguir comprobando en esta dirección hasta alcanzar una de las baldosas propias del jugador. Sin embargo, si continúa hasta más allá del tablero, la línea 68 hace que el programa vuelva al comienzo del bucle for y continúe con la siguiente dirección.

 69.             while tablero[x][y] == otraBaldosa:
 70.                 x += direcciónx
 71.                 y += direccióny
 72.                 if not estáEnTablero(x, y): # sale del bucle while y continua en el bucle for.
 73.                     break
 74.             if not estáEnTablero(x, y):
 75.                 continue

El bucle while de la línea 69 continúa ciclando de forma que x e y continúen moviéndose en la misma dirección siempre que sigan encontrando baldosas del otro jugador. Si la línea 72 detecta que x e y están fuera del tablero, la línea 73 sale del bucle for y el flujo de ejecución se mueve a la línea 74.

Lo que realmente quieres hacer aquí es salir del bucle while pero continuar dentro del bucle for. Es por esto que la línea 74 vuelve a comprobar not estáEnTablero(x, y) y ejecuta continue, lo que lleva a la ejecución hasta la próxima dirección en la sentencia for de la línea 59. Recuerda, las sentencias break y continue sólo interrumpen el bucle de nivel más bajo en el que se encuentran.

Averiguando si Hay Fichas a Convertir

 76.             if tablero[x][y] == baldosa:
 77.                 # Hay fichas a convertir. Caminar en dirección opuesta hasta llegar al casillero original, registrando todas las posiciones en el camino.
 78.                 while True:
 79.                     x -= direcciónx
 80.                     y -= direccióny
 81.                     if x == comienzox and y == comienzoy:
 82.                         break
 83.                     baldosasAConvertir.append([x, y])

El bucle while de la línea 69 deja de iterar cuando el código ha llegado al final de la secuencia de baldosas otraBaldosa. La línea 76 comprueba si este espacio en el tablero contiene una de nuestras baldosas. Si es así, entonces la jugada pasada originalmente a esJugadaVálida() es válida.

La línea 78 itera moviendo x e y en reversa hacia la posición original comienzox, comienzoy restando pasos del movimiento anterior. Cada espacio es añadido al final de la lista baldosasAConvertir.

 85.     tablero[comienzox][comienzoy] = ' ' # restablecer el espacio vacío
 86.     if len(baldosasAConvertir) == 0: # Si no se convirtió ninguna baldosa, la jugada no es válida.
 87.         return False
 88.     return baldosasAConvertir

El bucle for que comienza en la línea 59 repite todo esto en cada una de las ocho direccions. Luego de que el bucle concluye, la lista baldosasAConvertir contendrá las coordenadas XY de todas las baldosas del oponente que serían convertidas si el jugador colocara una baldosa en comienzox, comienzoy. Recuerda que la función esJugadaVálida() sólo comprueba si la jugada original era válida. Esta función no altera permanentemente la estructura del tablero de juego.

Si ninguna de las ocho direcciones ha convertido al menos una de las baldosas del oponente, entonces baldosasAConvertir contendrá una lista vacía. Esto quiere decir que esta jugada no es válida, por lo que esJugadaVálida() debe devolver False.

En caso contrario, esJugadaVálida() devuelve baldosasAConvertir.

Comprobando la Validez de las Coordenadas

 91. def estáEnTablero(x, y):
 92.     # Devuelve True si las coordenadas se encuentran dentro del tablero
 93.     return x >= 0 and x <= 7 and y >= 0 and y <=7

estáEnTablero() es una función llamada desde esJugadaVálida(). Llamar a esta función es una forma de abreviar la expresión Booleana de la línea 93 que devuelve True si tanto x como y están comprendidos entre 0 y 7. Esta función comprueba si un par ordenado X Y corresponde a una posición dentro del tablero. Por ejemplo, una coordenada X de 4 y una coordenada Y de 9999 no se encuentran dentro del tablero ya que las coordenadas Y sólo llegan hasta 7.

Obteniendo una Lista con Todas las Jugadas Válidas

 96. def obtenerTableroConJugadasVálidas(tablero, baldosa):
 97.     # Devuelve un nuevo tablero, marcando con "." las jugadas válidas que el jugador puede realizar.
 98.     réplicaTablero = obtenerCopiaTablero(tablero)
 99. 
100.     for x, y in obtenerJugadasVálidas(réplicaTablero, baldosa):
101.         réplicaTablero[x][y] = '.'
102.     return réplicaTablero

obtenerTableroConJugadasVálidas() devuelve una estructura de datos tablero que contiene caracteres '.' en cada espacio que es una jugada válida. Los puntos son para el modo pistas que muestra un tablero donde están marcadas todas las jugadas posibles.

Esta función crea un duplicado de la estructura de datos tablero (devuelto por obtenerCopiaTablero() en la línea 98) en lugar de modificar la que recibe a través del parámetro tablero. La línea 100 llama a obtenerJugadasVálidas() para obtener una lista de coordenadas XY con todas las jugadas válidas que el jugador podría tomar. La copia del tablero se marca con puntos en cada uno de esos espacios y se devuelve.

105. def obtenerJugadasVálidas(tablero, baldosa):
106.     # Devuelve una lista de listas [x,y] de jugadas válidas para el jugador en el tablero dado.
107.     jugadasVálidas = []
108. 
109.     for x in range(8):
110.         for y in range(8):
111.             if esJugadaVálida(tablero, baldosa, x, y) != False:
112.                 jugadasVálidas.append([x, y])
113.     return jugadasVálidas

La función obtenerJugadasVálidas() devuelve una lista de listas de dos elementos. Estas listas contienen las coordenadas XY de todas las jugadas válidas para el jugador correspondiente al parámetro baldosa y el estado del juego correspondiente al parámetro tablero.

Esta función usa bucles anidados (en las líneas 109 y 110) para comprobar cada par de coordenadas XY (las 64 combinaciones posibles) llamando a esJugadaVálida() en ese casillero y comprobando si devuelve False o una lista de casilleros (en cuyo caso es una jugada válida). Cada coordenada XY válida es añadida a la lista jugadasVálidas.

La Función bool()

La función bool() es similar a las funciones int() y str(). Devuelve la forma Booleana del valor que recibe.

La mayoría de los tipos de datos tiene un valor que se considera False para ese tipo de datos. Todos los otros valores se consideran True. Por ejemplo, el entero 0, el número de punto flotante 0.0, la cadena vacía, la lista vacía y el diccionario vacío se consideran False cuando se usan como condición para una sentencia if o una sentencia de bucle. Todos los otros valores son True. Prueba ingresar lo siguiente en la consola interactiva:

>>> bool(0)
False
>>> bool(0.0)
False
>>> bool('')
False
>>> bool([])
False
>>> bool({})
False
>>> bool(1)
True
>>> bool('Hola')
True
>>> bool([1, 2, 3, 4, 5])
True
>>> bool({'spam':'cheese', 'fizz':'buzz'})
True

Imagina que la condición de cualquier sentencia se colocase dentro de la llamada a bool(). Es decir, las condiciones son automáticamente interpretadas como valores Booleanos. Es por esto que la condición en la línea 111 funciona correctamente. La llamada a la función esJugadaVálida() devuelve el valor Booleano False o una lista no vacía.

Si te imaginas que la condición entera se coloca dentro de una llamada a bool(), entonces la condición False de la línea 111 se convierte en bool(False) (lo cuál, por supuesto, se evalúa a False). Y una condición de una lista no vacía colocada como el parámetro de bool devolverá True.

Obteniendo el Puntaje del Tablero de Juego

116. def obtenerPuntajeTablero(tablero):
117.     # Determina el puntaje contando las piezas. Devuelve un diccionario con claves 'X' y 'O'.
118.     puntajex = 0
119.     puntajeo = 0
120.     for x in range(8):
121.         for y in range(8):
122.             if tablero[x][y] == 'X':
123.                 puntajex += 1
124.             if tablero[x][y] == 'O':
125.                 puntajeo += 1
126.     return {'X':puntajex, 'O':puntajeo}

La función obtenerPuntajeTablero() usa bucles for anidados para comprobar los 64 espacios del tablero (8 filas multiplicadas por 8 columnas nos dan 64 espacios) y ver qué baldosas (si es que hay alguna) están sobre ellos. Por cada baldosa 'X', el código aumenta puntajex en la línea 123. Por cada baldosa 'X', el código incrementa puntajeo en la línea 125.

Obteniendo la Opción de Baldosa del Jugador

129. def ingresarBaldosaJugador():
130.     # Permite al jugador elegir que baldosa desea ser.
131.     # Devuelve una lista con la baldosa del jugador como primer elemento y el de la computadora como segundo.
132.     baldosa = ''
133.     while not (baldosa == 'X' or baldosa == 'O'):
134.         print('¿Deseas ser X ó O?')
135.         baldosa = input().upper()

This function asks the player which tile they want to be, either 'X' or 'O'. The for loop will keep looping until the player types in 'X' or 'O'.

137.     #  El primer elemento en la lista es la baldosa del juegador, el segundo es la de la computadora.
138.     if baldosa == 'X':
139.         return ['X', 'O']
140.     else:
141.         return ['O', 'X']

The enterPlayerTile() function then returns a two-item list, where the player’s tile choice is the first item and the computer’s tile is the second. Line 252, which calls enterPlayerTile(), uses multiple assignment to put these two returned items in two variables.

Determining Who Goes First

144. def quiénComienza():
145.     # Elije al azar qué jugador comienza.
146.     if random.randint(0, 1) == 0:
147.         return 'computadora'
148.     else:
149.         return 'jugador'

The whoGoesFirst() function randomly selects who goes first, and returns either the string 'computer' or the string 'player'.

Asking the Player to Play Again

152. def jugarDeNuevo():
153.     # Esta función devuelve True si el jugador quiere jugar de nuevo, de lo contrario devuelve False.
154.     print('¿Quieres jugar de nuevo? (sí o no)')
155.     return input().lower().startswith('s')

The playAgain() function was also in previous games. If the player types in a string that begins with 'y', then the function returns True. Otherwise the function returns False.

Placing Down a Tile on the Game Board

158. def hacerJugada(tablero, baldosa, comienzox, comienzoy):
159.     # Coloca la baldosa sobre el tablero en comienzox, comienzoy, y convierte cualquier baldosa del oponente.
160.     # Devuelve False si la jugada es inválida, True si es válida.
161.     baldosasAConvertir = esJugadaVálida(tablero, baldosa, comienzox, comienzoy)

makeMove() is called when you want to place a tile on the board and flip the other tiles according to the rules of Reversi. This function modifies the board data structure that is passed in-place. Changes made to the board variable (because it is a list reference) will be made to the global scope.

Most of the work is done by isValidMove(), which returns a list of XY coordinates (in a two-item list) of tiles that need to be flipped. (Remember, if the xstart and ystart arguments point to an invalid move, then isValidMove() will return the Boolean value False.)

163.     if baldosasAConvertir == False:
164.         return False
165. 
166.     tablero[comienzox][comienzoy] = baldosa
167.     for x, y in baldosasAConvertir:
168.         tablero[x][y] = baldosa
169.     return True

On lines 163 and 164, if the return value of isValidMove() (now stored in tilesToFlip) was False, then makeMove() will also return False.

Otherwise, isValidMove() returns a list of spaces on the board to put down the tiles (the 'X' or 'O' string in tile). Line 166 sets the space that the player has moved on. Line 167’s for loop sets all the tiles that are in tilesToFlip.

Copying the Board Data Structure

172. def obtenerCopiaTablero(tablero):
173.     # Duplica la lista del tablero y devuelve el duplicado.
174.     réplicaTablero = obtenerNuevoTablero()
175. 
176.     for x in range(8):
177.         for y in range(8):
178.             réplicaTablero[x][y] = tablero[x][y]
179. 
180.     return réplicaTablero

getBoardCopy() is different from getNewBoard(). getNewBoad() will create a blank game board data structure which has only empty spaces and the four starting tiles. getBoardCopy() will create a blank game board data structure, but then copy all of the spaces from the board parameter. This function is used by the AI to have a game board that it can change around without changing the real game board. This technique was also used by the previous Tic Tac Toe program.

A call to getNewBoard() handles getting a fresh game board data structure. Then the two nested for loops copy each of the 64 tiles from board to the duplicate board data structure in dupeBoard.

Determining if a Space is on a Corner

183. def esEsquina(x, y):
184.     # Devuelve True si la posicion es una de las esquinas.
185.     return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)

The isOnCorner() function returns True if the coordinates are on a corner space at coordinates (0,0), (7,0), (0,7) or (7,7). Otherwise isOnCorner() returns False.

Getting the Player’s Move

188. def obtenerJugadaJugador(tablero, baldosaJugador):
189.     # Permite al jugador tipear su jugada.
190.     # Devuelve la jugada como [x, y] (o devuelve las cadenas 'pistas' o 'salir')
191.     CIFRAS1A8 = '1 2 3 4 5 6 7 8'.split()

The getPlayerMove() function is called to let the player type in the coordinates of their next move (and check if the move is valid). The player can also type in 'hints' to turn hints mode on (if it is off) or off (if it is on). The player can also type in 'quit' to quit the game.

The DIGITS1TO8 constant variable is the list ['1', '2', '3', '4', '5', '6', '7', '8']. The DIGITS1TO8 constant is used because it is easier to type than the entire list. You can’t use the isdigit() method because that would allow 0 and 9 to be entered, which are not valid coordinates on the 8 × 8 board.

192.     while True:
193.         print('Ingresa tu jugada, salir para terminar el juego, o pistas para activar/desactivar las pistas.')
194.         jugada = input().lower()
195.         if jugada == 'salir':
196.             return 'salir'
197.         if jugada == 'pistas':
198.             return 'pistas'

The while loop will keep looping until the player has typed in a valid move. Lines 195 to 198 check if the player wants to quit or toggle hints mode, and return the string 'quit' or 'hints', respectively. The lower() method is called on the string returned by input() so the player can type 'HINTS' or 'Quit' but still have the command understood.

The code that called getPlayerMove() will handle what to do if the player wants to quit or toggle hints mode.

200.         if len(jugada) == 2 and jugada[0] in CIFRAS1A8 and jugada[1] in CIFRAS1A8:
201.             x = int(jugada[0]) - 1
202.             y = int(jugada[1]) - 1
203.             if esJugadaVálida(tablero, baldosaJugador, x, y) == False:
204.                 continue
205.             else:
206.                 break

The game is expecting that the player would have typed in the XY coordinates of their move as two numbers without anything between them. Line 200 first checks that the size of the string the player typed in is 2. After that, it also checks that both move[0] (the first character in the string) and move[1] (the second character in the string) are strings that exist in DIGITS1TO8.

Remember that the game board data structures have indexes from 0 to 7, not 1 to 8. The code prints 1 to 8 when the board is displayed in drawBoard() because non-programmers are used to numbers beginning at 1 instead of 0. So to convert the strings in move[0] and move[1] to integers, lines 201 and 202 subtract 1.

Even if the player typed in a correct move, the code still needs to check that the move is allowed by the rules of Reversi. This is done by isValidMove() which is passed the game board data structure, the player’s tile, and the XY coordinates of the move.

If isValidMove() returns False, then line 204’s continue statement executes. The execution will then go back to the beginning of the while loop and asks the player for a valid move again.

Otherwise, the player did type in a valid move and the execution needs to break out of the while loop.

207.         else:
208.             print('Esta no es una jugada válida. Ingresa la coordenada x (1-8), luego la coordenada y (1-8).')
209.             print('Por ejemplo, 81 corresponde a la esquina superior derecha.')

If the if statement’s condition on line 200 was False, then the player didn’t type in a valid move. Lines 208 and 209 instructs them on how to correctly type in moves. Afterwards, the execution moves back to the while statement on line 192 because line 209 isn’t only the last line in the else-block, but also the last line in the while-block.

211.     return [x, y]

Finally, getPlayerMove() returns a two-item list with the XY coordinates of the player’s valid move.

Getting the Computer’s Move

214. def obtenerJugadaComputadora(tablero, baldosaComputadora):
215.     # Dado un tablero y la baldosa de la computadora, determinar dónde
216.     # jugar y devolver esa jugada como una lista [x, y].
217.     jugadasPosibles = obtenerJugadasVálidas(tablero, baldosaComputadora)

getComputerMove() and is where the AI algorithm is implemented. Normally you use the results from getValidMoves() for hints mode. Hints mode will print '.' period characters on the board to show the player all the potential moves they can make.

But if getValidMoves() is called with the computer AI’s tile (in computerTile), it will also find all the possible moves that the computer can make. The AI will select the best move from this list.

219.     # ordena al azar el orden de las jugadas posibles
220.     random.shuffle(jugadasPosibles)

First, random.shuffle() will randomize the order of moves in the possibleMoves list. Why we want to shuffle the possibleMoves list will be explained later, but first let’s look at the algorithm.

Corner Moves are the Best Moves

222.     # siempre jugar en una esquina si está disponible.
223.     for x, y in jugadasPosibles:
224.         if esEsquina(x, y):
225.             return [x, y]

First, line 223 loops through every move in possibleMoves. If any of them are on the corner, return that space is returned as the move. Corner moves are a good idea in Reversi because once a tile has been placed on the corner, it can never be flipped over. Since possibleMoves is a list of two-item lists, use multiple assignment in the for loop to set x and y.

If possibleMoves contains multiple corner moves, the first one is always used. But since possibleMoves was shuffled on line 220, it is random which corner move is first in the list.

Get a List of the Best Scoring Moves

227.     # Recorrer la lista de jugadas posibles y recordar la que da el mejor puntaje
228.     mejorPuntaje = -1
229.     for x, y in jugadasPosibles:
230.         réplicaTablero = obtenerCopiaTablero(tablero)
231.         hacerJugada(réplicaTablero, baldosaComputadora, x, y)
232.         puntaje = obtenerPuntajeTablero(réplicaTablero)[baldosaComputadora]
233.         if puntaje > mejorPuntaje:
234.             mejorJugada = [x, y]
235.             mejorPuntaje = puntaje
236.     return mejorJugada

If there are no corner moves, loop through the entire list and find out which move results in the highest score. Line 229’s for loop will set x and y to every move in possibleMoves. bestMove is set to the highest scoring move the code has found so far, and bestScore is set to the best move’s score.

When the code in the loop finds a move that scores higher than bestScore, line 233 to 235 will store that move and score as the new values in bestMove and bestScore.

Simulate All Possible Moves on Duplicate Board Data Structures

Before simulating a move, line 230 makes a duplicate game board data structure by calling getBoardCopy(). You’ll want a copy so you can modify without changing the real game board data structure stored in the board variable.

Then line 231 calls makeMove(), passing the duplicate board (stored in dupeBoard) instead of the real board. This will simulate what would happen on the real board if this move was made. makeMove() will handle placing the computer’s tile and the flipping the player’s tiles on the duplicate board.

Line 232 calls getScoreOfBoard()with the duplicate board, which returns a dictionary where the keys are 'X' and 'O', and the values are the scores.

For example, pretend that getScoreOfBoard() returns the dictionary {'X':22, 'O':8} and computerTile is 'X'. Then getScoreOfBoard(dupeBoard)[computerTile] would evaluate to {'X':22, 'O':8}['X'], which would then evaluate to 22. If 22 is larger than bestScore, bestScore is set to 22 and bestMove is set to the current x and y values.

By the time this for loop is finished, you can be sure that bestScore is the highest possible score a move can make, and that move is stored in bestMove.

Line 228 first sets bestScore to -1 so that the first move the code checks will be set to the first bestMove. This will guarantee that bestMove is set to one of the moves from possibleMoves when it returns.

Even though the code always chooses the first in the list of these tied moves, it’s random because the list order was shuffled on line 220. This ensures that the AI won’t be predictable when there’s more than one best move.

Printing the Scores to the Screen

239. def mostrarPuntajes(baldosaJugador, baldosaComputadora):
240.     # Imprime el puntaje actual.
241.     puntajes = obtenerPuntajeTablero(tableroPrincipal)
242.     print('Tienes %s puntos. La computadora tiene %s puntos.' % (puntajes[baldosaJugador], puntajes[baldosaComputadora]))

showPoints() calls the getScoreOfBoard() function and then prints the player’s and computer’s scores. Remember that getScoreOfBoard() returns a dictionary with the keys 'X' and 'O' and values of the scores for the X and O players.

That’s all the functions for the Reversi game. The code starting on line 246 will implement the actual game and calls these functions as needed.

The Start of the Game

246. print('¡Bienvenido a Reversi!')
247. 
248. while True:
249.     # Reiniciar el tablero y el juego.
250.     tableroPrincipal = obtenerNuevoTablero()
251.     reiniciarTablero(tableroPrincipal)
252.     baldosaJugador, baldosaComputadora = ingresarBaldosaJugador()
253.     mostrarPistas = False
254.     turno = quiénComienza()
255.     print(("El " if turno == "jugador" else "La ") + turno + ' comenzará.')

The while loop on line 248 is the main game loop. The program will loop back to line 248 when a new game starts. First get a new game board data structure by calling getNewBoard() and set the starting tiles by calling resetBoard(). mainBoard is the main game board data structure for the program. The call to enterPlayerTile() will let the player type in whether they want to be 'X' or 'O'. The return value is then stored in playerTile and computerTile using multiple assignment.

showHints is a Boolean value that determines if hints mode is on or off. It starts as off as False on line 253.

The turn variable is a string that either has the string value 'player' or 'computer'. It will keep track of whose turn it is. It is set to the return value of whoGoesFirst(), which randomly chooses who will go first.

Running the Player’s Turn

257.     while True:
258.         if turno == 'jugador':
259.             # Turno del jugador
260.             if mostrarPistas:
261.                 tableroConJugadasVálidas = obtenerTableroConJugadasVálidas(tableroPrincipal, baldosaJugador)
262.                 dibujarTablero(tableroConJugadasVálidas)
263.             else:
264.                 dibujarTablero(tableroPrincipal)
265.             mostrarPuntajes(baldosaJugador, baldosaComputadora)

The while loop that starts on line 257 will keep looping each time the player or computer takes a turn. The execution will break out of this loop when the current game is over.

Line 258 has an if statement whose body has the code that runs if it is the player’s turn. (The else-block that starts on line 282 has the code for the computer’s turn.)

First the board is displayed on the screen. If hints mode is on (that is, showHints is True), then the board data structure needs to have '.' period characters on every valid space the player could move.

The getBoardWithValidMoves() function does that. It is passed a game board data structure and returns a copy that also contains '.' period characters. Line 262 passes this board to the drawBoard() function.

If hints mode is off, then line 264 passes mainBoard to drawBoard().

After printing out the game board to the player, you also want to print the current score by calling showPoints() on line 265.

266.             jugada = obtenerJugadaJugador(tableroPrincipal, baldosaJugador)

Next, let the player type in their move. getPlayerMove() handles this, and its return value is a two-item list of the XY coordinate of the player’s move. getPlayerMove() has already made sure that the move the player typed in is a valid move.

Handling the Quit or Hints Commands

267.             if jugada == 'salir':
268.                 print('¡Gracias por jugar!')
269.                 sys.exit() # terminar el programa
270.             elif jugada == 'pistas':
271.                 mostrarPistas = not mostrarPistas
272.                 continue
273.             else:
274.                 hacerJugada(tableroPrincipal, baldosaJugador, jugada[0], jugada[1])

If the player typed in the string 'quit' for their move, then getPlayerMove() would have returned the string 'quit'. In that case, line 269 calls the sys.exit() to terminate the program.

If the player typed in the string 'hints' for their move, then getPlayerMove() would have returned the string 'hints'. In that case, you want to turn hints mode on (if it was off) or off (if it was on).

The showHints = not showHints assignment statement on line 271 handles both of these cases, because not False evaluates to True and not True evaluates to False. Then the continue statement moves the execution to the start of the loop (turn has not changed, so it will still be the player’s turn).

Otherwise, if the player didn’t quit or toggle hints mode, line 274 calls makeMove() to make the player’s move on the board.

Make the Player’s Move

276.             if obtenerJugadasVálidas(tableroPrincipal, baldosaComputadora) == []:
277.                 break
278.             else:
279.                 turno = 'computadora'

After making the player’s move, line 276 calls getValidMoves() to see if the computer could make any moves. If getValidMoves() returns a blank list, then there are no more valid moves that the computer could make. In that case, line 277 breaks out of the while loop and ends the game.

Otherwise, line 279 sets turn to 'computer'. The flow of execution skips the else-block and reaches the end of the while-block, so execution jumps back to the while statement on line 257. This time, however, it will be the computer’s turn.

Running the Computer’s Turn

281.         else:
282.             # Turno de la computadora
283.             dibujarTablero(tableroPrincipal)
284.             mostrarPuntajes(baldosaJugador, baldosaComputadora)
285.             input('Presiona enter para ver la jugada de la computadora.')
286.             x, y = obtenerJugadaComputadora(tableroPrincipal, baldosaComputadora)
287.             hacerJugada(tableroPrincipal, baldosaComputadora, x, y)

After printing out the board with drawBoard(), also print the current score with a call to showPoints() on line 284.

Line 285 calls input() to pause the script while the player can look at the board. This is much like how input() was used to pause the program in the Jokes chapter. Instead of using a print() call to print a string before a call to input(), you can do the same thing by passing the string to print to input().

After the player has looked at the board and pressed ENTER, line 286 calls getComputerMove() to get the XY coordinates of the computer’s next move. These coordinates are stored in variables x and y using multiple assignment.

Finally, pass x and y, along with the game board data structure and the computer’s tile, to the makeMove() function. This places the computer’s tile on the game board in mainBoard to reflect the computer’s move. Line 286’s call to getComputerMove() got the computer’s move (and stored it in variables x and y). The call to makeMove() on line 287 makes the move on the board.

289.             if obtenerJugadasVálidas(tableroPrincipal, baldosaJugador) == []:
290.                 break
291.             else:
292.                 turno = 'jugador'

Lines 289 to 292 are similar to lines 276 to 279. After the computer has made its move, line 289 checks if there exist any valid moves the human player can make. If getValidMoves() returns an empty list, then there are no valid moves. That means the game is over, and line 290 breaks out of the while loop.

Otherwise, there’s at least one possible move the player should make. The turn variable is to 'player'. There is no more code in the while-block after line 292, so execution loops back to the while statement on line 257.

Drawing Everything on the Screen

294.     # Mostrar el puntaje final.
295.     dibujarTablero(tableroPrincipal)
296.     puntajes = obtenerPuntajeTablero(tableroPrincipal)
297.     print('X ha obtenido %s puntos. O ha obtenido %s puntos.' % (puntajes['X'], puntajes['O']))
298.     if puntajes[baldosaJugador] > puntajes[baldosaComputadora]:
299.         print('¡Has vencido a la computadora por %s puntos! ¡Felicitaciones!' % (puntajes[baldosaJugador] - puntajes[baldosaComputadora]))
300.     elif puntajes[baldosaJugador] < puntajes[baldosaComputadora]:
301.         print('Has perdido. La computadora te ha vencido por %s puntos.' % (puntajes[baldosaComputadora] - puntajes[baldosaJugador]))
302.     else:
303.         print('¡Ha sido un empate!')

Line 294 is the first line beyond the while-block that started on line 257. This code is executed when the execution breaks out of that while loop from line 290 or 277. At this point, the game is over. Now the program should print the board and scores and determine who won the game.

getScoreOfBoard() will return a dictionary with keys 'X' and 'O' and values of both players’ scores. By checking if the player’s score is greater than, less than, or equal to the computer’s score, you can know if the player won, lost, or tied, respectively.

Ask the Player to Play Again

305.     if not jugarDeNuevo():
306.         break

Call the playAgain() function, which returns True if the player typed in that they want to play another game. If playAgain() returns False, the not operator makes the if statement’s condition True, the execution breaks out of the while loop that started on line 248. Since there are no more lines of code after this while-block, the program terminates.

Otherwise, playAgain() has returned True (making the if statement’s condition False), and so execution loops back to the while statement on line 248 and a new game board is created.

Changing the drawBoard() Function

The board you draw for the Reversi game is large. But you could change the drawBoard() function’s code to draw out a much smaller board, while keeping the rest of the game code the same. The new, smaller board would look like this:

  12345678
 +--------+
1|    O   |
2|   XOX  |
3|    O   |
4| XXXXX  |
5|  .OX   |
6|  OOO   |
7| ..O..  |
8|   O    |
 +--------+
You have 8 points. The computer has 9 points.
Enter your move, or type quit to end the game, or hints to turn off/on hints.

Here is the code for this new drawBoard() function, starting at line 6. You can also download this code from http://invpy.com/reversi_mini.py.

  6. def drawBoard(board):
  7.     # This function prints out the board that it was passed. Returns None.
  8.     LÍNEAH = ' +--------+'
  9.     print(' 12345678')
 10.     print(LÍNEAH)
 11.     for y in range(8):
 12.         print('%s|' % (y+1), end='')
 13.         for x in range(8):
 14.             print(board[x][y], end='')
 15.         print('|')
 16.     print(LÍNEAH)

Summary

The AI may seem almost unbeatable, but this isn’t because the computer is smart. The strategy it follows is simple: move on the corner if you can, otherwise make the move that will flip over the most tiles. We could do that, but it would be slow to figure out how many tiles would be flipped for every possible valid move we could make. But calculating this for the computer is simple. The computer isn’t smarter than us, it’s just much faster!

This game is similar to Sonar because it makes use of a grid for a board. It is also like the Tic Tac Toe game because there’s an AI that plans out the best move for it to take. This chapter only introduced one new concept: that empty lists, blank strings, and the integer 0 all evaluate to False in the context of a condition.

Other than that, this game used programming concepts you already knew! You don’t have to know much about programming to create interesting games. However, this game is stretching how far you can get with ASCII art. The board took up almost the entire screen to draw, and the game didn't have any color.

Later in this book, we will learn how to create games with graphics and animation, not just text. We will do this using a module called Pygame, which adds new functions and features to Python so that we can break away from using only text and keyboard input.
