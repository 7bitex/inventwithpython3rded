  Capítulo 9
  EL AHORCADO

Temas Tratados en este Capítulo:

• Cadenas multi-línea
• Métodos
• Listas
• Los métodos de lista append() y reverse()
• Los métodos de cadena lower(), upper(), split(), startswith(), y endswith()
• Los operadores in y not in
• Las funciones range() y list()
• Las sentencias del
• Los bucles for
• Las sentencias elif

El juego de este capítulo introduce muchos conceptos nuevos, pero no te preocupes. Experimentarás antes con estos conceptos de programación en el terminal interactivo. Aprenderás sobre los métodos, que son funciones vinculadas a valores. Aprenderás también acerca de un nuevo tipo de lazo de repetición llamado el bucle for y un nuevo tipo de dato llamado lista. Una vez entiendas estos conceptos, será mucho mas fácil programar El Ahorcado.

Código Fuente de El Ahorcado

El juego de este capítulo es un poco más largo que el de los juegos anteriores, pero una buena parte de este es arte ASCII para las figuras de el ahorcado. Introduzca lo siguiente en el editor de archivos y guárdelo como ahorcado.py.

hangman.py

  1. import random
  2. IMÁGENES_AHORCADO = ['''
  3.
  4.   +---+
  5.   |   |
  6.       |
  7.       |
  8.       |
  9.       |
 10. =========''', '''
 11.
 12.   +---+
 13.   |   |
 14.   O   |
 15.       |
 16.       |
 17.       |
 18. =========''', '''
 19.
 20.   +---+
 21.   |   |
 22.   O   |
 23.   |   |
 24.       |
 25.       |
 26. =========''', '''
 27.
 28.   +---+
 29.   |   |
 30.   O   |
 31.  /|   |
 32.       |
 33.       |
 34. =========''', '''
 35.
 36.   +---+
 37.   |   |
 38.   O   |
 39.  /|\  |
 40.       |
 41.       |
 42. =========''', '''
 43.
 44.   +---+
 45.   |   |
 46.   O   |
 47.  /|\  |
 48.  /    |
 49.       |
 50. =========''', '''
 51.
 52.   +---+
 53.   |   |
 54.   O   |
 55.  /|\  |
 56.  / \  |
 57.       |
 58. =========''']
 59. palabras = 'hormiga babuino tejon murcielago oso castor camello gato almeja cobra pantera coyote cuervo ciervo perro burro pato aguila huron zorro rana cabra ganso halcon leon lagarto llama topo mono alce raton mula salamandra nutria buho panda loro paloma piton conejo carnero rata cuervo rinoceronte salmon foca tiburon oveja mofeta perezoso serpiente araña cigüeña cisne tigre sapo trucha pavo tortuga comadreja ballena lobo wombat cebra'.split()
 60.
 61. def obtenerPalabraAlAzar(listaDePalabras):
 62.     # Esta función devuelve una cadena al azar de la lista de cadenas pasada como argumento.
 63.     índiceDePalabras = random.randint(0, len(listaDePalabras) - 1)
 64.     return listaDePalabras[índiceDePalabras]
 65.
 66. def mostrarTablero(IMÁGENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta):
 67.    print(IMÁGENES_AHORCADO[len(letrasIncorrectas)])
 68.    print()
 69.
 70.    print('Letras incorrectas:', end=' ')
 71.    for letra in letrasIncorrectas:
 72.        print(letra, end=' ')
 73.    print()
 74.
 75.    espaciosVacíos = '_' * len(palabraSecreta)
 76.
 77.    for i in range(len(palabraSecreta)): # completar los espacios vacíos con las letras adivinadas
 78.        if palabraSecreta[i] in letrasCorrectas:
 79.            espaciosVacíos = espaciosVacíos[:i] + palabraSecreta[i] + espaciosVacíos[i+1:]
 80.
 81.    for letra in espaciosVacíos: # mostrar la palabra secreta con espacios entre cada letra
 82.        print(letra, end=' ')
 83.    print()
 84.
 85. def obtenerIntento(letrasProbadas):
 86.    # Devuelve la letra ingresada por el jugador. Verifica que el jugador ha ingresado sólo una letra, y no otra cosa.
 87.    while True:
 88.        print('Adivina una letra.')
 89.        intento = input()
 90.        intento = intento.lower()
 91.        if len(intento) != 1:
 92.            print('Por favor, introduce una letra.')
 93.        elif intento in letrasProbadas:
 94.            print('Ya has probado esa letra. Elige otra.')
 95.        elif intento not in 'abcdefghijklmnñopqrstuvwxyz':
 96.            print('Por favor ingresa una LETRA.')
 97.        else:
 98.            return intento
 99.
100. def jugarDeNuevo():
101.    # Esta función devuelve True si el jugador quiere volver a jugar, en caso contrario devuelve False.
102.    print('¿Quieres jugar de nuevo? (sí o no)')
103.    return input().lower().startswith('s')
104.
105.
106. print('A H O R C A D O')
107. letrasIncorrectas = ''
108. letrasCorrectas = ''
109. palabraSecreta = obtenerPalabraAlAzar(palabras)
110. juegoTerminado = False
111.
112. while True:
113.     mostrarTablero(IMÁGENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta)
114.
115.    # Permite al jugador escribir una letra.
116.    intento = obtenerIntento(letrasIncorrectas + letrasCorrectas)
117.
118.    if intento in palabraSecreta:
119.        letrasCorrectas = letrasCorrectas + intento
120.
121.        # Verifica si el jugador ha ganado.
122.        encontradoTodasLasLetras = True
123.        for i in range(len(palabraSecreta)):
124.            if palabraSecreta[i] not in letrasCorrectas:
125.                encontradoTodasLasLetras = False
126.                break
127.        if encontradoTodasLasLetras:
128.            print('¡Sí! ¡La palabra secreta es "' + palabraSecreta + '"! ¡Has ganado!')
129.            juegoTerminado = True
130.    else:
131.        letrasIncorrectas = letrasIncorrectas + intento
132.
133.        # Comprobar si el jugador ha agotado sus intentos y ha perdido.
134.        if len(letrasIncorrectas) == len(IMÁGENES_AHORCADO) - 1:
135.            mostrarTablero(IMÁGENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta)
136.            print('¡Te has quedado sin intentos!\nDespués de ' + str(len(letrasIncorrectas)) + ' intentos fallidos y ' + str(len(letrasCorrectas)) + ' aciertos, la palabra era "' + palabraSecreta + '"')
137.            juegoTerminado = True
138.
139.    # Preguntar al jugador si quiere volver a jugar (pero sólo si el juego ha terminado).
140.    if juegoTerminado:
141.        if jugarDeNuevo():
142.            letrasIncorrectas = ''
143.            letrasCorrectas = ''
144.            juegoTerminado = False
145.            palabraSecreta = obtenerPalabraAlAzar(palabras)
146.        else:
147.            break

Como Funciona el Código

  1. import random

El programa El Ahorcado selecciona aleatoriamente una palabra secreta a partir de una lista secreta de palabras. El módulo random provee está habilidad, por lo que la línea 1 lo importa.

  2. IM\u00c1GENES_AHORCADO = ['''
  3.
  4.   +---+
  5.   |   |
  6.       |
  7.       |
  8.       |
  9.       |
 10. =========''', '''

...el resto del código es demasiado largo para mostrarlo acá...

Esta nueva sentencia de asignación se extiende a lo largo de las líneas 2 a la 58 en el código fuente. Para ayudarte a entender los que este código significa, aprendamos acerca de cadenas multi-línea.

Cadenas multi-línea

Hasta ahora todas las cadenas han sido de una sola línea y tenían un carácter de comillas al principio y al final. Sin embargo, si utiliza comillas triples al comienzo y al final entonces la cadena puede ir a lo largo de varias líneas:

>>> burbuja = '''Querida Alicia,
Volveré a la casa de Carol al final del mes. Te veré luego.
Tu amigo,
Bob '''
>>> print(burbuja)
Querida Alicia,
Volveré a la casa de Carol al final del mes. Te veré luego.
Tu amigo,
Bob

Estas son cadenas multi-línea. En una cadena multi-línea, los caracteres de nueva línea son incluidos como parte de la cadena. No tienes que utilizar el caracter de escape \n, o las comillas de escape siempre que no utilices tres comillas juntas. Esto hace que el código sea fácil de leer para largas cantidades de texto.

Variables Constantes

El nombre de variable IMÁGENES_AHORCADO está todo en mayúsculas. Esta es una convención en programación para variables constantes. Las constantes son variables que tienen por finalidad almacenar valores que nunca cambian desde la primera sentencia de asignación.  Aunque puedes cambiar el valor de IMÁGENES_AHORCADO como con cualquier otra variable, un nombre con todas las mayúsculas te recuerda no hacerlo. Dado que la variable IMÁGENES_AHORCADO nunca necesita ser cambiada, es marcada como constante.

Como todas las convenciones, es tu decisión seguirla. Pero siguiendo esta convención le haces mas fácil a otras y otros programadores leer tu código. Sabrán que IMÁGENES_AHORCADO siempre tendrá el valor que se le asignó en la línea 2.

Listas

Un valor de lista puede contener otros valores dentro. Intenta introducir esto en el terminal interactivo:

>>> spam = ['Vida', 'El Universo', 'Todo', 42]
>>> spam
['Vida', 'El Universo', 'Todo', 42]

Este valor lista en spam contiene cuatro valores. Cuando escribes el valor lista en tu código, comienza con un [ corchete y termina con otro corchete. Esto es igual a las cadenas que terminan y empiezan con un caracter de comillas.

Se separan con comas los valores individuales dentro de una lista. Estos valores son llamados elementos o ítems.

Índices

Intenta introducir animales = ['águila', 'alce', 'antílope', 'albert'] en el terminal interactivo para alamcenar una lista en la variable animales. Los corchetes son usados también para acceder al elemento dentro de una lista. Intenta introducir animales[0], animales[1], animales[2], animales[3] en un terminal interactivo para ver que devuelven:

>>> animales = ['águila', 'alce', 'antílope', 'albert']
>>> animals[0]
'águila'
>>> animals[1]
'alce'
>>> animals[2]
'antílope'
>>> animals[3] # ¡el autor de este libro!
'albert'

El número entre los corchetes es el índice. En Python, el índice del primer elemento en una lista es 0. El segundo elemento está en el índice 1, el tercer elemento está en el índice 2 y así. Debido a que los índices comienzan en 0 y no en 1, decimos que las listas de Python tiene índices de base cero.

Las listas son buenas para almacenar varios valores sin usar una variable para cada uno. En otro caso, el código se vería como esto:

>>> animales1 = 'águila'
>>> animales2 = 'alce'
>>> animales3 = 'antílope'
>>> animales4 = 'albert'

Este código podría ser difícil de manejar si tiene ciento o miles de cadenas. Pero una lista puede fácilmente contener cualquier número de valores. Utilizando corchetes, puedes tratar los elementos en la lista como cualquie rotro valor. Intenta introducir animales[0] + animales[2] en el intérprete interactivo:

>>> animales[0] + animales[2]
'águilaantílope'

La evaluación sería como esto:

animales[0] + animales[2]
           ▼
  'águila' + animals[2]
           ▼
  'águila' + 'antílope'
           ▼
   'águilaantílope'

IndexError

Si intentas acceder a un índice que es demasiado grande, obtendrás un IndexError que colgará tu programa. Intenta introducir lo siguiente en el intérprete interactivo:

>>> animales = ['águila', 'alce', 'antílope', 'albert']
>>> animales[9999]
Traceback (most recent call last):
File "", line 1, in
animales[9999]
IndexError: list index out of range

Cambiando los Valores de los Elementos de una Lista con asignación por Índice

También puedes usar los corchetes para cambiar el valor de un elemento en una lista. Intenta introducir lo siguiente en el intérprete interactivo:

>>> animales = ['águila', 'alce', 'antílope', 'albert']
>>> animales[1] = 'ALCE'
>>> animales
['águila', 'ALCE', 'antílope', 'albert']

La nueva cadena 'ALCE' sobreescribe el segundo elemento en la lista animales. De manera que animales[1] devolverá el segundo elemento de la lista en las expresiones, pero también puedes usarlo en el lado izquierdo de una sentencia de asignación para asignar un valor como el segundo elemento de la lista.

Concatenación de listas

Puedes unir listas en una sola lista con el operador +, del mismo modo como puedes unir cadenas. Unir listas con el operador + es una concatenación de listas. Intenta introducir lo siguiente en el intérprete interactivo:

>>> [1, 2, 3, 4] + ['manzanas', 'naranjas'] + ['Alicia', 'Beto']
[1, 2, 3, 4, 'manzanas', 'naranjas', 'Alicia', 'Beto']

['manzanas'] + ['naranjas'] devolverá ['manzanas', 'naranjas']. Pero ['manzanas'] + 'naranjas' resultará en un error. No puedes sumarun valor de lista y un valor de cadena en lugar de dos valores de lista. Si quieres sumar valores que no son lista a una lista, utiliza el método append() (descrito más adelante).

El Operador in

El operador in te puede decir si un valor está en una lista o no. Las expresiones que usan el operador in devuelven un valor lógico: True si el valor está en la lista y False si no está. Intenta introducir lo siguiente en el intérprete interactivo:

>>> animales = ['águila', 'alce', 'antílope', 'albert']
>>> 'antílope' in animales
True

La expresión 'antílope' en animales devuelve True porque la cadena 'antílope' es uno de los valores en la lista animales. Estña localizado en el índice 2.

Pero si escribes la expresión 'atún' in animales, esto devolverá False porque la cadena 'atún' no existe en la lista.

>>> animales = ['águila', 'alce', 'antílope', 'albert']
>>> 'antílope' in animales
True
>>> 'atún' in animales
False

El operador in también trabaja para las cadenas. Verifica si una cadena existe en otra. Intenta introducir lo siguiente en el intérprete interactivo:

>>> 'hola' in 'Alicia le dice hola a Beto.'
True

Eliminando Elementos de Listas con Sentencias del

Una sentencia del eliminará un elemento en un índice determinado de una lista. Intenta introducir lo siguiente en el intérprete interactivo:

>>> spam = [2, 4, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 6, 8, 10]

Nota que cuando eliminas un elemento en el índice 1, el elemento que estaba en el índice 2 ahora es el nuevo valor en el índice 1. El elemento que estaba en el índice 3 pasa a ser el nuevo valor en el índice 2. Todo lo que estaba por encima del elemento eliminado se mueve un índice hacia abajo.

Puedes escribir del spam[1] una y otra vez para seguir eliminando elementos de la lista:

>>> spam = [2, 4, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 6, 8, 10]
>>> del spam[1]
>>> spam
[2, 8, 10]
>>> del spam[1]
>>> spam
[2, 10]

La sentencia del es una sentencia, no una función ni un operador. No tiene paréntesis ni devuelve un valor.

Listas de Listas

Las listas pueden contener otros valores, incluyendo otras listas. Digamos que tienes una lista de comestibles, una lista de tareas domesticas, y una lista de tus pasteles favoritos. Puedes poner las tres listas en una sola lista. Intenta introducir lo siguiente en el intérprete interactivo:

>>> comestibles = ['huevos', 'leche', 'sopa', 'manzanas', 'pan']
>>> tareas = ['limpiar', 'cortar el césped', 'ir al supermercado']
>>> pastelesFavoritos = ['manzanas', 'zarzamora']
>>> listaDeListas = [comestibles, tareas, pastelesFavoritos]
>>> listaDeListas
[['huevos', 'leche', 'sopa', 'manzanas', 'pan'], ['limpiar', 'cortar el césped', 'ir al supermercado'], ['manzanas', 'zarzamora']]

Para obtener un elemento dentro de una lista de listas, usarías dos conjuntos de corchetes como este: listaDeListas[1][2] que devolvería la cadena 'ir al supermercado'.

Esto es porque listaDeListas[1][2] devuelve ['limpiar', 'cortar el césped', 'ir al supermercado'][2]. Lo que finalmente devuelve 'ir al supermercado':

listaDeListas[1][2]
         ▼
[['huevos', 'leche', 'sopa', 'manzanas', 'pan'], ['limpiar', 'cortar el césped', 'ir al supermercado'], ['manzanas', 'zarzamora']][1][2]
         ▼
['limpiar', 'cortar el césped', 'ir al supermercado'][2]
         ▼
'ir al supermercado'

La Figura 9-1 es otro ejemplo de una lista de listas, a lo largo de alguno de los índices que apuntan a los elementos. Las flechas apuntan a índices de las propias listas internas. La imagen está invertida lateralmente para facilitar su lectura.

Métodos

Los métodos son funciones adjuntas a un valor. Por ejemplo, todos los valores de cadena tienen el método lower(), el cuál devuelve una copia de la cadena en minúsculas. Lo puedes llamarlo como 'Hola.lower()', lo cual devuelve 'hola'. No puedes llamar a lower() por sí mismo y no puedes pasar un argumento a lower() (como en lower('Hola')). Debes añadir el método a una cadena especifica usando un punto. La siguiente sección describe en mayor profundidad los métodos de cadena.

Figura 9-1: Los índices de una Lista de listas

Los métodos de cadena lower() y upper()

Intenta introducir '¡Hola mundo!'.lower() en el intérprete interactivo para ver un ejemplo de este método:

>>> '¡Hola mundo!'.lower()
'¡hola mundo!'

También hay un método upper() para cadenas, el cual devuelve una cadena con todos los caracteres en mayúsculas. Intenta introducir '¡Hola mundo!.upper() en el intérprete interactivo:

>>> '!Hola mundo!'.upper()
'!HOLA MUNDO!'

Ya que el método upper() devuelve una cadena, también puedes llamar un método en esa cadena también. Intenta introducir '¡Hola mundo!'.upper().lower() en el intérprete interactivo:

>>> '¡Hola mundo!'.upper().lower()
'¡hola mundo!'
'¡Hola mundo!'.upper() devuelve la cadena '¡HOAL MUNDO!', y entonces se llama el método lower() de esta cadena. Esto devuelve la cadena '¡hola mundo!', que es el valor final de la evaluación.

'¡Hola mundo!'.upper().lower()
                    ▼
        '¡HOLA MUNDO!'.lower()
                    ▼
                '¡hola mundo!'

El orden es importante. '¡Hola mundo!'.lower().upper() no es lo mismo que '¡Hola mundo!'.upper().lower():

>>> '!Hola mundo!'.lower().upper()
'!HOLA MUNDO!'

Esta evaluación sería:

'¡Hola mundo!'.upper().lower()
                    ▼
        '¡hola mundo!'.upper()
                    ▼
                '!HOLA MUNDO!'

Si se almacena una cadena en una variable, puedes llamar un método de cadena en esa variable. Mira este ejemplo:

>>> spam = '¡Hola mundo!'
>>> spam.upper()
'!HOLA MUNDO!'

Esto no cambia el valor en spam. La variable spam seguirá conteniendo '¡Hola mundo!'.

Note que los tipos de dato integer y float no tienen ningún método.

Los métodos de lista reverse() y append()

El tipo de datos list también tiene métodos. El método reverse() invertirá el orden de los elementos en la lista. Intenta introducir spam = [1, 2, 3, 4, 5, 6, 'miau', 'guau'], y después spam.reverse() para invertir la lista. Entonces, introduce spam para ver los contenidos de la variable.

>>> spam = [1, 2, 3, 4, 5, 6, 'miau', 'guau']
>>> spam.reverse()
>>> spam
['guau', 'miau', 6, 5, 4, 3, 2, 1]

El método mas común de lista que usarás es append(). Este método añadirá el valor que pasas como argumento al final de la lista- Intenta introducir lo siguiente en el intérprete interactivo:

>>> huevos = []
>>> huevos.append('aerodeslizador')
>>> huevos
['aerodeslizador']
>>> huevos.append('anguilas')
>>> huevos
['aerodeslizador', 'anguilas']
>>> huevos.append(42)
>>> huevos
['aerodeslizador', 'anguilas', 42]

Estos métodos cambian las listas que los llaman. No devuelven una nueva lista. Decimos que esos métodos cambian la lista "en el sitio".

El método de lista split()

La línea 59 es una larga línea de código, pero en realidad es solamente una simple sentencia de asignación. Esta línea utiliza el método split(), que es un método del tipo de dato string, al igual que los métodos lower() y upper().

 59. palabras = 'hormiga babuino tejon murcielago oso castor camello gato almeja cobra pantera coyote cuervo ciervo perro burro pato aguila huron zorro rana cabra ganso halcon leon lagarto llama topo mono alce raton mula salamandra nutria buho panda loro paloma piton conejo carnero rata cuervo rinoceronte salmon foca tiburon oveja mofeta perezoso serpiente araña cigüeña cisne tigre sapo trucha pavo tortuga comadreja ballena lobo wombat cebra'.split()

Esta sentencia de asignación tiene solamente una larga cadena, llena de palabras separadas por espacios. Al final de la cadena hay una llamada al método split(). El método split() devuelve una lista en la que cada palabra en la cadena es un elemento aparte. La separación ocurre en cualquier lugar donde haya un espacio en la cadena.

Es fácil escribir código utilizando split(). Si lo hubieses creado desde el principio como lista, tendrías que haber escrito: ['hormiga', 'babuino', 'tejon',... y así, con comillas y comas para cada palabra.

Por ejemplo, intenta introducir lo siguiente en el intérprete interactivo:

>>> oracion = input()
Mi muy enérgica madre tan sólo nos sirvió nachos.
>>> oracion.split()
['Mi', 'muy', 'enérgica', 'madre', 'tan', 'sólo', 'nos', 'sirvió', 'nachos.']

El resultado es una lista de nueve cadenas, una cadena para una de las palabras de la cadena original, Los espacios no están incluidos en ningún elemento de la lista.

También puedes añadir tus propias palabras a la cadena en la línea 59, o eliminar cualquiera que no quieres que esté en el juego. Solamente asegurate que los espacios separan las palabras.

Como Funciona el Código

La línea 61 define la función obtenerPalabraAlAzar(). Se pasará una lista como argumento por su parámetro listaDePalabras. Esta función devolverá una palabra secreta de la lista en listaDePalabras.

 61. def obtenerPalabraAlAzar(listaDePalabras):
 62.     # Esta función devuelve una cadena al azar de la lista de cadenas pasada como argumento.
 63.     índiceDePalabras = random.randint(0, len(listaDePalabras) - 1)
 64.     return listaDePalabras[índiceDePalabras]

La línea 63 almacena un índice aleatorio para esta lista en la variable índiceDePalabras. Lo haces llamando randint() con dos argumentos. El primer argumento es 0 (para el primer índice posible) y el segundo argumento es el valor que devuelve la expresión len(listaDePalabras) - 1 (para el último índice posible en una listaDePalabras).

Los índices de lista comienzan en 0 y no en 1. Si tienes una lista de tres elementos, el índice del primer elemento es 0, el índice del segundo elemento es 1, y el índice del tercer elemento es 2. La longitud de este lista es 3, pero el índice 3 estaría después del último índice. Esta es la razón por la que en la línea 63 se resta 1 de la longitud. El código en la línea 63 funcionará sin importar el tamaño de listaDePalabras. Ahora si quieres puedes añadir o quitar cadenas a listaDePalabras.

A la variable índiceDePalabras se asignará un índice al azar para la lista pasada como el parámetro listaDePalabras. La línea 64 devolverá el elemento en listaDePalabras almacenado en el índice entero índiceDePalabras.

Supongamos que ['manzana', 'naranja', 'uva'] se pasa como argumento a obtenerPalabraAlAzar() y que randint(0, 2) devuelve el número entero 2. Eso significaría que la línea 64 devolvería listaDePalabras[2] , y entonces se evaluaría para devolver 'uva'. Así es como obtenerPalabraAlAzar() devuelve una cadena aleatoria de la lista listaDePalabras.

Así, la entrada de obtenerPalabraAlAzar() es una lista de cadenas, y la salida que devuelve es una cadena seleccionada al azar de esa lista. Esto será útil en el juego del ahorcado para seleccionar una palabra secreta que adivine el jugador.

Mostrando el tablero al Jugador

A continuación, necesitas una función para imprimir el tablero del ahorcado en pantalla. También mostrará el número de letras que el jugador ha adivinado correctamente (e incorrectamente).

 66. def mostrarTablero(IMÁGENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta):
 67.     print(IMÁGENES_AHORCADO[len(letrasIncorrectas)])
 68.     print()

Este código define una nueva función llamada mostrarTablero(). Esta función tiene cuatro parámetros:

• IMÁGENES_AHORCADO - Una lista de cadenas múlti-línea que mostrarán el tablero como arte ASCII. (La variable global IMÁGENES_AHORCADO será pasado por este parámetro.)
• letrasIncorrectas - Una cadena de las letras que el jugador ha probado que no están en la palabra secreta.
• letrasCorrectas - Una cadena de las letras que el jugador ha probado que se encuentran en la palabra secreta.
• palabraSecreta - Una cadena de la palabra secreta que el jugador está tratando de adivinar.

La primera llamada a la función print() mostrará el tablero. IMÁGENES_AHORCADO será una lista de cadenas para cada tablero posible. IMÁGENES_AHORCADO[0] muestra una horca vacía, IMÁGENES_AHORCADO[1] muestra la cabeza (cuando el jugador falla una letra), IMÁGENES_AHORCADO[2] muestra una cabeza y el cuerpo (cuando el jugador falla dos letras), y así sucesivamente hasta IMÁGENES_AHORCADO[6] que muestra al ahorcado completo.

El número de letras en letrasIncorrectas reflejará cuantos intentos incorrectos ha hecho el jugador. Llama a len(letrasIncorrectas) para averiguar este número. Así que, si letrasIncorrectas es 'aetr' entonces len ('aetr') devolverá 4. Imprimir IMÁGENES_AHORCADO[4] mostrará el tablero del ahorcado apropiado para 4 fallos. Esto es lo que devuelve IMÁGENES_AHORCADO[len(letrasIncorrectas)] en la línea 67.

 70.     print('Letras incorrectas:', end=' ')
 71.     for letra in letrasIncorrectas:
 72.         print(letra, end=' ')
 73.     print()

La línea 70 imprime la cadena 'Letras incorrectas:' con un carácter de espacio al final en lugar de un salto de línea. Recuerde que el argumento de palabra clave end=' ' utiliza sólo un signo = (como =), no dos (como ==).

La línea 71 es un nuevo tipo de bucle, llamado bucle for. Un bucle for a menudo utiliza la función range(). Ambos se explican en las dos secciones siguientes.

Las Funciones range() y list()

Cuando se llama con un argumento, range() devolverá un objeto range de números enteros desde 0 hasta (pero sin incluir) el argumento. Este objeto range se puede convertir al tipo de datos más común list con la función list(). Intenta introducir list(range(10)) en el intérprete interactivo:

>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list('Hola')
['H', 'o', 'l', 'a']

La función list() es similar a las funciones str() o int(). Toma el valor que se pasa y devuelve una lista. Es fácil generar enormes listas con la función range(). Prueba a introducir list(range(10,000)) en el intérprete interactivo:

>>> list(range(10000))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ...
      ... se omite por brevedad ...
... 9989, 9990, 9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999]

La lista es tan grande, que ni siquiera cabrá completa en la pantalla. Pero puedes almacenar la lista en una variable:

>>> spam = list(range(10000))

Si pasa dos argumentos enteros a range(), el objeto range que devuelve va desde el primer argumento entero hasta (pero sin incluir) el segundo argumento entero. Intente introducir lista (range(10, 20)) en el intérprete interactivo:

>>> list(range(10, 20))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

La función range() se utiliza a menudo en los bucles for, que son muy parecidos a los bucles while que ya has visto.

Los bucles for

El bucle for es útil para recorrer una lista de valores. Esto es diferente al bucle while, los bucles while se repiten mientras una determinada condición es True. Una sentencia for comienza con la palabra clave for, seguida por un nuevo nombre de variable, seguido por la palabra clave in, seguido por un valor iterable, y terminando con dos puntos.

Un iterable es un valor de los tipos de datos list, range, o cadena. También hay otros tipos de datos que se consideran iterables que serán presentado más adelante.

Cada vez que la ejecución del programa se repite a través del bucle a la nueva variable en la sentencia for se le asigna el valor del siguiente elemento de la lista.

>>> for i in range(5):
...     print('i se establece en ' + str(i))
...
i se establece en 0
i se establece en 1
i se establece en 2
i se establece en 3
i se establece en 4

El objeto range devuelto por range(5) es equivalente a la lista [0, 1, 2, 3, 4] en una instrucción for. La primera vez que la ejecución pasa por el código en el bloque for, se asigna 0 a la variable i. En la siguiente iteración, se asigna 1 a i, y así sucesivamente.

La sentencia for convierte automáticamente el objeto range devuelto por range() en una lista, así que no hay necesidad de hacer list(range(5)) en la sentencia for. Es suficiente con range(5).

Las listas y las cadenas son también tipos de datos iterables. Puedes usarlos en las sentencias for. Prueba a introducir lo siguiente en el intérprete interactivo:

>>> for cosa in ['gustan los gatos', 'gusta la pasta', 'gusta la programación', 'gusta el spam']:
...     print('Realmente me ' + cosa)
...
Realmente me gustan los gatos
Realmente me gusta la pasta
Realmente me gusta la programación
Realmente me gusta el spam

>>> for i in 'Hola':
...     print(i)
...
H
o
l
a

Un Bucle while equivalente a un Bucle for

El bucle for es similar al bucle while, pero sólo cuando necesitas iterar sobre los elementos de una lista, usar un bucle for es mucho menos código que escribir. Este es un bucle while que se comporta igual que el anterior bucle for mediante la adición de código extra:

>>> valorIterable = ['gustan los gatos', 'gusta la pasta', 'gusta la programación', 'gusta el spam']
>>> índice = 0
>>> While (índice < len(iterableVal)):
...     cosa = iterableVal[índice]
...     print('Realmente me ' + cosa)
...     índice = índice + 1
...
Realmente me gustan los gatos
Realmente me gusta la pasta
Realmente me gusta la programación
Realmente me gusta el spam

Pero el uso de la sentencia for hace automáticamente el código adicional y facilita la programación ya que tienes menos que escribir.

El resto de la función mostrarTablero() muestra las letras incorrectas y crea la cadena de la palabra secreta con todas las letras aún no imaginado como espacios en blanco.

 70.     print('Letras incorrectas:', end=' ')
 71.     for letra in letrasIncorrectas:
 72.         print(letra, end=' ')
 73.     print()

El bucle en la línea 71 iterará sobre cada carácter de la cadena letrasIncorrectas e los imprimirá en pantalla. Recuerde que end=' ' reemplazará el carácter de salto de línea que se imprime después de la cadena con un único carácter de espacio.

Por ejemplo, si letrasIncorrectas era 'ajtw' este bucle for mostraría a j t w.

Cortes

El corte de lista crea un nuevo valor de lista con un subconjunto de elementos de otra lista. En el código, se especifican dos índices (al inicio y final) separados por dos puntos en los corchetes después de una lista. Por ejemplo, introduce lo siguiente en el intérprete interactivo:

>>> spam = ['manzanas', 'bananas', 'zanahorias', 'fechas']
>>> spam [1: 3]
['bananas', 'zanahorias']

La expresión spam[1: 3] se evalúa a una lista con los elementos desde el índice 1 hasta (pero sin incluir) el índice 3 en spam.

Si se omite el primer índice, Python pensará automáticamente que deseas el índice 0 como primer índice:

>>> spam = ['manzanas', 'bananas', 'zanahorias', 'fechas']
>>> spam[2]
['manzanas', 'bananas']

Si se omite el segundo índice, Python pensará automáticamente que deseas el resto de la lista:

>>> spam = ['manzanas', 'bananas', 'zanahorias', 'fechas']
>>> spam [2:]
['zanahorias', 'fechas']

Cortar es una forma sencilla de obtener un subconjunto de los elementos de una lista. Utiliza cortes con cadenas en la misma forma que los utilizas con listas. Cada carácter de la cadena es como un elemento de la lista. Prueba a introducir lo siguiente en el intérprete interactivo:

>>> miNombre = 'Zophie el Gato Gordo'
>>> miNombre[4:12]
'ie el Ga'
>>> miNombre[:10]
'Zophie el '
>>> miNombre[7:]
'el Gato Gordo'

La siguiente parte del código en el ahorcado utiliza cortes.

Mostrando la Palabra Secreta con espacios en blanco

Now you want code to print the secret word, but with blank lines for the letters that have not been guessed. You can use the _ character (called the underscore character) for this. First create a string with nothing but one underscore for each letter in the secret word. Then replace the blanks for each letter in correctLetters.

So if the secret word was 'otter' then the blanked out string would be '_____' (five _ characters). If correctLetters was the string 'rt' you would change the string to '_tt_r'. Line 75 to 79 is the code that does that.

 75.     blanks = '_' * len(secretWord)

Line 75 creates the blanks variable full of _ underscores using string replication. Remember that the * operator can also be used on a string and an integer, so the expression '_' * 5 evaluates to '_____'. This will make sure that blanks has the same number of underscores as secretWord has letters.

 77.     for i in range(len(secretWord)): # replace blanks with correctly guessed letters
 78.         if secretWord[i] in correctLetters:
 79.             blanks = blanks[:i] + secretWord[i] + blanks[i+1:]

Line 77 has a for loop to go through each letter in secretWord and replace the underscore with the actual letter if it exists in correctLetters.

For example, pretend the value of secretWord is 'otter' and the value in correctLetters is 'tr'. You would want the string '_tt_r' displayed to the player. Let’s figure out how to create this string.

Line 77’s len(secretWord) call would return 5. The range(len(secretWord)) call becomes range(5), which makes the for loop iterate over 0, 1, 2, 3, and 4.

Because the value of i will take on each value in [0, 1, 2, 3, 4], the code in the for loop is the same as this:

if secretWord[0] in correctLetters:
    blanks = blanks[:0] + secretWord[0] + blanks[1:]

if secretWord[1] in correctLetters:
    blanks = blanks[:1] + secretWord[1] + blanks[2:]

if secretWord[2] in correctLetters:
    blanks = blanks[:2] + secretWord[2] + blanks[3:]

if secretWord[3] in correctLetters:
    blanks = blanks[:3] + secretWord[3] + blanks[4:]

if secretWord[4] in correctLetters:
    blanks = blanks[:4] + secretWord[4] + blanks[5:]

If you are confused as to what the value of something like secretWord[0] or blanks[3:] is, then look at Figure 9-2. It shows the value of the secretWord and blanks variables, and the index for each letter in the string.

Figure 9-2: The indexes of the blanks and secretWord strings.

If you replace the list slices and the list indexes with the values that they represent, the loop code would be the same as this:

if 'o' in 'tr': # False
    blanks = '' + 'o' + '____' # This line is skipped.

if 't' in 'tr': # True
    blanks = '_' + 't' + '___' # This line is executed.

if 't' in 'tr': # True
    blanks = '_t' + 't' + '__' # This line is executed.

if 'e' in 'tr': # False
    blanks = '_tt' + 'e' + '_' # This line is skipped.

if 'r' in 'tr': # True
    blanks = '_tt_' + 'r' + '' # This line is executed.

# blanks now has the value '_tt_r'

The above code examples all do the same thing when secretWord is 'otter' and correctLetters is 'tr'. The next few lines of code print the new value of blanks with spaces between each letter.

 81.     for letter in blanks: # show the secret word with spaces in between each letter
 82.         print(letter, end=' ')
 83.     print()

Get the Player’s Guess

The getGuess() function will be called so that the player can enter a letter to guess. The function returns the letter the player guessed as a string. Further, getGuess() will make sure that the player types a valid letter before returning from the function.

 85. def getGuess(alreadyGuessed):
 86.     # Returns the letter the player entered. This function makes sure the player entered a single letter, and not something else.

A string of the letters the player has guessed is passed as the argument for the alreadyGuessed parameter. Then the getGuess() function asks the player to guess a single letter. This single letter will be getGuess()’s return value.

 87.     while True:
 88.         print('Guess a letter.')
 89.         guess = input()
 90.         guess = guess.lower()

Line 87’s while loop will keep asking the player for a letter until they enter text that is:

1.  A single letter.
2.  A letter they have not guessed previously.

The condition for the while loop is simply the Boolean value True. That means the only way execution will ever leave this loop is by executing a break statement (which leaves the loop) or a return statement (which leaves not just the loop but the entire function).

The code inside the loop asks the player to enter a letter, which is stored in the variable guess. If the player entered a capitalized letter, it will be overwritten with a to lowercase letter on line 90.

elif (“Else If”) Statements

The next part of the Hangman program uses elif statements. You can think of elif “else if” statements as saying “If this is true, do this. Or else if this next condition is true, do that. Or else if none of them are true, do this last thing.”

Take a look at the following code:

if catName == 'Fuzzball':
    print('Your cat is fuzzy.')
elif catName == 'Spots':
        print('Your cat is spotted.')
else:
    print('Your cat is not fuzzy or spotted.')

If the catName variable is equal to the string 'Fuzzball', then the if statement’s condition is True and the if-block tells the user that their cat is fuzzy. However, if this condition is False, then Python tries the elif (“else if”) statement’s condition next. If catName is 'Spots', then the 'Your cat is spotted.' string is printed to the screen. If both are False, then the code tells the user their cat isn’t fuzzy or spotted.

You can have as many elif statements as you want:

if catName == 'Fuzzball':
    print('Your cat is fuzzy.')
elif catName == 'Spots':
    print('Your cat is spotted.')
elif catName == 'Chubs':
    print('Your cat is chubby.')
elif catName == 'Puff':
    print('Your cat is puffy.')
else:
    print('Your cat is neither fuzzy nor spotted nor chubby nor puffy.')

When one of the elif conditions is True, its code is executed and then execution jumps to the first line past the else-block. So one and only one of the blocks in the if-elif-else statements will be executed. You can also leave off the else-block if you don’t need one, and just have if-elif statements.

Making Sure the Player Entered a Valid Guess

 91.         if len(guess) != 1:
 92.             print('Please enter a single letter.')
 93.         elif guess in alreadyGuessed:
 94.             print('You have already guessed that letter. Choose again.')
 95.         elif guess not in 'abcdefghijklmnopqrstuvwxyz':
 96.             print('Please enter a LETTER.')
 97.         else:
 98.             return guess

The guess variable contains player’s letter guess. The program needs to make sure they typed in a valid guess: one and only one lowercase letter. If they didn't, the execution should loop back and ask them for a letter again.

Line 91’s condition checks if guess is not one character long. Line 93’s condition checks if guess already exists inside the alreadyGuessed variable. Line 95’s condition checks if guess is not a lowercase letter.

If all of these conditions are False, then the else statement’s block executes and getGuess() returns the value in guess on line 98.

Remember, only one of the blocks in if-elif-else statements will be executed.

Asking the Player to Play Again

100. def playAgain():
101.     # This function returns True if the player wants to play again, otherwise it returns False.
102.     print('Do you want to play again? (yes or no)')
103.     return input().lower().startswith('y')

The playAgain() function has just a print() function call and a return statement. The return statement has an expression that looks complicated, but you can break it down. Here’s a step by step look at how Python evaluates this expression if the user types in YES.

input().lower().startswith('y')
            ▼
  'YES'.lower().startswith('y')
            ▼
          'yes'.startswith('y')
            ▼
           True

The point of the playAgain() function is to let the player type in yes or no to tell the program if they want to play another round of Hangman. The player should be able to type YES, yes, Y, or anything else that begins with a “Y” in order to mean “yes”. If the player types in YES, then the return value of input() is the string 'YES'. And 'YES'.lower() returns the lowercase version of the attached string. So the return value of 'YES'.lower() is 'yes'.

But there’s the second method call, startswith('y'). This function returns True if the associated string begins with the string parameter between the parentheses, and False if it doesn’t. The return value of 'yes'.startswith('y') is True.

Now you have evaluated this expression! What it does is let the player type in a response, lowercases the response, checks if it begins with the letter 'y', then returns True if it does and False if it doesn’t.

On a side note, there’s also an endswith(someString) string method that will return True if the string ends with the string in someString and False if it doesn’t. endswith() is sort of like the opposite of startswith().

Review of the Hangman Functions

That’s all the functions we are creating for this game! Let’s review them:

• getRandomWord(wordList) will take a list of strings passed to it, and return one string from it. That is how a word is chosen for the player to guess.
• displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord) will show the current state of the board, including how much of the secret word the player has guessed so far and the wrong letters the player has guessed. This function needs four parameters passed to work correctly. HANGMANPICS is a list of strings that hold the ASCII art for each possible hangman board. correctLetters and missedLetters are strings made up of the letters that the player has guessed that are in and not in the secret word, respectively. And secretWord is the secret word the player is trying to guess. This function has no return value.
• getGuess(alreadyGuessed) takes a string of letters the player has already guessed and will keep asking the player for a letter that isn’t in alreadyGuessed.) This function returns the string of the valid letter the player guessed.
• playAgain() is a function that asks if the player wants to play another round of Hangman. This function returns True if the player does and False if the player doesn’t.

After the functions is the code for the main part of the program at line 106. Everything previous was just function definitions and a large assignment statement for HANGMANPICS.

Setting Up the Variables

106. print('H A N G M A N')
107. missedLetters = ''
108. correctLetters = ''
109. secretWord = getRandomWord(words)
110. gameIsDone = False

Line 106 is the first print() call that executes when the game is run. It displays the title of the game. Next is assigning blank strings for missedLetters and correctLetters since the player hasn’t guessed any missed or correct letters yet.

The getRandomWord(words) call will evaluate to a randomly selected word from the words list.

Line 110 sets gameIsDone to False. The code will set gameIsDone to True when it wants to signal that the game is over and should ask the player if they want to play again.

Displaying the Board to the Player

112. while True:
113.     displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord)

The while loop’s condition is always True, which means it will loop forever until a break statement is encountered. (This happens later on line 147.)

Line 113 calls the displayBoard() function, passing it the list of hangman ASCII art pictures and the three variables set on lines 107, 108, and 109. Based on how many letters the player has correctly guessed and missed, this function displays the appropriate hangman board to the player.

Letting the Player Enter Their Guess

115.     # Let the player type in a letter.
116.     guess = getGuess(missedLetters + correctLetters)

The getGuess() function needs all the letters in missedLetters and correctLetters combined, so line 116 concatenates the strings in these variables and passes the result as the argument. This argument is needed by getGuess() because the function has to check if the player types in a letter that they have already guessed.

Checking if the Letter is in the Secret Word

118.     if guess in secretWord:
119.         correctLetters = correctLetters + guess

If the guess string exists in secretWord, then concatenate guess to the end of the correctLetters string. This string will be the new value of correctLetters.

Checking if the Player has Won

121.         # Check if the player has won
122.         foundAllLetters = True
123.         for i in range(len(secretWord)):
124.             if secretWord[i] not in correctLetters:
125.                 foundAllLetters = False
126.                 break

How can the program know if the player has guessed every letter in the secret word? Well, correctLetters has each letter that the player correctly guessed and secretWord is the secret word itself. But you can’t just check if correctLetters == secretWord because consider this case: if secretWord was the string 'otter' and correctLetters was the string 'orte', then correctLetters == secretWord would be False even though the player has guessed each letter in the secret word.

The only way you can be sure the player won is to iterate over each letter in secretWord and see if it exists in correctLetters. If, and only if, every letter in secretWord exists in correctLetters will the player have won.

If you find a letter in secretWord that doesn’t exist in correctLetters, you know that the player has not guessed all the letters. The new variable foundAllLetters is set to True on line 122 before the loop begins. The loop starts out assuming that all the letters in the secret word have been found. But the loop’s code on line 125 will change foundAllLetters to False the first time it finds a letter in secretWord that isn’t in correctLetters.

127.         if foundAllLetters:
128.             print('Yes! The secret word is "' + secretWord + '"! You have won!')
129.             gameIsDone = True

If all letters in the secret word have been found, the player is told they have won and gameIsDone is set to True.

When the Player Guesses Incorrectly

130.     else:
131.         missedLetters = missedLetters + guess

This is the start of the else-block. Remember, the code in this block will execute if the condition was False. But which condition? To find out, point your finger at the start of the else keyword and move it straight up like in Figure 9-3. You’ll see that the else keyword's indentation is the same as the if keyword's indentation on line 118.

Figure 9-3: The else statement is matched with the if statement at the same indentation.

So if the condition on line 118 (guess in secretWord) was False, then the execution moves into this else-block.

Wrongly guessed letters are concatenated to the missedLetters string on line 131. This is like what line 119 did for letters the player guessed correctly.

133.         # Check if player has guessed too many times and lost
134.         if len(missedLetters) == len(HANGMANPICS) - 1:
135.             displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord)
136.             print('You have run out of guesses!\nAfter ' + str(len(missedLetters)) + ' missed guesses and ' + str(len(correctLetters)) + ' correct guesses, the word was "' + secretWord + '"')
137.             gameIsDone = True

Each time the player guesses wrong, the code concatenates the wrong letter to the string in missedLetters. So the length of missedLetters (or, in code, len(missedLetters)) is also the number of wrong guesses.

The HANGMANPICS list has 7 ASCII art strings. So when len(missedLetters) equals 6, you know the player has lost because the hangman picture will be finished. Remember, HANGMANPICS[0] is the first item in the list, and HANGMANPICS[6] is the last one.

So, when the length of the missedLetters string is equal to len(HANGMANPICS) - 1 (that is, 6), the player has run out of guesses. Line 136 prints the secret word and line 137 sets the gameIsDone variable is set to True.

139.     # Ask the player if they want to play again (but only if the game is done).
140.     if gameIsDone:
141.         if playAgain():
142.             missedLetters = ''
143.             correctLetters = ''
144.             gameIsDone = False
145.             secretWord = getRandomWord(words)

If the player won or lost after guessing their letter, the game should ask the player if they want to play again. The playAgain() function handles getting a yes or no from the player, so it is called on line 141.

If the player does want to play again, the values in missedLetters and correctLetters must be reset to blank strings, gameIsDone to False, and a new secret word stored in secretWord. This way when the execution loops back to the beginning of the while loop on line 112, the board will be back to a fresh game.

146.         else:
147.             break

If the player did not type in something that began with “y” when asked if they wanted to play again, then line 141’s condition would be False and the else-block executes. The break statement causes the execution to jump to the first instruction after the loop. But because there are no more instructions after the loop, the program terminates.

Summary

This has been a long chapter, and you’ve been introduced to several new concepts. But Hangman has been our most advanced game yet. As your games get more and more complex, it’ll be a good idea to sketch out a flow chart on paper of what happens in your program.

Lists are values that can contain other values. Methods are functions specific to a data type. Lists have append() and reverse() methods. Strings have lower(), upper(), split(), startswith(), and endswith() methods. You’ll learn about many more data types and methods in the rest of this book.

The for loop is a loop that iterates over the items in a list, unlike a while loop which iterates as long as a condition is True. The elif statement lets you add an “or else if” clause to the middle of your if-else statements. The del statement can delete variables or items inside lists.
