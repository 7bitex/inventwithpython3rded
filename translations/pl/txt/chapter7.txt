    Rozdział 7
    UŻYCIE ODPLUSKIWACZA (ang. DEBUGGER)

Tematy omówione w tym rozdziale:

•   3 różne typy błędów
•   Odpluskiwacz w IDLE
•   Praca krokowa
•   Naprzód i Wyjdź
•   Break Points

Pluskwy!

Uwaga od tłumacza: po angielsku błąd w programie jest slangowo nazywany "bug", co oznacza pluskwę, robaka.

“Dwukrotnie już zapytanie mnie: 'Niech pan powie panie Babbage, czy jeśli dostaczymy maszynie złe dane, to da ona prawidłową odpowiedź?' Nie jestem w stanie zrozumieć jakie pomieszanie pomysłów może prowadzić do takiego pytania.”
-Charles Babbage, XIX wieczny pomysłodawaca programowalnych komputerów.

Jeśli wprowadzisz zły kod, to komputer nie da co prawidłowego programu. Program komputerowy zawsze zrobi co mu kazałeś, ale to co mu kazałeś nie zawsze jest tym, co chciałeś, by program robił. Te błędy nazywamy pluskwami (ang. bug). Pluskwy zdarzają się kiedy programista nie dość uważnie przemyślał co dokładnie ma robić program. Mamy trzy typy takich błędów jakie mogą zdarzyć się w twoim programie:

•   Błędy składniowe (Syntax Errors) są błędami wynikającymi z pomyłek w trakcie pisania. Kiedy intepreter Pythona stwierdzi błąd składni, to oznacza, że twój kod nie jest napisany w prawidłowym języku Python. Programu takiego, nawet z jednym błędem składni nie da się uruchomić.
•   Błędy czasu wykonanie (ang. Runtime Errors) są błędami które zachodzą w czasie pracy programu. Program będzie pracował do czasu, aż napotka linię kody z błędem, a wtedy program zakończy się z komunikatem o błędzie (nazywamy to padem, ang. crashing). Interpreter Pythona wyświetli stos wywołań zwany z angielska “traceback” and pokaże linię w której wystąpił problem.
•   Błędy semantyczne (ang. Semantic Errors) są najtrudniejsze do naprawienia. Te błędy nie powodują padu programu, ale program robi co innego niż chciał programista. Przykładowo programista chce, by zmienna total była sumą wartości w zmiennych a, b i c, ale zamiast napisał total = a * b * c, co sprawi, że wartość w total będzie nieprawidłowa. To może doprowadzić do padu programu w przyszłości, ale na pierwszy rzut oka błąd semantyczny nie jest oczywisty.

Znalezienie błędu w programie może być trudne, o ile w ogóle go zauważysz! Kiedy uruchamiasz swój program, możesz odkryć, że czasem funkcje nie są wywoływane kiedy się tego spodziewasz, albo są wywoływane zbyt wiele razy. Mogłeś podać zły warunek w pętli while, więc wykona się ona nie tyle razy, ile zamierzałeś. Pętla z której nie ma wyjścia jest znanan pod nazwą nieskonczonej pętli (ang. infinite loop). Aby zatrzymać ten program możesz w interaktywnej powłoce nacisnąć Ctrl-C. Każda z tych rzeczy może przez pomyłkę znaleźć się w twoim kodzie jeśli nie będziesz uważny.

Sprawdźmy tworzenie nieskończonej pętli w interaktywnej powłoce przez wpisane poniższego kodu (musisz dwukrotnie nacisnąć ENTER, aby dać znać interaktywnej powłoce, że zakończyłeś wpisywanie bloku while):

>>> while True:
...     print('Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!')
...

Teraz wciśnij i przytrzymaj klawisz Ctrl i jednocześnie wciśnij C, by zatrzymać program. Interaktywna powłoka będzie wyglądała tak:

Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!
Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!
Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!
Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!
Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    while True: print('Naciśnij Ctrl-C by zatrzymać tą nieskończoną pętlę!!!')
KeyboardInterrupt

Odpluskwiacz (ang. debugger)

Znalezienie kodu który powoduje błąd może być bardzo trudne. Linie kodu wykonują się szybko a wartości w zmiennych często ulegają zmianom. Odpluskiwacz jest programem który pozwala na krokowe wykonywanie programu linia po linii w takiej samej kolejności jak robi to Python. Odpluskwiacz na każdym kroku pokazuje także wartości zmiennych.

Uruchomienie odpluskwiacza

W IDLE, otwórz grę Królestwo smoków którą stworzyłeś w ostatnim rozdziale. Po otwarciu pliku dragon.py, kliknij na Debug ► Debugger aby pojawiło się okno Debug Control (Rysunek 7-1).

Rysunek 7-1: Okno Debug Control.

Rysunek 7-2: uruchomienie Królestwa smoków w odpluskwiaczu.

Kiedy uruchomisz Królestwo smoków przez naciśnięcie F5, odpluswiacz IDLE zostanie uaktywniony. Nazywamy to uruchomieniem programu “w odpluskwiaczu” (czasem mówimy "w debuggerze"). W oknie Debug Control, sprawdź checkboksy Source i Globals.

Kiedy uruchamiasz program w odpluskwiaczu, program zatrzyma się nim wykonana zostanie pierwsza instrukcja. Gdy klikniesz w tytułowe okno edytora (i zaznaczyłeś wcześniej checkboks Source w oknie Debug Control), pierwsza instrukcja będzie podświetlona na szaro. Okno Debug Controlpokazuje, że wykonanie jest w linii 1, czyli linii z import random.

Praca krokowa

Odpluskwiacz pozwala na wykonanie pojedynczych instrukcji. Nazywamy to pracą krokową. Aby wykonać pojedynczą instrukcję kliknij przycisk Step w oknie Debug Window. Zrób to proszę. Python wykona instrukcję import random i zatrzyma się przed wykonaniem kolejnej instrukcji. Okno Debug Control pokaże, że wyknanie jest obecnie w linii 2 z import time. Kliknij przycisk Quit by zakończyć działanie programu.

Mamy tu podsumowanie tego, co dzieje się gdy klikniejsz przycisk Step z grą Królestwo smoków uruchomioną w odpluskwiaczu. Naciśnij F5 by ponownie uruchomić Królestwo smoków i wykonaj następujące polecenia:

1. import random
2. print('Rzucę monetą 1000 razy. Zgadnij ile razy wypadnie orzeł. (Naciśnij enter by rozpocząć)')
3. input()
4. flips = 0

Okno Debug Control będzie pokazywało jaka linia zostanie wykonanan po naciśnięciu przycisku Stepw oknie Debug Control. Odpluskwiacz ominie linię 3, ponieważ jest to pusta linia. Zauważ, że w odpluskwiaczu można tylko iść naprzód, nie można wrócić.

Obszar globalny (Globals Area)

Obbszar globalny w oknie Debug Control pozwala na oglądanie zmiennych globalnych. Pamiętaj, że zmienne globalne są tworzone poza funkcjami (to znaczy w zakresie globalnym).

Jako, że zostały wykonane trzy dyrektywy def które zdefiniowały funkcje, pojawią się one w oknie Debug Control w obszarze globalnym.

Napis obok nazw funkcji w obszarze globalnym wygląda jak: “<function checkCave at 0x012859B0>“. Także nazwy modułów mają tajemniczo wyglądający napis jak “<module 'random' from 'C:\\Python31\\lib\\random.pyc'>“. Nie potrzebujesz wiedzieć co to znaczy gdy odpluskwiasz swoje programy. To, że funkcje i moduły są w obszarze globalnym mówi, czy te funkcje zostały zdefiniowane, albo czy zaimportowano moduł.

Możesz także zignorować linie __builtins__, __doc__ i __name__ w obszarze globalnym. Są to zmienne jakie pojawiają się w każdym programie w Pythonie,

Kiedy zostanie stworzona zmienna playAgain, to pojawi się ona w obszarze globalnym. Obok nazwy zmiennej będzie napis 'tak'. Odpluskwiacz pozwala ci oglądać wartości wszystkich zmiennych w programie w trakcie jego wykonania. To jest bardzo użyteczne gdy naprawia się błędy.

Obszar lokalny

Mamy także obszar lokalny, gdzie pokazywane są zmienne z zasięgu lokalnego. Obszar lokalny zawiera jedynie zmienne w czasie, gdy wykonanie jest we wnętrzu funkcji. Gdy wykonanie przejdzie do zasięgu globalnego, to ten obszar jest pusty.

Przycisk Naprzód (ang. Go) i Wyjdź (ang. Quit)

Jeśli zmęczyłeś się klikając wciąż przycisk Krok (ang. Step) i chcesz by program działał normalnie, kliknij przycisk Naprzód (ang. Go)na górze okna Debug Control. Sprawi to, że program zadziała normalnie, a nie krokowo.

Aby zakończyć pracę programu po prostu kliknij przycisk Wyjdź (ang. Quit) na górze okna Debug Control. Program natychmiast się zakończy. Jest to pomocne gdy musisz rozpocząć odpluskwianie od początku programu.

Wchodzenie do, Przekraczanie i Zstępowanie

Uruchom Królestwo smoków w odpluskwiaczu. Przejdź krokowo do momentu, gdy odpluskiwacz będzie w linii 38. Jak pokazano na rysunku 7-3, jest to linia z displayIntro(). Kiedy znowu klikniesz Krok (ang. Step), to odpluskwiacz przeskosczy do tej funkcji i pokawi się w linii 5, pierwszej linii funkcji displayIntro(). Ten rodzaj pracy krokowej nazywamy wchodzeniem do. Różni się to od przechodzenia, które zaraz omówimy.

Rysunek 7-3: Przejdź krokowo, aż dotrzesz do linii 38.

Kiedy wykonanie zatrzyma się w linii 5, jeszcze jedno kliknięcie w Krok (ang. Step) spowoduje wejście do funkcji print(). Funkcja print() jest jedną z wbudowanych funkcji Pythona, więc wejście do niech przez odpluskiwacza nie jest zbyt użyteczne. Wbudowane w Pythona funkcje takie jak print(), input(), str(), lub random.randint() zostały dokłądanie sprawdzone. Możesz przyjąć, że nie powodują one błędów w twoim programie.

Nie chcesz tracić czasu na krokowe wykonywanie funkcji print(). Zamiast klikać Step by wkroczyć do wnętrza funkcji print() kliknij Over (Przekrocz). To spowoduje przejście przez funkcję print(). Kod we wnętrzu print() będzie wykonany ze zwykłą prędkością, po czym odpluskwiacz zatrzyma się jak tylko wykonanie opuści print().

Stepping over is a convenient way to skip stepping through code inside a function. The debugger will now be paused at line 40, caveNumber = chooseCave().

Click Step one more time to step into the chooseCave() function. Keep stepping through the code until line 15, the input() call. The program will wait until you type a response into the interactive shell, just like when you run the program normally. If you try clicking the Step button now, nothing will happen because the program is waiting for a keyboard response.

Click back on the interactive shell window and type which cave you want to enter. The blinking cursor must be on the bottom line in the interactive shell before you can type. Otherwise the text you type will not appear.

Once you press ENTER, the debugger will continue to step lines of code again. Click the Out button on the Debug Control window. This is called stepping out, because it will cause the debugger to step over as many lines as it needs to until execution has returned from the function it is in. After it jumps out, the execution will be on the line after the line that called the function.

For example, clicking Out inside the displayIntro() function on line 6 would step until the function returned to the line after the call to displayIntro(). Stepping out can save you from having to click Step repeatedly to jump out of the function.

If you are not inside a function, clicking Out will cause the debugger will execute all the remaining lines in the program. This is the same behavior as clicking the Go button.

Here’s a recap of what each button does:

•   Go - Executes the rest of the code as normal, or until it reaches a break point. (Break points are described later.)
•   Step - Step one instruction. If the line is a function call, the debugger will step into the function.
•   Over - Step one instruction. If the line is a function call, the debugger won’t step into the function, but instead step over the call.
•   Out - Keeps stepping over lines of code until the debugger leaves the function it was in when Out was clicked. This steps out of the function.
•   Quit - Immediately terminates the program.

Find the Bug

The debugger can help you find the cause of bugs in your program. As an example, here is a small program with a bug. The program comes up with a random addition problem for the user to solve. In the interactive shell window, click on File, then New Window to open a new file editor window. Type this program into that window, and save the program as buggy.py.

buggy.py

1. import random
2. print('Rzucę monetą 1000 razy. Zgadnij ile razy wypadnie orzeł. (Naciśnij enter by rozpocząć)')
3. input()
4. flips = 0
5. heads = 0
6. while flips < 1000:
7.     if random.randint(0, 1) == 1:
8.         heads = heads + 1
9.     flips = flips + 1

Type the program as it is above, even if you can already tell what the bug is. Then trying running the program by pressing F5. This is a simple arithmetic quiz that comes up with two random numbers and asks you to add them. Here’s what it might look like when you run the program:

What is 5 + 1?
6
Nope! The answer is 6

That’s a bug! The program doesn’t crash but it is not working correctly. The program says the user is wrong even if they type the correct answer.

Running the program under a debugger will help find the bug’s cause. At the top of the interactive shell window, click on Debug ► Debugger to display the Debug Control window. In the Debug Control window, check all four checkboxes (Stack, Source, Locals, and Globals). This makes the Debug Control window provide the most information. Then press F5 in the file editor window to run the program. This time it will be run under the debugger.

1. import random

The debugger starts at the import random line. Nothing special happens here, so just click Step to execute it. You will see the random module added to the Globals area.

2. print('Rzucę monetą 1000 razy. Zgadnij ile razy wypadnie orzeł. (Naciśnij enter by rozpocząć)')

Click Step again to run line 2. A new file editor window will appear with the random.py file. You have stepped inside the randint() function inside the random module. Python’s built-in functions won’t be the source of your bugs, so click Out to step out of the randint() function and back to your program. Then close the random.py file's window.

3. input()

Next time, you can click Over to step over the randint() function instead of stepping into it. Line 3 is also a randint() function call. Skip stepping into this code by clicking Over.

4. flips = 0

Line 4 is a print() call to show the player the random numbers. You know what numbers the program will print even before it prints them! Just look at the Globals area of the Debug Control window. You can see the number1 and number2 variables, and next to them are the integer values stored in those variables.

The number1 variable has the value 4 and the number2 variable has the value 8. When you click Step, the program will display the string in the print() call with these values. The str() function will concatenate the string version of these integers. When I ran the debugger, it looked like Rysunek 7-4. (Your random numbers will probably be different.)

Rysunek 7-4: number1 is set to 4 and number2 is set to 8.

5. heads = 0

Clicking on Step from line 5 will execute input(). The debugger waits until the player enters a response into the program. Enter the correct answer (in my case, 12) into the interactive shell window. The debugger will resume and move down to line 6.

6. while flips < 1000:
7.     if random.randint(0, 1) == 1:

Line 6 is an if statement. The condition is that the value in answer must match the sum of number1 and number2. If the condition is True, then the debugger will move to line 7. If the condition is False, the debugger will move to line 9. Click Step one more time to find out where it goes.

8.         heads = heads + 1
9.     flips = flips + 1

The debugger is now on line 9! What happened? The condition in the if statement must have been False. Take a look at the values for number1, number2, and answer. Notice that number1 and number2 are integers, so their sum would have also been an integer. But answer is a string.

That means that answer == number1 + number2 would have evaluated to '12' == 12. A string value and an integer value will always not equal each other, so the condition evaluated to False.

That is the bug in the program. The bug is that the code has answer when it should have int(answer). Change line 6 to int(answer) == number1 + number2, and run the program again.

What is 2 + 3?
5
Correct!

This time, the program worked correctly. Run it one more time and enter a wrong answer on purpose. This will completely test the program. You’ve now debugged this program! Remember, the computer will run your programs exactly as you type them, even if what you type isn’t what you intend.

Break Points

Stepping through the code one line at a time might still be too slow. Often you’ll want the program to run at normal speed until it reaches a certain line. A break point is set on a line when you want the debugger to take control once execution reaches that line. If you think there’s a problem with your code on, say, line 17, just set a break point on line 17 (or maybe a few lines before that).

When execution reaches that line, the debugger will “break into the debugger”. Then you can step through lines one at a time to see what is happening. Clicking Go will execute the program normally until it reaches another break point or the end of the program.

To set a break point, right-click on the line in the file editor and select Set Breakpoint from the menu that appears. The file editor will highlight that line with yellow. You can set break points on as many lines as you want. To remove the break point, click on the line and select Clear Breakpoint from the menu that appears.

Rysunek 7-5: The file editor with two break points set.

Example Using Break Points

Here is a program that simulates coin flips by calling random.randint(0, 1). The function returning the integer 1 will be “heads” and returning the integer 0 will be “tails”. The  flips variable will track how many coin flips have been done. The heads variable will track how many came up heads.

The program will do “coin flips” one thousand times. This would take a person over an hour to do, but the computer can do it in one second! Type in the following code into the file editor and save it as coinFlips.py. If you get errors after typing this code in, compare the code you typed to the book’s code with the online diff tool at http://invpy.com/diff/coinflips.

coinFlips.py

 1. import random
 2. print('I will flip a coin 1000 times. Guess how many times it will come up heads. (Press enter to begin)')
 3. input()
 4. flips = 0
 5. heads = 0
 6. while flips < 1000:
 7.     if random.randint(0, 1) == 1:
 8.         heads = heads + 1
 9.     flips = flips + 1
10.
11.     if flips == 900:
12.         print('900 rzutów i orzeł wypadł ' + str(heads) + ' razy.')
13.     if flips == 100:
14.         print('Mamy 100 rzutów, jak na razie orzeł wypadł ' + str(heads) + ' razy.')
15.     if flips == 500:
16.         print('Połowa za nami, a orzeł wypadł ' + str(heads) + ' razy.')
17.
18. print()
19. print('Na 1000 rzutów, orzeł wypadł ' + str(heads) + ' razy!')
20. print('Byłeś bliski?')

The program runs pretty fast. It spent more time waiting for the user to press ENTER than doing the coin flips. Let’s say you wanted to see it do coin flips one by one. On the interactive shell's window, click on Debug ► Debugger to bring up the Debug Control window. Then press F5 to run the program.

The program starts in the debugger on line 1. Press Step three times in the Debug Control window to execute the first three lines (that is, lines 1, 2, and 3). You’ll notice the buttons become disabled because input() was called and the interactive shell window is waiting for the user to type something. Click on the interactive shell window and press ENTER. (Be sure to click beneath the text in the interactive shell window, otherwise IDLE might not receive your keystrokes.)

You can click Step a few more times, but you’ll find that it would take quite a while to get through the entire program. Instead, set a break point on lines 12, 14, and 16. The file editor will highlight these lines as shown in Rysunek 7-6.

Rysunek 7-6: Three break points set.

After setting the breakpoints, click Go in the Debug Control window. The program will run at normal speed until it reaches the next break point. When flip is set to 100, the condition for the if statement on line 13 is True. This causes line 14 (where there’s a break point set) to execute, which tells the debugger to stop the program and take over. Look at the Debug Control window in the Globals section to see what the value of flips and heads are.

Click Go again and the program will continue until it reaches the next break point on line 16. Again, see how the values in flips and heads have changed.

If you click Go again, the execution will continue until the next break point is reached, which is on line 12.

Summary

Writing programs is only the first part of programming. The next part is making sure the code you wrote actually works. Debuggers let you step through the code one line at a time. You can examine which lines execute in what order, and what values the variables contain. When this is too slow, you can set break points to stop the debugger only at the lines you want.

Using the debugger is a great way to understand what a program is doing. While this book provides explanations of all the game code in it, the debugger can help you find out more on your own.
