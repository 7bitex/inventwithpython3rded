    Rozdział 4

    ZGADNIJ LICZBĘ

Tematy omówione w tym rozdziale:

•   Dyrektywa import
•   Moduły
•   Argumenty
•   Dyrektywa while
•   Warunki
•   Bloki
•   Typ logiczny (boolean)
•   Operatory porównania
•   Różnica między = i ==
•   Dyrektywa if
•   Słowo kluczowe break
•   Funkcje str() i int()
•   Funkcja random.randint()

Gra “Zgadnij liczbę”

W tym rozdziale stworzymy grę “Zgadnij numer”. Komputer wymyśli losową liczbę między 1, a 20 i poprosi, byś ją odgadł. Przy każdej próbie komputer powie, czy podana liczba jest za mała, albo zbyt duża. Wygrasz jeśli zgadniesz liczbę do szóstej próby.

To jest dobra gra ponieważ wykorzystuje liczby losowe, pętle i pobiera dane id użytkownika w dość krótkim programie. Nauczysz się jak zmieniać typ wartości (i do czego to można wykorzystać). Ponieważ program jest grą, nazwiemy użytkownika graczem, choć nazwa "użytkownik" też jest prawidłowa.

Przykładowy przebieg gry “Zgadnij liczbę”

Oto co zobaczy gracz który uruchomi grę. Tekst wpisany przez gracza jest pogrubiony.

Cześć! Jak masz na imię?
Albert
Dobrze Albert, myślę sobie o liczbie między 1 i 20.
Spróbuj ją zgadnąć.
10
Podałeś za małą liczbę.
Spróbuj ją zgadnąć.
15
Podałeś zbyt dużą liczbę.
Spróbuj ją zgadnąć.
12
Gratuluję Albert! Zgadłeś moją liczbę w 3 próbach!



Wprowadź ten kod dokładnie tak, jak tu podano i zachowaj go klikając File ► Save As (Plik ► Zapisz jako). Nazwij plik guess.py. Wciśniej F5 by uruchomić program. Nie mart się jeśli nie rozumiesz tego kodu. Wytłumaczę go krok po kroku.

Kod źródłowy zgadywania liczby

Oto kod źródłowy gry “Zgadnij liczbę”. Podczas wpisywanie tego kody w edytorze zwróć uwagę na liczbę spacji na początku niektórych linii. Niektóre linie mają cztery, lub osiem spacji wcięcia (przesunięcia).

WAŻNA UWAGA! Programy z tej książki da sie uruchomić tylko w Pythonie 3, a nie w Pythonie 2. Gdy pojawi sie okno IDLE, to na górze pojawi sie tekst “Python 3.4.0”, lub podobnie. Jeśli masz zainstalowanego Pythona 2, to możesz jednocześnie mieć Pythona 3. Aby pobrać Pythona 3, odwiedź https://python.org/download/.

Poniższy kod możesz pobrać z http://invpy.com/guess.py. Jeśli uzyskasz jakiekolwiek błedy po wpisaniu kego kodu porównaj go z kodem z książki za pomocą narzędzia jakie znajdziesz na http://invpy.com/diff/guess.

guess.py

 1. # To jest gra w zgadywanie liczby
 2. import random
 3. 
 4. probyZgadniecia = 0
 5. 
 6. print('Cześć! Jak masz na imię?')
 7. mojeImie = input()
 8. 
 9. tajemnaLiczba = random.randint(1, 20)
10. print('Dobrze ' + mojeImie + ', myślę sobie o liczbie między 1 i 20.')
11. 
12. while probyZgadniecia < 6:
13.     print('Spróbuj ją zgadnąć.') # Na początku linii są cztery spacje.
14.     podanaLiczba = input()
15.     podanaLiczba = int(podanaLiczba)
16. 
17.     probyZgadniecia = probyZgadniecia + 1
18. 
19.     if podanaLiczba < tajemnaLiczba:
20.         print('Podałeś za małą liczbę.') # Na początku linii jest osiem spacji.
21. 
22.     if podanaLiczba > tajemnaLiczba:
23.         print('Podałeś zbyt dużą liczbę.')
24. 
25.     if podanaLiczba == tajemnaLiczba:
26.         break
27. 
28. if podanaLiczba == tajemnaLiczba:
29.     probyZgadniecia = str(probyZgadniecia)
30.     print('Gratuluję ' + mojeImie + '! Zgadłeś moją liczbę w ' + probyZgadniecia + ' próbach!')
31. 
32. if podanaLiczba != tajemnaLiczba:
33.     tajemnaLiczba = str(tajemnaLiczba)
34.     print('Niestety. Numer o jakim myślałem to ' + tajemnaLiczba)

Przyjrzyjmy się każdej linii kodu by zobaczyc jak ten program działa.

Dyrektywa import

1. # To jest gra w zgadywanie liczby
2. import random
 
Pierwsza linia to komentarz. Pamiętaj, że Python zignoruje wszystko po znaku #. Ten jest po to, by przypomnieć nam co robi program.

Druga linia to dyrektywa import. Pamiętaj, że dyrektywy są instrukcjami które wykonują jakąś czynność, ale w odróżnieniu od wyrażeń nie są wyliczne do jakiejś wartości. Już widziałeś dyrektywy: dyrektywa podstawienia zachowuje wartość w zmiennej (ale dyrektywa sama w sobie nie jest wyliczana do żadnej wartości).

Choć Python ma wiele wbudowanych funkcji, niektóe funkcje są w oddzielnych programach zwanych modułami. Moduły to programy które zwawierają dodatkowe funkcje. Aby ich używać trzeba zaimportować ich moduły do własnego programu używając dyrektywy import.

Dyrektywa import to słowo kluczowe import i nazwa modułu. Linia 2 importuje moduł o nazwie random. Moduł random zawiera kilka funkcji związanych z liczbami losowymi. Jedna z takich funkcji dostarczy liczby losowej jaką będzie zgadywał użytkownik programu.

4. probyZgadniecia = 0

Ta linia tworzy nową zmienną o nazwie probyZgadniecia. Zapiszesz w niej ile razy użytkownik próbował zgadnąć liczbę. Na razie użytkownik jeszcze nie próbował, więc zapiszemy tam 0.

6. print('Cześć! Jak masz na imię?')
7. mojeImie = input()

Linia 6 i 7 są takie same jak linie w programie "Witaj świecie" z rozdziału 3. Programiści częst używają kodu z ich innych programów by zaoszczędzić nieco pracy.

Linia 6 to wywołanie funkcji print(). Pamiętaj, że funkcja to taki mini-program w środku twojego programu. Kiedy twój program wywołuje funkcję, uruchamia ten mini-program. Kod w środku funkcji print() wyświetla podany napis na ekranie.

Linia 7 pozwala użtkownikowi na podanie swojego imienia i zapisuje je w zmiennej mojeImie. (Pamiętaj, że podane imię noże nie być prawdziwym imieniem gracza. To może być dowolny tekst podany przez użytkownika. Komputery są tępe i po prostu robią to im się każe .)

Funkcja random.randint()

 9. tajemnaLiczba = random.randint(1, 20)

Linia 9 wywołuje nową funkcję o nazwie randint() i zapisuje liczbę, jaką ta funkcja zwraca. Pamiętaj, że wywołania funkcji mogą być częśćią wyrażeń ponieważ są wyliczane do wartości.

Ponieważ funkcja randint() jest w module random należy poprzedzić ją random. (nie zapomnij o kropce!), by powiedzieć Pythonowi że funkcja randint() jest w module random.

Funkcja randint() zwraca liczbę całkowitą pomiędzy (i włączając) dwoma przekazanymi jako argumenty. W linii 9 między nawiasami jakie są po nazwie funkcji mamy 1 i 20 oddzielone przecinkiem. Losowa liczba zwracana przez randint() jest zapisywana z w zmiennej tajemnaLiczba; to jest tajemnicza liczba jaką gracz będzie próbował zganąć.

Na chwilkę wróć do interaktywnej powłoki i wpis import random by zaimportować moduł random. Potem wprowadź random.randint(1, 20), by zobaczyć co ta funkcja zwróci. Będzie zwracała liczby całowite pomiędzy 1 i 20. Powtórz ten kod i wywołanie funkcji prawdopodobnie zwróci inną liczbę. Funkcja randint() zwraca jakąś liczbę losową podobniej jak rzuty kostką do grania za każdym razem zwracają liczbę losową.

>>> import random
>>> random.randint(1, 20)
12
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
3
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
7

Uzyj funkcji randint() kiedy potrzebujesz losowości w swojej grze. W większości gier użyjesz losowości. Pomyśl jak wiele gier planszowych używa kostek.

Możesz także spróbować z różnymi zakresami liczb przez zmianę argumentów. Przykładowo wpisz random.randint(1, 4) i będziesz dostawał jedynie liczby całowite z zakresu od 1 do 4 (włączając zarówno 1 jak i 4). Spróbuje też random.randint(1000, 2000) by uzyskać liczby całkowite pomiędzy 1000 i 2000. Przykładowo wprowadź w interaktywnej powłoce następujący kod. Wyniki jakie uzyskasz wywołując random.randint() prawdodpodobnie będę inne (w końcu są losowe).

>>> random.randint(1, 4)
3
>>> random.randint(1000, 2000)
1294

Możesz lekko zmienić kod gry, by gra zachowywała się nieco inaczej. Spróbuj zmienić linię 9 i 10 z:

 9. tajemnaLiczba = random.randint(1, 20)
10. print('Dobrze ' + mojeImie + ', myślę sobie o liczbie między 1 i 20.')

…na te linie:

 9. tajemnaLiczba = random.randint(1, 100)
10. print('Dobrze ' + mojeImie + ', myślę sobie o liczbie między 1 i 100.')


Teraz komputer będzie myślał o liczbie pomiędzy 1 i 100, zamiast 1 i 20. Zmiana w linii 9 zmieni zakres liczby losowej, ale pamiętaj by zmienić także linię 10 by gra pokazywała graczowi nowy zakres zamiast starego.

Przywitanie gracza

10. print('Dobrze ' + mojeImie + ', myślę sobie o liczbie między 1 i 100.')

W linii 10 funkcja print() wita gracza używając jefo imienia i mówi, że komputer wymyślił liczbę losową.

Wydawać się może, że w linii 10 jest więcej niż jeden argumen, ale spójrz na nią uważnie. Znak plus łączy trzy napisy i tworzy z nich jeden napis. To właśnie jest pojedynczym argumentem napisowym przekazanym do funkcji print(). Jak przyjrzysz się bliżej, to zobaczysz, że przecinki są wewnątrz znaków cytowania i są częścią napisów.

Pętle

12. while probyZgadniecia < 6:

Linia 12 jest dyrektywą while, która oznacza początek pętli while. Pętle pozwalają na wykonywanie kodu wiele razy. Jednak najpierw musisz nauczyć się kilku innych rzeczy nim nauczysz się o pętlach. Te rzeczy to bloki kodu, wartości typu logicznego (ang: boolean o wartości prawda, lub fałsz), operatory porównania, warunki i dyrektywa while.

Bloki kodu

Kilka linii kodu może być pogrupowane razem w kod bloku. Blok kodu ma taki same minimalną wielkość wcięcia. Możesz powiedzieć gdzie blok się zaczyna i kończy potrząc na liczbę spacji na początku linii. Te spacje to właśnie wcięcie linii.

Blok kodu zaczyna się, gdy zwiększa się wcięcie (zwykle przez użycie czterech spacji). Każda kolejna linia która jest wcięta za pomocą czterech spacji jest częścią tego bloku kodu. Blok ten kończy się, gdy wcięcie wraca do poziomu sprzed rozpoczęcia bloku. To oznacza, że w danym bloku kodu mogą istnieć inne bloki kodu.

Rysunek 4-1 to diagram kodu w blokach outlined and numbered. Spacje są oznaczone czarnymi prostokątami by było je łatwiej zliczyć.



Rysunek 4-1: Bloki i ich wcięcia. Czarne kropki oznaczają spacje.

Na rysunku 4-1, linia 12 nie ma wcięcia i nie jest w żadnym bloku. Linia 13 ma wcięcie z czterech spacji. Ponieważ wcięcie to jest większe niż wcięcie w poprzedniej linii, to znaczy, że zaczął się nowy blok kodu. Ten blok jest oznaczony (1) na rysunku 4-1. Ten blok będzie kontynuowany aż do linii bez spacji na początku (oryginalna wielkość wcięcia nim zaczął się blok). Puste linie są ignorowane.

Linia 20 ma wcięcie z ośmiu spacji. To więcej niż cztery spacje, więc zaczyna to nowy blok. Then blok jest oznaczony (2) na rysunku 4-1. Ten blok jest we wnętrzu innego bloku.

Linia 22 ma tylko cztery spacje. Ponieważ wielkość wcięcia się zmniejszyła, wiemy, że blok się zakończył. Linia 20 jest jedyną linią tego bloku. Linia 22 jest w tym samym bloku co inne linie mające cztery spacje wcięcia.

Linia 23 zwiększa wcięcie do ośmiu spacji, więc znowy zaczął się nowy blok. Jest on oznaczony (3) na rysunku 4-1.

Dla przypomnienia, linia 12 nie jest w żadnym bloku. Linie od 13 do 23 są w tym samym bloku (oznaczonym jako blok 1). Linia 20 jest w bloku w bloku (oznaczonym jako blok 2). A linia 23 jest jedyną linią kolejnego bloku w bloku (oznaczonego jako blok 3).

Typ logiczny (ang. boolean)

Typ logiczny (ang. boolean) ma tylko dwie wartości: prawda (ang. True), lub fałsz (ang. False). Te wartości wpisujemy po angielsku z użyciem dużej litery na początku. Resztę wpisujemy małymi literami. Będziesz używał wartości logicznych z operatorami porównywania by tworzyć warunki. Warunki będą omówione później.

Jak na razie zostałeś wprowadzony do typów liczb całkowitych, liczb zmiennoprzeninkowych, napisów i teraz typu logicznego.

Operatory porównania

Linia 12 ma dyrektywę while:

12. while probyZgadniecia < 6:

Wyrażenie które następuje po słowie kluczowym while (część probyZgadniecia < 6) zawiera dwie wartości (wartość w zmiennej probyZgadniecia i liczbę całkowitą 6) połączone operatorem (znak <, czyli znak “mniejsze niż”). Znak < jest nazywany operatorem porównania.

Operatory porównania porównują dwie wartości i wyliczają z nich prawdę, lub fałsz (wartości logiczne True, lub False). Lista wszystkich operatorów porównania jest w tabeli  4-1.

Tabela 4-1: Operatory porównania.
Znak operatora      Nazwa operatora
<                   Mniejsze niż
>                   Większe niż
<=                  Mniejsze niż, lub równe z
>=                  Większe niż, lub równe z
==                  Równe z
!=                  Różne od

Czytałeś już o operatorach matematycznych: +, -, * i /. Podobnie do innych operatorów, operatory porównania robią operacje z wartościami by zbudować wyrażenie takie jak probyZgadniecia < 6.

Warunki

Warunek to wyrażenie składające się z dwóch wartości z operatorem porównania (takim jak <, lub >) i który zostaje wyliczony do wartości logicznej. Warunek jest po prostu inną nazwą na wyrażenie jakie zostanie wyliczone do wartości True, lub False. Warunki są używane w dyrektywach while (i w kilku innych miejscach, ale o tym później).

Przykładowo, wyrażenie probyZgadniecia < 6 pyta, “czy wartość zapisana w probyZgadniecia jes mniejsza niż liczba 6?” Jeśli tak, to wyrażenie daje wartość True (prawda). Jeśli nie, to wyrażenie daje wartość False (fałsz).

W przypadku programu “Zgadnij numer”, w linii 4 zapisałeś wartość 0 do zmiennej probyZgadniecia. Ponieważ 0 jest mniejsze niż 6, to to wyrażenie daje wartość logiczną True. The wyliczanie wygląda tak:

probyZgadniecia < 6
                ▼
              0 < 6
                ▼
              True

Eksperymenty z wartościami logicznymi, operatorami porównania i warunkami

Wprowadź następujące wyrażenia w interaktywnej powłoce by sprawdzić ich wyniki jako wartości logiczne:

>>> 0 < 6
True
>>> 6 < 0
False
>>> 50 < 10
False
>>> 10 < 11
True
>>> 10 < 10
False

Warunek 0 < 6 zwraca wartość logicznną True ponieważ liczba 0 jest mniejsza niż liczba 6. Ale ponieważ 6 nie jest mniejsze od 0, to warunek 6 < 0 wylicza się do False. 50 nie jest mniejsze od 10, więc 50 < 10 daje False. 10 jest mniejsze od 11, więc 10 < 11 daje True.

Zauważ, że 10 < 10 daje False ponieważ 10 nie jest mniejsze od 10. One są równe. Jeśli Alicja jest tak samo wysoka jak Franek, to nie powiesz, że Alicja jest wyższa od Franka, albo że Alicja jest niższa od Franka. Oba te wyrażenia są fałszywe.

Teraz spróbuj wprowadzić kolejne wyrażenia w interaktywnej powłoce:

>>> 10 == 10
True
>>> 10 == 11
False
>>> 11 == 10
False
>>> 10 != 10
False
>>> 10 != 11
True
>>> 'Hello' == 'Hello'
True
>>> 'Hello' == 'Goodbye'
False
>>> 'Hello' == 'HELLO'
False
>>> 'Goodbye' != 'Hello'
True

Nie należy mylić operatora podstawienia (=) i operatora “równe z” (==). Znak równości (=) jest używany w dyrektywach podstawienia by zapisać wartość w zmiennej, podczas gdy podwójny znak równości (==) jest używany w wyrażeniach, by sprawdzić, czy dwie wartości są równe. Łatwo pomyłkowo użyć jednego z nich, gdy naprawdę chce się użyc drugiego.

Po prostu pamiętaj, że operator “równe z” (==) używa dwóch znaków, podobnie jak operator “różne od” (!=), który również używa dwóch znaków.

Napisy i liczby całkowite nie będą równe. Sprawdź to wpisując następujący kod w powłoce interaktywnej:

>>> 42 == 'Hello'
False
>>> 42 != '42'
True

Pętle używające dyrektywy while

Dyrektywa while oznacza początek pętli. Pętle wykonują ten sam kawałek kodu wielokrotnie. Kiedy wykonanie programu dojdzie do dyrektywy while, to sprawdzany jest warunek wpisany zaraz po słowie kluczowym while. Jeśli ten warunek zwróci True, to wykoananie wchodzi do wnętrza bloku while (w twoim programie blok while zaczyna się w linii 13). Jeśli warunek zwróci False, to wykonanie przejdzie poza blok while (w “Zganij numer” pierwsza linia za blokiem while to linia 28).

Dyrektywa while zawsze ma dwukropek (znak : ) za warunkiem.

12. while probyZgadniecia < 6:



Rysunek 4-2: Warunek pętli while

Rysunek 4-2 pokazuje jak w zależności od warunku przebiega wykonanie kodu. Jeśli warunek zwraca True (co dzieje sie za pierwszym razem, ponieważ wartość probyZgadniecia wynosi 0), wykonanie wejdzie do bloku while w linii 13 i do kolejnych linii. Jak tylko program dotrze do końca bloku while, to zamiast iść dalej, do kolejnej linii, program zapętli się, wróci do linii z dyrektywą while (linia 12) i pownownie sprawdzi warunek. Podobnie jak wcześniej, jeśi warunek zwróci True wykonanie wchodzi do bliku while. Każde wykonanie kodu w pętli nazwyamy iteracją.

W ten sposób działają pętle. Jak długo warunek jest spełniony (zwraca True), program będzie wykonywał kod we wnętrzu bloku while, a zakończy gdy pierwszy raz warunek przestanie być spełniany (zwróci False). Myśl o  dyrektywie while jako: “dopóki warunek jest spełniony wykonuj kod w tym bloku”.

Kod wewnątrz bloku while obsługuje pobieranie zgadywanych liczb od użytkownika i sprawdzanie, czy podana liczba jest większa, mniejsza, czy równa tajemnej liczbie. Możesz zmienić trudność gry zmieniając liczbę możliwych prób zgadywania. Aby dać graczowi tylko cztery szanse zmień linię:

12. while probyZgadniecia < 6:

w linię:

12. while probyZgadniecia < 4:

Kod w bloku while w każdej iteracji zwiększa zmienną probyZgadniecia o 1. Ustawiając warunek probyZgadniecia < 4 sprawisz, że kod wewnątrz pętli wykona się cztery razy, a nie sześć. To sprawi, że gra będzie trudniejsza. Aby zrobić ją łatwiejszą ustaw warunek naprobyZgadniecia < 8, lub probyZgadniecia < 10. To sprawi, że pętla wykona się kilka razy więcej i przyjmie więcej prób zgadnięcia od gracza.

Oczywiście jeśli usuniesz linię 17 (probyZgadniecia = probyZgadniecia + 1) to zmienna probyZgadniecia nigdy nie zostanie zwiększona. Warunek pętli while zawsze będzie spełniony (True)! To da graczowi nielimitowaną liczbę prób zgadnięcia. Graczowi może się to podobać, ale programista uważa to za błąd (ang. bug).

The Player Guesses

Lines 13 to 17 ask the player to guess what the secret number is and let them enter their guess. That number is stored in a variable named guess.

13.     print('Take a guess.') # There are four spaces in front of print.
14.     guess = input()

Converting Strings to Integers with the int() function

15.     guess = int(guess)

In line 15, you call a new function called int(). The int() function takes one argument and returns an integer value form that argument. Try entering the following into the interactive shell:

>>> int('42')
42
>>> int(42)
42
>>> int('forty-two')
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
int('forty-two')
ValueError: invalid literal for int() with base 10: 'forty-two'
>>> 3 + int('2')
5

The int('42') call will return the integer value 42. The int(42) call will do the same (though it is kind of pointless to get an integer value form of an integer value). However, even though you can pass a string to the int() function, you cannot pass just any string. Passing 'forty-two' to int() will result in an error. The string you pass to int() must be made up of numbers.

The 3 + int('2') line shows an expression that uses the return value of int() as part of an expression. It evaluates to the integer value 5:

3 + int('2')
  ▼
3 + 2
  ▼
  5

Remember, the input() function returns a string of text the player typed. If the player types 5, the input() function will return the string value '5', not the integer value 5. Python cannot use the < and > comparison operators to compare a string and an integer value:

>>> 4 < '5'
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    4 < '5'
TypeError: unorderable types: int() < str()

On line 14 the guess variable originally held the string value of what the player typed. Line 15 overwrites the string value in guess with the integer value returned by int(). This lets the code later in the program compare if guess is greater than, less than, or equal to the secret number in the number variable. Python cannot compare a string value with an integer value to see if one is greater or less than the other, even if that string value is something like '5'.

One last thing: Calling int(guess) doesn’t change the value in the guess variable. The code int(guess) is an expression that evaluates to the integer value form of the string stored in the guess variable. What changes guess is the assignment statement: guess = int(guess)

Incrementing Variables

17.     guessesTaken = guessesTaken + 1

Once the player has taken a guess, the number of guesses should be increased by one.

On the first iteration of the loop, guessesTaken has the value of 0. Python will take this value and add 1 to it. 0 + 1 evaluates to 1, which is stored as the new value of guessesTaken. Think of line 17 as meaning, “the guessesTaken variable should be one more than what it already is”.

Adding one to a variable’s integer or float value is incrementing the variable. Subtracting one from a variable’s integer or float value is decrementing the variable.

if statements

Is the Player’s Guess Too Low?

19.     if guess < number:
20.          print('Your guess is too low.') # There are eight spaces in front of print.

Line 19 checks if the player’s guess is less than the computer’s secret number. If so, then the execution moves to line 20 and prints a message telling the player this. Line 19 is an if statement. The execution will run the code in the following block if the if statement’s condition evaluates to True. If the condition is False, then the code in the if-block is skipped. Using if statements, you can make the program only run certain code when you want it to.

The if statement works almost the same as a while statement, too. But unlike the while-block, the execution doesn’t jump back to the if statement at the end of the if-block. It just continues down to the next line. In other words, if statements don’t loop. See Rysunek 4-3 for a comparison of the two statements.



Rysunek 4-3: if and while statements.

Is the Player’s Guess Too High?

22.     if guess > number:
23.          print('Your guess is too high.')

Line 22 checks if the player’s guess is greater than the random integer. If this condition is True, then the print() function call tells the player that their guess is too big.

Leaving Loops Early with the break statement

25.     if guess == number:
26.          break

The if statement on line 25 checks if the guess is equal to the random integer. If it is, the program runs the break statement on line 26.

A break statement tells the execution to jump immediately out of the while-block to the first line after the end of the while-block. (The break statement doesn’t bother rechecking the while loop’s condition, it just breaks out of the loop immediately.)

The break statement is just the break keyword by itself, with no condition or colon.

If the player’s guess isn’t equal to the random integer, the execution reaches the bottom of the while-block. This means the execution will loop back to the top and recheck the condition on line 12 (guessesTaken < 6). Remember after the guessesTaken = guessesTaken + 1 line of code executed, the new value of guessesTaken is 1. Because 1 < 6 is True, the execution enters the loop again.

If the player keeps guessing too low or too high, the value of guessesTaken will change to 2, then 3, then 4, then 5, then 6. When guessesTaken has the number 6 stored in it, the while statement’s condition is False, since 6 isn’t less than 6. Because the while statement’s condition is False, the execution moves to the first line after the while-block.

If the player guessed the number correctly, the break statement would move the execution to the first line after the while-block.

The remaining lines of code run when the player has finished guessing, either because the player guessed the correct number or run out of guesses.

Check if the Player Won

28. if guess == number:

Line 28 has no indentation, which means the while-block has ended and this is the first line after the while-block. The execution left the while-block either because the while statement’s condition was False (when the player runs out of guesses) or the break statement executed (when the player guesses the number correctly). Line 28 checks to see if the player guessed correctly. If so, the execution enter the if-block at line 29.

29.     guessesTaken = str(guessesTaken)
30.     print('Good job, ' + myName + '! You guessed my number in ' + guessesTaken + ' guesses!')

Lines 29 and 30 only execute if the condition in the if statement on line 28 was True (that is, if the player correctly guessed the computer’s number).

Line 29 calls the new function str(), which returns the string form of an argument. This code gets the string form of the integer in guessesTaken since only strings concatenate strings together.

Line 30 concatenates strings together to tell the player they have won and how many guesses it took them. Only string values can concatenate to other strings. This is why line 29 had to change guessesTaken to the string form. Otherwise, trying to concatenate a string to an integer would cause Python to display an error.

Check if the Player Lost

32. if guess != number:

Line 32 uses the comparison operator != to check if player’s last guess is not equal to the secret number. If this condition evaluates to True, the exeution moves into the if-block on line 33.

Lines 33 and 34 are inside the if-block, and only execute if the condition on line 32 was True.

33.     number = str(number)
34.     print('Nope. The number I was thinking of was ' + number)

In this block, the program tells the player what the secret number they failed to guess correctly was. This requires concatenating strings, but number stores an integer value. Line 33 will replace number with a string form so that it can be concatenated to the 'Nope. The number I was thinking of was ' string on line 34.

At this point, the execution has reached the end of the code, and the program terminates. Congratulations! You’ve just programmed your first real game!

Flow Control Statements

In previous chapters, the program execution started at the top instruction in program and went straight down, executing each instruction in order. But with the while, if, else, and break statements, you can cause the execution to loop and skip instructions based on conditions. The name for these kinds of statements is flow control statement, since they change the “flow” of the program execution as it moves around your program.

Summary

If someone asked you, “What exactly is programming anyway?” what could you say to them? Programming is just the action of writing code for programs, that is, creating programs that can be executed by a computer.

“But what exactly is a program?” When you see someone using a computer program (for example, playing your “Guess the Number” game), all you see is some text appearing on the screen. The program decides what exact text to show on the screen (the program’s output), based on its instructions and on the text that the player typed on the keyboard (the program’s input). A program is just a collection of instructions that act on the user’s input.

“What kind of instructions?” There are only a few different kinds of instructions, really.

1.  Expressions. Expressions are values connected by operators. Expressions are all evaluated down to a single value, as 2 + 2 evaluates to 4 or 'Hello' + ' ' + 'World' evaluates to 'Hello World'. When expressions are next to the if and while keywords, you also call them conditions.
2.  Assignment statements. Assignment statements store values in variables so you can remember the values later in the program.
3.  The if, while, and break flow control statements. Flow control statements can cause the flow to skip instructions, loop over instructions, or break out of loops. Function calls also change the flow of execution by jumping to the start of a function.
4.  The print() and input() functions. These functions display text on the screen and get text from the keyboard. This is called I/O (pronounced like the letters, “eye-oh”), because it deals with the Input and Output of the program.

And that’s it, just those four things. Of course, there are many details about those four types of instructions. In this book you’ll learn about new data types and operators, new flow control statements, and many other functions that come with Python. There are also different types of I/O such as input from the mouse or outputting sound and graphics instead of just text.

For the person using your programs, they only care about that last type, I/O. The user types on the keyboard and then sees things on the screen or hears things from the speakers. But for the computer to Rysunek out what sights to show and what sounds to play, it needs a program, and programs are just a bunch of instructions you, the programmer, have written.

