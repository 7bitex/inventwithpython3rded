    Bab 6
    ALAM NAGA

Cakupan topik dalam Bab ini:

•   Modul time
•   Fungsi time.sleep()
•   Keyword return
•   Membuat fungsi baru dengan keyword def
•   Boolean operators Operator Boolean and dan or
•   Tabel kebenaran
•   Cakupan variabel (Global dan Local)
•   Parameter dan argumen
•   Diagram alur

Memperkenalkan Fungsi-Fungsi

Sejauh ini kamu telah menggunakan beberapa fungsi: print(), input(), random.randint(), str(), dan int(). Kamu telah memanggil fungsi-fungsi tersebut untuk menjalankan kode di dalamnya. Dalam bab ini, kamu akan menulis sendiri fungsi-fungsi sendiri yang akan dipanggil oleh program buatanmu. Sebuah fungsi mirip seperti program mini dalam sebuah program. Fungsi membuatmu dapat menjalankan sebuah kode berulang kali tanpa harus melakukan copy-paste kode tersebut dalam kode sumber. Sebaliknya, kamu dapat menaruh kode tersebut dalam sebuah fungsi dan memanggil fungsi tersebut berkali-kali. Ini memberikan keuntungan ketika terjadi kesalahan pada kode sebuah fungsi. Kamu hanya perlu mengubah kode fungsi tersebut.

Game yang akan kamu buat pada bab ini bernama "Alam Naga". Pemain akan memilih diantara dua gua dimana dapat berisi harta karun atau kematian bagi pemain.

Bagaimana Cara Memainkan "Alam Naga"

Dalam game ini pemain berada dalam sebuah dunia penuh dengan naga. Naga-naga hidup dalam gua yang penuh dengan tumpukan harta karun. Ada beberapa naga yang jinak dan mau berbagi harta karun denganmu. Namun ada juga naga-naga yang lapar dan akan memakan siapapun yang memasuki gua mereka. Pemain berada di antara dua gua: satu gua berisi naga jinak dan lainnya berisi naga kelaparan. Pemain harus memilih salah satu dari dua gua tersebut.

Bukalah sebuah jendela file editor baru dengan mengeklik File - New Window. Pada jendela yang kosong, ketikkan kode sumber dan simpan sebagai dragon.py. Kemudian jalankan programnya dengan menekan F5.

Contoh Alur Alam Naga

Kamu ada di pulau yang dihuni banyak naga. Di depanmu,
kamu melihat dua gua. Di salah satu gua dihuni oleh naga ramah
dan mau berbagi harta karun bersamamu. Naga lain
tamak dan lapar. Kamu bisa dimakan olehnya jika terlihat.
Gua mana yang ingin kau jelajahi? (1 atau 2)
1
Kamu memasuki gua...
Gua ini gelap dan menakutkan...
Naga besar lompat didepanmu! Dia membuka mulutnya dan...
Mengunyahmu dalam satu gigitan!
Mau main lagi? (ya atau tidak)
tidak

Kode Sumber Alam Naga

Satu hal yang perlu kamu ketahui ketika membaca kode di bawah ini: Blok-blok setelah baris-baris def mendefinisikan sebuah fungsi. Ini berbeda dari menjalankan kode. Potongan kode tersebut tidak akan dijalankan hingga fungsi tersebut dipanggil. Kamu akan membaca lebih banyak mengenai pemanggilan fungsi di bab ini.

PERLU DIPERHATIKAN! Program-program dalam buku ini hanya dapat dijalankan di Python 3. Kamu dapat melihat versi Python yang kamu gunakan dengan melihat angka versi pada jendela IDLE. Jika kamu telah memiliki instalasi Python 2, kamu dapat memiliki instalasi Python 3 dalam satu komputer secara bersamaan. Silakan buka https://python.org/download untuk mengunduh Python 3.

Jika kamu mendapatkan error setelah mengetikkan kode dalam kode sumber berikut, coba bandingkan dengan kode sumber pada buku melalui perangkat diff online di http://invpy.com/diff/naga

naga.py
 1. import random
 2. import time
 3.
 4. def displayIntro():
 5.     print('Kamu ada di pulau yang dihuni banyak naga. Di depanmu,')
 6.     print('kamu melihat dua gua. Di salah satu gua dihuni oleh naga ramah')
 7.     print('dan mau berbagi harta karun bersamamu. Naga lain')
 8.     print('tamak dan lapar. Kamu bisa dimakan olehnya jika terlihat.')
 9.     print()
10.
11. def chooseCave():
12.     cave = ''
13.     while cave != '1' and cave != '2':
14.         print('Gua mana yang ingin kau jelajahi? (1 atau 2)')
15.         cave = input()
16.
17.     return cave
18.
19. def checkCave(chosenCave):
20.     print('Kamu memasuki gua...')
21.     time.sleep(2)
22.     print('Gua ini gelap dan menakutkan...')
23.     time.sleep(2)
24.     print('Naga besar lompat didepanmu! Dia membuka mulutnya dan...')
25.     print()
26.     time.sleep(2)
27.
28.     friendlyCave = random.randint(1, 2)
29.
30.     if chosenCave == str(friendlyCave):
31.          print('Memberimu harta karunnya!')
32.     else:
33.          print('Mengunyahmu dalam satu gigitan!')
34.
35. playAgain = 'ya'
36. while playAgain == 'ya' or playAgain == 'y':
37.
38.     displayIntro()
39.
40.     caveNumber = chooseCave()
41.
42.     checkCave(caveNumber)
43.
44.     print('Mau main lagi? (ya atau tidak)')
45.     playAgain = input()

Bagaimana Kode Bekerja

Mari lihat kode sumber dengan lebih teliti.

 1. import random
 2. import time

Program ini melakukan impor terhadap dua modul. Modul random akan menyediakan fungsi random.randint() seperti yang telah dilakukan dalam gim "Tebak Angka". Kamu juga akan membutuhkan fungsi-fungsi yang berhubungan dengan waktu. Oleh karena itu, imporlah juga modul time.

Pernyataan-pernyataan def

 4. def displayIntro():
 5.     print('Kamu ada di pulau yang dihuni banyak naga. Di depanmu,')
 6.     print('kamu melihat dua gua. Di salah satu gua dihuni oleh naga ramah')
 7.     print('dan mau berbagi harta karun bersamamu. Naga lain')
 8.     print('tamak dan lapar. Kamu bisa dimakan olehnya jika terlihat.')
 9.     print()

Baris 4 adalah pernyataan def. Pernyataan def membuat, atau mendefinisikan, sebuah fungsi baru yang dapat kamu panggil di lain waktu pada program. Setelah kamu mendefinisikan fungsi, kamu dapat memanggilnya seperti kamu memanggil fungsi-fungsi lainnya. Ketika kamu memanggil fungsi, program akan menjalankan kode-kode dalam def-block.

Gambar 6-1 menampilkan bagian-bagian dari sebuah pernyataan def. Terdapat keyword def diikuti dengan nama fungsi dengan tanda kurung dan tanda titik dua (:). Blok setelah pernyataan def disebut sebagai def-block.

Gambar 6-1: Bagian-bagian sebuah pernyataan def.

Perlu diingat bahwa pernyataan def tidak menjalankan kode. Pernyataan def hanya mendefinisikan kode-kode apa yang akan dijalankan ketika fungsi dipanggil. Ketika eksekusi program mencapai pernyataan def, alur eksekusi program akan berpindah ke baris pertama setelah def-block.

Tapi ketika fungsi displayIntro() dipanggil (seperti pada baris 38), eksekusi program berpindah ke dalam fungsi displayIntro() pada baris pertama def-block.

38.     displayIntro()

Semua pemanggilan print() akan dijalankan dan teks pengantar 'Kamu ada di pulau yang dihuni banyak naga...' akan ditampilkan.

Meletakkan Definisi Fungsi-Fungsi

Sebuah pernyataan def sebuah fungsi dan blok def miliknya harus dibuat terlebih dahulu sebelum fungsi tersebut dapat dipanggil. Ini seperti kamu harus memasukkan sebuah nilai pada variabel terlebih dahulu sebelum kamu dapat menggunakannya. Jika kamu meletakkan pemanggilan fungsi sebelum fungsi tersebut didefinisikan, maka kamu akan mendapatkan error. Coba perhatikan kode berikut:

sayGoodbye()

def sayGoodbye():
    print('Goodbye!')

Jika kamu mencoba menjalankannya, Python akan memberikan pesan error yang terlihat seperti ini:

Traceback (most recent call last):
  File "C:\Python34\spam.py", line 1, in <module>
sayGoodbye()
NameError: name 'sayGoodbye' is not defined

Untuk membetulkannya, letakkan definisi fungsi sebelum pemanggilan fungsi:

def sayGoodbye():
    print('Goodbye!')

sayGoodbye()

Mendefinisikan Fungsi chooseCave()

11. def chooseCave():

Disini kamu mendefinisikan sebuah fungsi lain bernama chooseCave(). Fungsi ini meminta pemain untuk memilih antara gua 1 atau gua 2 untuk dijelajahi.

12.     cave = ''
13.     while cave != '1' and cave != '2':

Kode ini dibutuhkan untuk menjamin pemain hanya memasukkan 1 atau 2, dan bukan lainnya. Sebuah perulangan disini akan terus meminta pemain hingga ia memasukkan salah satu masukan yang sah.

Baris 12 membuat variabel baru bernama cave dan menyimpan sebuah string kosong di dalamnya. Kemudian sebuah perulangan while mulai pada baris 13. Kondisinya mengandung sebuah operator yang belum pernah kamu lihat sebelumnya, yaitu operator and. Sama seperti - atau * yang berupa operator matematika, dan == atau != yang berupa operator perbandingan, and merupakan sebuah operator Boolean.

Operator-Operator Boolean

Logika Boolean berhubungan dengan hal-hal yang bernilai Benar (True) atau Salah (False). Operator-operator Boolean membandingkan dua nilai Boolean dan dievaluasi menjadi nilai Boolean tunggal. Operator Boolean and menggabungkan dua nilai Boolean untuk menghasil sebuah nilai Boolean baru.

Misalkan terdapat sebuah kalimat "Kucing memiliki kumis dan anjing memiliki ekor." "Kucing memiliki kumis" adalah benar, begitu pula dengan "anjing memiliki ekor." Oleh karena itu, keseluruhan kalimat "Kucing memiliki kumis dan anjing memiliki ekor" adalah benar.

Namun pada kalimat "Kucing memiliki kumis dan anjing memiliki sayap" adalah salah. Walaupun "Kucing memiliki kumis" adalah benar, anjing tidak memiliki sayap. Makanya "anjing memiliki sayap" adalah salah. Dalam logika Boolean, suatu hal hanya akan sepenuhnya bernilai benar (true) atau salah (false). Karena ada kata "and", keseluruhan kalimat hanya akan benar jika masing-masing bagiannya benar. Jika salah satu atau kedua-duanya salah, maka keseluruhan kalimat adalah salah.

Operator and dan or

Operator and di Python berlaku sama layaknya kata and di logika Boolean. Jika nilai Boolean di masing-masing sisi pada keyword and bernilai True, maka ekspresi dengan operator and dievaluasi menjadi True. Jika salah satu nilai Boolean bernilai False atau masing-masing nilai Boolean bernilai False, maka ekspresi dievaluasi menjadi False.

Coba masukkan ekspresi-ekspresi dengan operator and berikut ke dalam shell interaktif:

>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False
False
>>> 10 < 20 and 'Hello' == 'Hello'
True

Operator or mirip seperti operator and, kecuali dia akan dievalusi menjadi True ketika salah satu dari dua nilai Boolean bernilai True. Satu-satunya waktu operator or dievaluasi menjadi False adalah ketika masing-masing nilai Boolean bernilai False.

Coba masukkan ekspresi-ekspresi berikut ke dalam shell interaktif:

>>> True or True
True
>>> True or False
True
>>> False or True
True
>>> False or False
False
>>> 10 > 20 or 20 > 10
True

Operator not

Operator not hanya bekerja pada sebuah nilai, bukan dengan menggabungkan dua nilai. Operator not akan dievaluasi menghasilkan nilai kebalikan dari suatu nilai Boolean. Ekspresi not True akan dievaluasi menjadi False, dan not False akan dievaluasi menjadi True.

Coba masukkan ekspresi-ekspresi berikut ke dalam shell interaktif:

>>> not True
False
>>> not False
True
>>> not 'black' == 'white'
True

Tabel Kebenaran

Jika kamu lupa bagaimana operator-operator Boolean bekerja, kamu dapat melihat pada tabel-tabel berikut yang disebut sebagai tabel kebenaran:

Tabel 6-1: Tabel Kebenaran Operator and
A       and B       Adalah  Keseluruhan pernyataan
True    and True    Adalah  True
True    and False   Adalah  False
False   and True    Adalah  False
False   and False   Adalah  False

Tabel 6-2: Tabel Kebenaran Operator or
A       or B       Adalah  Keseluruhan pernyataan
True    or True    Adalah  True
True    or False   Adalah  True
False   or True    Adalah  True
False   or False   Adalah  False

Tabel 6-3: Tabel Kebenaran Operator not
not A       adalah  Keseluruhan pernyatan
not True    adalah  False
not False   adalah  True

Mengevaluasi Operator-Operator Boolean

Lihat kembali baris 13:

13.     while cave != '1' and cave != '2':

Kondisi di atas memiliki dua bagian yang dihubungkan dengan sebuah operator Boolean and. Kondisinya bernilai True hanya jika kedua bagiannya bernilai True.

Pertama kalinya kondisi dalam pernyataan while dicek, cave bernilai string kosong ''. String kosong tidak sama dengan string '1', maka sisi kiri kondisi dalam while dievaluasi menjadi True. String kosong juga tidak sama dengan string '2', maka sisi kanan kondisi juga dievaluasi menjadi True.

Pada akhirnya, kondisi dalam pernyataan while menjadi True dan True. Karena kedua nilai Boolean bernilai true dan dievaluasi menggunakan operator and, maka hasilnya menjadi True. Oleh karena itu, eksekusi program masuk ke dalam blok while.

Ini merupakan gambaran bagaimana proses evaluasi dalam kondisi (jika nilai dalam cave berupa string kosong):

while cave != '1' and cave != '2':
                   ▼
while  ''  != '1' and cave != '2':
                   ▼
while     True    and cave != '2':
                   ▼
while     True    and  ''  != '2':
                   ▼
while     True    and     True:
                   ▼
while             True:

Mendapatkan Masukan dari Pemain

13.     while cave != '1' and cave != '2':
14.         print('Gua mana yang ingin kau jelajahi? (1 atau 2)')
15.         cave = input()

Baris 14 meminta pemain untuk memilih gua. Baris 15 memungkinkan pemain untuk mengetikkan respon dan menekan ENTER. Respon ini kemudian disimpan dalam variabel cave. Setelah kode ini dijalankan, eksekusi program berulang kembali ke atas pernyataan while dan mengecek kembali kondisi.

Jika pemain memasukkan 1 atau 2, maka cave akan bernilai antara 1 atau 2. Ini akan menyebabkan kondisi False dan eksekusi program akan berlanjut melewati perulangan while. Sebagai contoh, jika pengguna memasukkan '1', maka evaluasinya akan terlihat seperti ini:

while cave != '1' and cave != '2':
                   ▼
while  '1' != '1' and cave != '2':
                   ▼
while     False   and cave != '2':
                   ▼
while     False   and  '1' != '2':
                   ▼
while     False   and     True:
                   ▼
while            False:

Namun jika pemain memasukkan 3 atau 4 atau HELLO, respon tersebut tidak sah. Kondisinya akan tetap True dan kembali ke blok while untuk meminta kembali pada pemain. Program akan tetap meminta pemain hingga pemain memasukkan 1 atau 2. Ini akan menjamin eksekusi akan berlanjut ketika variabel cave mengandung respon yang sah.

Nilai Kembalian

17.     return cave

Ini merupakan pernyataan return yang hanya akan muncul dalam blok-blok def.  Ingat bagaimana fungsi input() mengembalikan sebuah nilai string yang dimasukkan oleh pemain? Fungsi chooseCave() juga akan mengembalikan sebuah nilai. Baris 17 mengembalikan string yang tersimpan dalam cave, yaitu antara '1' atau '2'.

Ketika pernyataan return dijalankan, eksekusi program langsung loncat keluar blok def. (Ini seperti bagaimana pernyataan break akan membuat eksekusi program loncat keluar blok while.) Eksekusi program kemudian berpindah kembali ke baris dengan pemanggilan fungsi. Pemanggilan fungsi tersebut akan menghasilkan sebuah nilai kembalian.

Coba perhatikan sebentar baris 40 di bawah ini:

40.     caveNumber = chooseCave()

Ketika chooseCave() nanti dipanggil oleh program pada baris 40, nilai kembaliannya disimpan pada variabel caveNumber. Perulangan while menjamin bahwa chooseCave() hanya akan mengembalikan antara '1' atau '2' sebagai nilai kembalian.

Jadi ketika baris 17 mengembalikan sebuah string, pemanggilan fungsi pada baris 40 menghasilkan string yang sebelumnya tersimpan dalam caveNumber. 

Cakupan Global dan Cakupan Lokal

Your program’s variables are forgotten after the program terminates. These variables created while the execution is inside a function call are the same. The variables are created when the function is called and forgotten when the function returns.
Not only that, but when execution is inside the function, you cannot change the variables outside of the function, including variables inside other functions. This is because these variables exist in a different “scope”. All variables exist in either the global scope or a function call’s local scope.
The scope outside of all functions is called the global scope. The scope inside of a function (for the duration of a particular function call) is called a local scope. The entire program has only one global scope, and each function has a local scope of its own.
Variables defined in the global scope can be read outside and inside functions, but can only be modified outside of all functions. Variables created in a function call can only be read or modified during that function call.
You can read the value of global variables from the local scope, but attempting to change a global variable from the local scope won’t work. What Python actually does in that case is create a local variable with the same name as the global variable. You could, for example, have a local variable named spam at the same time as having a global variable named spam. Python will consider these to be two different variables.
Look at this example to see what happens when you try to change a global variable from inside a local scope. The comments explain what is going on:

def bacon():
    # We create a local variable named "spam"
    # instead of changing the value of the global
    # variable "spam":
    spam = 99
    # The name "spam" now refers to the local
    # variable only for the rest of this
    # function:
    print(spam)    # 99

spam = 42 # A global variable named "spam":
print(spam) # 42
bacon() # Call the bacon() function:
# The global variable was not changed in funky():
print(spam)    # 42

When run, this code will output the following:

42
99
42

Where a variable is created determines what scope it is in. When the Dragon Realm program first executes the line:

12.     cave = ''

...the variable cave is created inside the chooseCave() function. This means it is created in the chooseCave() function’s local scope. It will be forgotten when chooseCave() returns, and will be recreated if chooseCave() is called a second time. The value of a local variable isn’t remembered in between function calls.

Defining the checkCave() Function

19. def checkCave(chosenCave):

The next function the program defines is named checkCave(). Notice that the text chosenCave in between the parentheses. This is a parameter: a local variable that is assigned the argument passed in when this function is called.
Remember how for some function calls like str() or randint(), you would pass an argument in between the parentheses:

>>> str(5)
'5'
>>> random.randint(1, 20)
14

You will also pass an argument when you call checkCave(). This argument is stored in a new variable named chosenCave. These variables are also called parameters.

Parameters

Parameters are local variables created when a function is called. For example, here is a short program that demonstrates defining a function with a parameter:

def sayHello(name):
    print('Hello, ' + name + '. Your name has ' + str(len(name)) + 'letters.')

sayHello('Alice')
sayHello('Bob')
spam = 'Carol'
sayHello(spam)

If you run this program, it would look like this:

Hello, Alice. Your name has 5 letters.
Hello, Bob. Your name has 3 letters.
Hello, Carol. Your name has 5 letters.

When you call sayHello(), the argument is assigned to the name parameter. Parameters are just ordinary local variables. Like all local variables, the values in parameters will be forgotten when the function call returns.

Displaying the Game Results

Back to the game’s source code:

20.     print('You approach the cave...')
21.     time.sleep(2)

Remember that calling the function random.randint() required you execute import random first? In the Dragon Realm game, you imported the time module on line 2. The time module has a function called sleep() that pauses the program. This function will pause the program for a few seconds. Line 21 passes the integer value 2 so that time.sleep() will pause the program for 2 seconds.

22.     print('It is dark and spooky...')
23.     time.sleep(2)

Here the code prints some more text and waits for another 2 seconds. These short pauses add suspense to the game, instead of displaying the text all at once. In the previous chapter’s Jokes program, you called the input() function to pause until the player pressed the ENTER key. Here, the player doesn’t have to do anything except wait a couple seconds.

24.     print('A large dragon jumps out in front of you! He opens his jaws and...')
25.     print()
26.     time.sleep(2)

What happens next? And how does the program decide? This is explained in the next section.

Deciding Which Cave has the Friendly Dragon

28.     friendlyCave = random.randint(1, 2)

The program randomly choses which cave had the friendly dragon in it. Line 28 calls the random.randint() function which will return either 1 or 2. This integer value is stored in friendlyCave.

30.     if chosenCave == str(friendlyCave):
31.          print('Gives you his treasure!')

Line 30 checks if the player’s chosen cave in the chosenCave variable ('1' or '2') is equal to the       friendly dragon cave.
The value in chosenCave is a string because input() returns strings. But the value in friendlyCave is an integer because random.randint() returns integers. You can’t compare strings and integers with the == sign, because they will always be not equal. '1' doesn’t equal 1 and '2' doesn’t equal 2.
So friendlyCave is passed to str() function, which returns the string value of friendlyCave. This way the values will be the same data type and can be meaningfully compared to each other. This code could also have been used:

    if int(chosenCave) == friendlyCave:

The above if statement’s condition would compare the integer value returned by the int() function to the integer value in friendlyCave. This code would also work.
If the condition is True, line 31 tells the player they have won the treasure.

32.     else:
33.          print('Gobbles you down in one bite!')

Line 32 is an else statement. The else keyword always comes after the if-block. The else-block executes if the if statement’s condition was False. Think of it as the program’s way of saying, “If this condition is true then execute the if-block or else execute the else-block.”
Remember to put the colon (the : sign) after the else keyword.

Where the Main Part Begins

35. playAgain = 'yes'
36. while playAgain == 'yes' or playAgain == 'y':

Line 35 is the first line that isn’t a def statement or inside a def-block. This line is where the main part of the program begins. The previous def statements merely defined the functions. It didn’t run the code inside of the functions.
Line 35 and 36 are setting up a loop that the rest of the game code fits in. At the end of the game, the player can enter if they want to play again. If they do, the execution enters the while loop to run the entire game all over again. If they don’t, the while statement’s condition will be False and the execution will move on to the end of the program and terminate.

Pertama kalinya ekseuki program mencapai pernyatan while ini, baris 35 akan langsung memasukkan 'ya' ke dalam variabel playAgain. Itu berarti kondisinya akan menjadi True.

Memanggil Fungsi-Fungsi Dalam Program

38.     displayIntro()

Baris 38 memanggil fungsi displayIntro(). Ini bukanlah fungsi bawaan Python, namun merupakan fungsi yang telah kamu buat sebelumnya di baris 4. Ketika fungsi ini dipanggil, eksekusi program loncat ke baris pertama dalam fungsi displayIntro() pada baris 5. Ketika seluruh baris dalam fungsi telah selesai dieksekusi, alur eksekusi program loncat kembali ke baris 38 dan berlanjut maju ke bawah.

40.     caveNumber = chooseCave()

Baris 40 juga memanggil sebuah fungsi yang telah kamu buat. Ingat bahwa fungsi chooseCave() meminta pemain untuk mengetikkan gua yang mereka ingin jelajahi. Ketika pernyataan return cave pada baris 17 dieksekusi, alur eksekusi program akan kembali loncat ke baris 40 dan pemanggilan chooseCave() mengembalikan sebuah nilai kembalian. Nilai kembalian ini kemudian disimpan dalam variabel baru bernama caveNumber. Lalu eksekusi program maju ke baris 42.

42.     checkCave(caveNumber)

Baris ini memanggil fungsi checkCave() buatanmu, lalu melemparkan nilai dalam variabel caveNumber sebagai argumen. Eksekusi tidak hanya loncat ke baris 20, namun nilai dalam caveNumber disalin ke parameter chosenCave dalam fungsi checkCave(). Fungsi ini yang akan menampilkan 'Memberimu harta karunnya!' atau 'Mengunyahmu dalam satu gigitan!', tergantung pilihan gua yang dipilih oleh pemain.

Meminta Pemain Untuk Kembali Bermain

44.     print('Mau main lagi? (ya atau tidak)')
45.     playAgain = input()

Walaupun pemain kalah atau kalah, pemain akan diminta apakah mereka ingin bermain kembali. Variabel playAgain menyimpan string yang diketikkan oleh pemain. Baris 46 adalah baris terakhir pada while-block. Oleh karena itu, program akan kembali loncat ke baris 36 untuk memeriksa kondisi: playAgain == 'ya' or playAgain == 'y'

Jika pemain mengetikkan string 'ya' atau 'y', maka eksekusi akan berulang kembali ke baris 38.

Jika pemain mengetikkan 'tidak' atau 't' atau sesuatu yang tidak relevan seperti 'Abraham Lincoln', maka evaluasi kondisi tetap menghasilkan False. Eksekusi program akan berlanjut ke baris setelah while-block. Namun karena tidak ada baris setelah while-block, maka program akan berhenti.

Satu hal yang perlu dicatat: string 'YA' tidak sama dengan string 'ya'. Jika pemain mengetikkan string 'ya', maka kondisi dalam pernyataan while akan dievaluasi menjadi False dan program akan tetap berhenti. Program-program dalam bab-bab selanjutnya akan menunjukkan cara bagaimana menghindari masalah ini.

Kamu baru saja menyelesaikan game kedua kamu! Pada Alam Naga, kamu telah menggunakan hal-hal yang telah kamu pelajari pada game "Tebak Angka" dan belajar trik-trik baru. Jika kamu belum mengerti beberapa konsep dalam program ini, maka bacalah ringkasan pada akhir bab ini. Atau kamu dapat kembali melihat setiap baris pada kode sumber dan mencoba mengubahnya dan lihat bagaimana program berubah.

Pada bab berikutnya kamu tidak akan membuat sebuah gim, tapi kamu akan belajar bagaimana menggunakan sebuah fitur IDLE yang disebut sebagai debugger.

Merancang Program

Alam Naga merupakan game sederhana. Game-game lainnya dalam buku ini akan sedikit lebih rumit. Seringkali menuliskan apa saja yang kamu inginkan dari game atau program akan sangat membantu sebelum kamu mulai menulis kode. Kegiatan ini disebut "merancang program."

Sebagai contoh, kamu dapat menggambar sebuah diagram alur. Diagram alur adalah sebuah gambar yang menunjukkan semua kemungkinan aksi yang dapat terjadi dalam permainan dan aksi-aksi tersebut akan mengarah kepada aksi-aksi yang lain. Gambar 6-2 merupakan diagram alur untuk Dunia Naga.

Gambar 6-2: Diagram alur permainan Dunia Naga.

Untuk melihat apa yang terjadi dalam permainan, coba taruh jari kamu pada kotak "Mulai", lalu ikuti panah dari sana ke kotak lain. Jari kamu berfungsi layaknya eksekusi program. Program akan selesai ketika jari kamu mendarat pada kotak "Selesai".

Ketika kamu mencapai kotak "Cek apakah ada naga baik atau naga lapar", kamu dapat pergi ke kotak "Pemain menang" atau "Pemain kalah". Titik percabangan ini menunjukkan bagaimana program dapat melakukan hal-hal yang berbeda. Bagaimanapun, masing-masing jalur akan berakhir pada kotak "Mau main lagi?".

Ringkasan

Pada permainan "Alam Naga", kamu telah membuat fungsi buatanmu sendiri. Fungsi merupakan sebuah program mini di dalam program. Kode di dalam fungsi dijalankan ketika fungsi dipanggil. Dengan memecah kode kamu menjadi kumpulan fungsi, kamu dapat menyusun kode buatanmu menjadi bagian-bagian kecil yang lebih mudah dipahami.

Argumen merupakan nilai-nilai yang dimasukkan ke dalam fungsi ketika fungsi tersebut dipanggil. Pemanggilan fungsi dievaluasi hingga menghasilkan sebuah nilai yang disebut sebagai nilai kembalian.

Kamu juga telah memelajari mengenai cakupan variabel. Variabel-variabel yang dibuat dalam suatu fungsi hidup dalam cakupan lokal. Sedangkan variabel-variabel yang dibuat di luar semua fungsi hidup dalam cakupan global. Kode dalam cakupan global tidak dapat menggunakan variabel-variabel dalam cakupan lokal. Ketika ada variabel lokal yang memiliki nama sama dengan variabel dalam cakupan global, Python menganggapnya sebagai variabel yang berbeda. Oleh karena itu, memasukkan nilai baru ke dalam variabel lokal tidak akan mengubah nilai dalam variabel global.

Cakupan variabel mungkin terlihat rumit, namun mereka sangat bermanfaat untuk mengorganisir fungsi-fungsi sebagai bagian kode-kode terpisah dari keseluruhan program. Kamu dapat yakin bahwa kode dalam suatu fungsi tidak akan membuat bug di fungsi lain karena tiap fungsi memiliki cakupan lokal masing-masing.

Hampir semua program melakukan pemanggilan fungsi karena sangat berguna. Dengan memahami cara kerja fungsi, kamu dapat mengurangi banyak ketikan dan membuat bug lebih mudah dibetulkan.
