    Kapitel 4
    GISSA TALET

Ämnen som behandlas i detta kapitel:

•   import-satser
•   Moduler
•   while-satser
•   Villkor
•   Block
•   Booleska värden
•   Jämförelseoperatorer
•   Skillnaden mellan = och ==
•   if-satser
•   Nyckelordet break
•   Funktionerna str(), int() och float()
•   Funktionen random.randint()

I det här kapitlet så kommer du att skapa ett "Gissa talet"-spel. Datorn kommer att tänka på ett tal mellan 1 och 20, och be dig att försöka gissa talet. Sedan kommer datorn att tala om ifall det tal du gissat på är för högt eller för lågt. Du vinner om du gissar rätt på högst sex försök.

Det här är ett bra spel att koda eftersom det använder både slumptal, loopar och indata från användaren samtidigt som programmet är kort. Du får lära dig att konvertera värden till andra datatyper, och varför detta ibland är nödvändigt. Eftersom det här programmet är ett spel så kallar vi användaren för spelaren. Men "användaren" hade också varit korrekt.

Provköring av Gissa talet

Så här ser det ut för spelaren när programmet körs. Texten med fet stil är det som spelaren skriver in. 

Hej! Vad heter du?
Albert
Okej, Albert, jag tänker på ett tal mellan 1 och 20.
Gör en gissning.
10
Du gissade på ett för högt tal.
Gör en gissning.
2
Du gissade på ett för lågt tal.
Gör en gissning.
4
Bra jobbat, Albert! Du gissade rätt på 3 gissningar!

Gissa talets källkod

Öppna ett nytt fönster i fileditorn genom att klicka på File ► New File. Skriv in källkoden i det tomma fönster som öppnas och spara den som gissa.py. Kör sedan programmet genom att trycka på F5. När du skriver in koden i fileditorn, var uppmärksam på mellanslagen framför vissa rader. En del rader är indragna med fyra eller åtta mellanslag.

OBS, VIKTIGT! Programmen i den här boken kan bara köras med Python 3, inte med Python 2. När IDLE-fönstret öppnas, så ska det stå något i stil med “Python 3.4.2” längst upp. Du kan ha både Python 2 och Python 3 installerat samtidigt. För att ladda ner Python 3, gå till https://python.org/download/.

Om du får felmeddelanden när du försöker köra koden, så jämför den kod du skrivit in med bokens kod med diff-verktyget på adressen http://invpy.com/diff/gissa.

gissa.py

 1. # Det här spelet går ut på att gissa rätt tal.
 2. import random
 3. 
 4. antalGissningar = 0
 5. 
 6. print('Hej! Vad heter du?')
 7. namn = input()
 8. 
 9. tal = random.randint(1, 20)
10. print('Okej, ' + namn + ', jag tänker på ett tal mellan 1 och 20.')
11. 
12. while antalGissningar < 6:
13.     print('Gör en gissning.') # Det är fyra mellanslag före print.
14.     gissning = input()
15.     gissning = int(gissning)
16. 
17.     antalGissningar = antalGissningar + 1
18. 
19.     if gissning < tal:
20.         print('Du gissade på ett för lågt tal.') # Det är åtta mellanslag före print.
21.
22.     if gissning > tal:
23.         print('Du gissade på ett för högt tal.')
24. 
25.     if gissning == tal:
26.         break
27. 
28. if gissning == tal:
29.     antalGissningar = str(antalGissningar)
30.     print('Bra jobbat, ' + namn + '! Du gissade rätt på ' + antalGissningar + ' gissningar!')
31. 
32. if gissning != tal:
33.     tal = str(tal)
34.     print('Nix. Talet jag tänkte på var ' + tal)

import-satser

1. # Det här spelet går ut på att gissa rätt tal.
2. import random

Första raden är en kommentar. Kom ihåg att Python ignorerar allt som följer efter tecknet #. Den här raden bara påminner oss om vad programmet gör.

Andra raden är en import-sats. Du kanske minns att satser är instruktioner som utför något, men som till skillnad från uttryck inte utvärderas till något värde. Du har sett satser tidigare: tilldelningssatser lagrar ett värde i en variabel.

Även om Python har många inbyggda funktioner så ligger vissa av funktionerna i separata program som kallas för moduler. Du kan använda de här funktionerna genom att importera modulerna till ditt program med en import-sats.

Rad 2 importerar en modul kallad random, så att programmet kan anropa funktionen random.randint(). Den här funktionen returnerar ett slumptal som användaren ska försöka gissa. 

4. antalGissningar = 0

På rad 4 skapas en ny variabel kallad antalGissningar. Du lagrar antalet gissningar som spelaren har gjort i denna variabel. Eftersom spelaren inte har gjort några gissningar så här långt i programmet, så sparas heltalet 0 här.

6. print('Hej! Vad heter du?')
7. namn = input()

Rad 6 och 7 är samma rader som i Hejsan världen-programmet i kapitel 3. Programmerare återanvänder ofta kod från andra program för att spara tid. 

Rad 6 är ett funktionsanrop till print()-funktionen. Kom ihåg att en funktion är som ett mini-program inuti ditt program. När ditt program anropar en funktion så körs detta mini-program. Koden inuti print()-funktionen visar det sträng-argument som du skickat till den på skärmen.

Rad 7 låter användaren skriva in sitt namn och sparar det i variabeln namn. (Som du nog minns så behöver strängen inte innehålla spelarens namn. Utan den innehåller det som spelaren skriver in, oavsett vad. Datorer är dumma och följer bara de instruktioner vi ger dem.)

Funktionen random.randint()

9. tal = random.randint(1, 20)

Rad 9 anropar en ny funktion kallad randint() och sparar returvärdet i tal. Kom ihåg att funktionsanrop kan ingå i uttryck eftersom de utvärderas till ett värde. 

Funktionen randint() ingår i modulen random, så du måste skriva random. (glöm inte punkten!) före för att tala om för Python att randint()-funktionen finns i random-modulen.

Funktionen randint() returnerar ett slumpmässigt heltal mellan (och inklusive) de två heltal du skickar med som argument. På rad 9 skickas 1 och 20, med komma emellan, med mellan de parenteser som följer efter funktionsnamnet. Det slumpmässiga heltalet som randint() returnerar sparas i en variabel kallad tal; detta är det hemliga tal som spelaren ska försöka gissa.

För ett ögonblick, gå tillbaka till den interaktiva kommandotolken och skriv in import random för att importera random-modulen. Skriv sedan in random.randint(1, 20) för att se vad funktionsanropet utvärderas till. Funktionen kommer att returnerar ett heltal mellan 1 och 20. Upprepa koden igen och funktionsanropet kommer att returnera ett annat heltal. Funktionen randint() returnerar ett slumpmässigt heltal varje gång, ungefär som när du kastar en tärning:

>>> import random
>>> random.randint(1, 20)
12
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
3
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
7

Använd funktionen randint() när du vill ha slumpmässighet i dina spel. Du kommer att använda slumpen i många spel. (Tänk bara hur många brädspel som använder tärningar.)

Du kan också testa olika intervall genom att ändra funktionsargumenten. Till exempel kan du skriva in random.randint(1, 4) för att få slumptal endast mellan 1 och 4 (inklusive både 1 och 4). Eller prova med random.randint(1000, 2000) för att få slumptal mellan 1000 och 2000.

Till exempel kan du prova att mata in följande kod i den interaktiva tolken. Du kommer förmodligen få andra resultat än de nedan från random.randint() (det är ju slumptal som returneras).

>>> random.randint(1, 4)
3
>>> random.randint(1000, 2000)
1294

Genom att ändra spelets kod något kan du få spelet att bete sig på ett annat sätt. Prova att ändra rad 9 och 10 från det här:

 9. tal = random.randint(1, 20)
10. print('Okej, ' + namn + ', jag tänker på ett tal mellan 1 och 20.')

...till det här:

 9. tal = random.randint(1, 100)
10. print('Okej, ' + namn + ', jag tänker på ett tal mellan 1 och 100.')

Nu kommer datorn att tänka på ett tal mellan 1 och 100 i stället för mellan 1 och 20. Ändringen på rad 9 ändrar intervallet för slumptalet, men kom ihåg att även ändra rad 10 så att spelet skriver ut det nya intervallet och inte det gamla.

Att välkomna spelaren

10. print('Okej, ' + namn + ', jag tänker på ett tal mellan 1 och 20.')

På rad 10 så används print()-funktionen för att välkomna spelaren med namn och tala om att datorn tänker på ett slumptal.

Det kanske ser ut som att fler än ett sträng-argument skickas till funktionen, men titta noga på koden. Plustecknet slår ihop de tre strängarna så att de utvärderas till en enda sträng. Och det är den strängen som skickas som argument till print()-funktionen. Om du tittar riktigt noga så ser du att kommatecknen står innanför citattecknen och alltså ingår i själva strängarna.

Loopar

12. while antalGissningar < 6:

Rad 12 är en while-sats, som indikerar början på en while-loop. Loopar används för att köra kod om och om igen. Men innan du lär dig om loopar behöver du känna till några andra koncept. Dessa koncept är block, booleska variabler, jämförelseoperatorer, villkor och while-satser.

Block

Flera rader kod kan grupperas i ett block. Varje rad i ett kodblock är indragen minst lika mycket som de andra raderna. Du kan se var ett block börjar och slutar genom att se på antalet mellanslag före raden. Det är detta som är radens indrag, eller indentering.

Ett block börjar när indenteringen av en rad ökar (vanligen med fyra mellanslag). Varje följande rad som också är indragen med fyra mellanslag ingår i blocket. Blocket slutar där det kommer en rad som är indragen lika mycket som koden före blocket. Det här betyder att block kan finnas inuti andra block. I koden i Figur 4-1 har de olika blocken markerats och numrerats. 

I Figur 4-1 har rad 12 inget indrag, och ingår därmed inte i något block. Rad 13 är indragen med fyra mellanslag. Eftersom detta indrag är större än föregående rads, så påbörjar denna rad ett nytt block. Detta block är märkt med (1) i Figur 4-1. Blocket fortsätter fram till den rad vars indentering är noll mellanslag (det ursprungliga indraget innan blocket började). Blankrader ignoreras.

Rad 20 är indragen me åtta mellanslag. Åtta mellanslag är mer än fyra mellanslag, så här börjar ett nytt block. Blocket är märkt med (2) i Figur 4-1. Detta block ligger inuti ett annat block.

Figur 4-1: Block och deras indrag. De svarta prickarna motsvarar mellanslag.

Rad 22 är bara indragen med fyra mellanslag. Eftersom indenteringen har minskat så vet du att det föregående blocket är slut. Rad 20 är den enda raden i det blocket. Rad 22 ingår i samma block som de andra raderna som är indragna med fyra mellanslag.

På rad 23 ökas indenteringen till åtta mellanslag, så återigen påbörjas ett nytt block. Det är märkt med (3) i Figur 4-1.

För att repetera, rad 12 ingår inte i något block. Rad 13 till 23 ligger i ett block märkt (1). Rad 20 utgör ett block inuti ett annat block och är markerat med (2). Rad 23 är enda raden i ytterligare ett block som ligger i ett annat block, och markeras med (3).

Datatypen Boolean

Datatypen Boolean kan bara ha två olika värden: True och False (sant och falskt). De här värdena måste skrivas med stort "T" respektive "F". Resten av namnen måste skrivas med små bokstäver. Du kommer att använda booleska värden tillsammans med jämförelseoperatorer för att bilda villkor. (Villkor förklaras senare.)

Prova till exempel att lagra booleska värden i variabler:

>>> skräp = True
>>> ägg = False

The data types that have been introduced so far are integers, floats, strings, and now bools. Every value in Python belongs to one data type.

Comparison Operators

Line 12 has a while statement:

12. while guessesTaken < 6:

The expression that follows the while keyword (the guessesTaken < 6 part) contains two values (the value in the variable guessesTaken, and the integer value 6) connected by an operator (the < “less than” sign). The < sign is a comparison operator.

Comparison operators compare two values and evaluate to a True or False Boolean value. A list of all the comparison operators is in Table 4-1.

Table 4-1: Comparison operators.
Operator Sign   Operator Name
<   Less than
>   Greater than
<=  Less than or equal to
>=  Greater than or equal to
==  Equal to
!=  Not equal to

You’ve already read about the +, -, *, and / math operators. Like any operator, the comparison operators combine with values to form expressions such as guessesTaken < 6.

Conditions

A condition is an expression that combines two values with a comparison operator (such as < or >) and evaluates to a Boolean value. A condition is just another name for an expression that evaluates to True or False. Conditions are used in while statements (and a few other instructions, explained later.)

For example, the condition guessesTaken < 6 asks, “is the value stored in guessesTaken less than the number 6?” If so, then the condition evaluates to True. If not, the condition evaluates to False.

In the case of the “Guess the Number” program, on line 4 you stored the value 0 in guessesTaken. Because 0 is less than 6, this condition evaluates to the Boolean value of True. The evaluation would look like this:

guessesTaken < 6
             ▼
           0 < 6
             ▼
            True

Experiment with Booleans, Comparison Operators, and Conditions

Enter the following expressions in the interactive shell to see their Boolean results:

>>> 0 < 6
True
>>> 6 < 0
False
>>> 50 < 10
False
>>> 10 < 11
True
>>> 10 < 10
False

The condition 0 < 6 returns the Boolean value True because the number 0 is less than the number 6. But because 6 isn’t less than 0, the condition 6 < 0 evaluates to False. 50 isn’t less than 10, so 50 < 10 is False. 10 is less than 11, so 10 < 11 is True.

Notice that 10 < 10 evaluates to False because the number 10 isn’t smaller than the number 10. They are the same size. If Alice were the same height as Bob, you wouldn't say that Alice is taller than Bob or that Alice is shorter than Bob. Both of those statements would be false.

Now try entering these expressions into the interactive shell:

>>> 10 == 10
True
>>> 10 == 11
False
>>> 11 == 10
False
>>> 10 != 10
False
>>> 10 != 11
True
>>> 'Hello' == 'Hello'
True
>>> 'Hello' == 'Goodbye'
False
>>> 'Hello' == 'HELLO'
False
>>> 'Goodbye' != 'Hello'
True

The Difference Between = and ==

Try not to confuse the assignment operator (=) and the “equal to” comparison operator (==). The equal sign (=) is used in assignment statements to store a value to a variable, while the equal-equal sign (==) is used in expressions to see whether two values are equal. It’s easy to accidentally use one when you meant to use the other.

Just remember that the “equal to” comparison operator (==) has two characters in it, just as the “not equal to” comparison operator (!=) has two characters in it.

String and integer values will never be equal to each other. For example, try entering the following into the interactive shell:

>>> 42 == 'Hello'
False
>>> 42 != '42'
True

Looping with while statements

The while statement marks the beginning of a loop. Loops can execute the same code repeatedly. When the execution reaches a while statement, it evaluates the condition next to the while keyword. If the condition evaluates to True, the execution moves inside the following block, called the while-block. (In the program, the while-block begins on line 13.) If the condition evaluates to False, the execution moves all the way past the while-block. In Guess the Number, the first line after the while-block is line 28.

A while statement always has a : colon after the condition. Statements that end with a colon expect a new block on the next line.

12. while guessesTaken < 6:

Figure 4-2: The while loop’s condition.

Figure 4-2 shows how the execution flows depending on the condition. If the condition evaluates to True (which it does the first time, because the value of guessesTaken is 0), execution will enter the while-block at line 13 and keep going down. Once the program reaches the end of the while-block, instead of going down to the next line, the execution loops back up to the while statement’s line (line 12) and re-evaluates the condition. As before, if the condition is True the execution enters the while-block again. Each time the execution goes through the loop is called an iteration.

This is how the loop works. As long as the condition is True, the program keeps executing the code inside the while-block repeatedly until the first time the condition is False. Think of the while statement as saying, “while this condition is true, keep executing the code in the following block”.

The Player Guesses

13.     print('Take a guess.') # There are four spaces in front of print.
14.     guess = input()

Lines 13 to 17 ask the player to guess what the secret number is and lets them enter their guess. That number is stored in a variable named guess.

Converting Values with the int(), float(), and str() Functions

15.     guess = int(guess)

Line 15 calls a new function named int(). The int() function takes one argument and returns an integer value form of that argument. Try entering the following into the interactive shell:

>>> int('42')
42
>>> 3 + int('2')
5

The int('42') call will return the integer value 42. However, even though you can pass a string to the int() function, you cannot pass just any string. Passing 'forty-two' to int() will result in an error. The string you pass to int() must be made up of numbers:

>>> int('forty-two')
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
int('forty-two')
ValueError: invalid literal for int() with base 10: 'forty-two'

The 3 + int('2') line shows an expression that uses the return value of int() as part of an expression. It evaluates to the integer value 5:

3 + int('2')
  ▼
3 + 2
  ▼
  5

Remember, the input() function always returns a string of text the player typed. If the player types 5, the input() function will return the string value '5', not the integer value 5. Python cannot use the < and > comparison operators to compare a string and an integer value:

>>> 4 < '5'
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    4 < '5'
TypeError: unorderable types: int() < str()

On line 14 the guess variable originally held the string value of what the player typed. Line 15 overwrites the string value in guess with the integer value returned by int(). This lets the code later in the program compare if guess is greater than, less than, or equal to the secret number in the number variable.

One last thing: Calling int(guess) doesn’t change the value in the guess variable. The code int(guess) is an expression that evaluates to the integer value form of the string stored in the guess variable. What changes guess is the assignment statement: guess = int(guess)

The float(), str(), and bool() functions will similarly return float, string, and Boolean versions of the arguments passed to them. Try entering the following into the interactive shell:

>>> float('42')
42.0
>>> float(42)
42.0
>>> str(42)
'42'
>>> str(42.0)
'42.0'
>>> str(False)
'False'
>>> bool('')
False
>>> bool('any nonempty string')
True

Using the int(), float(), str(), and bool() functions, you can take a value of one data type and return it as a value of a different data type.

Incrementing Variables

17.     guessesTaken = guessesTaken + 1

Once the player has taken a guess, the number of guesses should be increased by one.

On the first iteration of the loop, guessesTaken has the value of 0. Python will take this value and add 1 to it. 0 + 1 evaluates to 1, which is stored as the new value of guessesTaken. Think of line 17 as meaning, “the guessesTaken variable should be one more than what it already is”.

Adding one to a variable’s integer or float value is called incrementing the variable. Subtracting one from a variable’s integer or float value is called decrementing the variable.

if statements

19.     if guess < number:
20.          print('Your guess is too low.') # There are eight spaces in front of print.

Line 19 is an if statement. The execution will run the code in the following block if the if statement’s condition evaluates to True. If the condition is False, then the code in the if-block is skipped. Using if statements, you can make the program only run certain code when you want it to.

Line 19 checks if the player’s guess is less than the computer’s secret number. If so, then the execution moves inside the if-block on line 20 and prints a message telling the player this.

The if statement works almost the same as a while statement, too. But unlike the while-block, the execution doesn’t jump back to the if statement at the end of the if-block. It just continues down to the next line. In other words, if statements don’t loop. See Figure 4-3 for a comparison of the two statements.

Figure 4-3: if and while statements.

22.     if guess > number:
23.          print('Your guess is too high.')

Line 22 checks if the player’s guess is greater than the secret number. If this condition is True, then the print() function call tells the player that their guess is too high.

Leaving Loops Early with the break statement

25.     if guess == number:
26.          break

The if statement on line 25 checks if the guess is equal to the secret number. If it is, the program runs the break statement on line 26.

A break statement tells the execution to jump immediately out of the while-block to the first line after the end of the while-block. The break statement doesn’t bother rechecking the while loop’s condition.

The break statement is only found inside loops, such as in a while-block.

If the player’s guess isn’t equal to the secret number, the execution reaches the bottom of the while-block. This means the execution will loop back to the top and recheck the condition on line 12 (guessesTaken < 6). Remember after the guessesTaken = guessesTaken + 1 instruction executed, the new value of guessesTaken is 1. Because 1 < 6 is True, the execution enters the loop again.

If the player keeps guessing too low or too high, the value of guessesTaken will change to 2, then 3, then 4, then 5, then 6. When guessesTaken has the number 6 stored in it, the while statement’s condition (guessesTaken < 6) is False, since 6 isn’t less than 6. Because the while statement’s condition is False, the execution moves to the first line after the while-block, line 28.

Check if the Player Won

28. if guess == number:

Line 28 has no indentation, which means the while-block has ended and this is the first line after the while-block. The execution left the while-block either because the while statement’s condition was False (when the player runs out of guesses) or the break statement on line 26 was executed (when the player guesses the number correctly).

Line 28 checks to see if the player guessed correctly. If so, the execution enters the if-block at line 29.

29.     guessesTaken = str(guessesTaken)
30.     print('Good job, ' + myName + '! You guessed my number in ' + guessesTaken + ' guesses!')

Lines 29 and 30 only execute if the condition in the if statement on line 28 was True (that is, if the player correctly guessed the computer’s number).

Line 29 calls the str() function, which returns the string form of guessesTaken. Line 30 concatenates strings to tell the player they have won and how many guesses it took them. Only string values can concatenate to other strings. This is why line 29 had to change guessesTaken to the string form. Otherwise, trying to concatenate a string to an integer would cause Python to display an error.

Check if the Player Lost

32. if guess != number:

Line 32 uses the “not equal to” comparison operator != to check if player’s last guess is not equal to the secret number. If this condition evaluates to True, the execution moves into the if-block on line 33.

Lines 33 and 34 are inside the if-block, and only execute if the condition on line 32 was True.

33.     number = str(number)
34.     print('Nope. The number I was thinking of was ' + number)

In this block, the program tells the player what the secret number they failed to guess correctly was. This requires concatenating strings, but number stores an integer value. Line 33 will overwrite number with a string form so that it can be concatenated to the 'Nope. The number I was thinking of was ' string on line 34.

At this point, the execution has reached the end of the code, and the program terminates. Congratulations! You’ve just programmed your first real game!

You can change the game’s difficulty by changing the number of guesses the player gets. To give the player only four guesses, change the code on line 12:

12. while guessesTaken < 6:

into this line:

12. while guessesTaken < 4:

Code later in the while-block increases the guessesTaken variable by 1 on each iteration. By setting the condition to guessesTaken < 4, you ensure that the code inside the loop only runs four times instead of six. This makes the game much more difficult. To make the game easier, set the condition to guessesTaken < 8 or guessesTaken < 10. This will cause the loop to run a few more times and accept more guesses from the player.

Flow Control Statements

In previous chapters, the program execution started at the top instruction in program and went straight down, executing each instruction in order. But with the while, if, else, and break statements, you can cause the execution to loop and skip instructions based on conditions. The name for these kinds of statements is flow control statement, since they change the “flow” of the program execution as it moves around your program.

Summary

If someone asked you, “What exactly is programming anyway?” what could you say to them? Programming is just the action of writing code for programs, that is, creating programs that can be executed by a computer.

“But what exactly is a program?” When you see someone using a computer program (for example, playing your “Guess the Number” game), all you see is some text appearing on the screen. The program decides what exact text to show on the screen (the program’s output), based on its instructions and on the text that the player typed on the keyboard (the program’s input). A program is just a collection of instructions that act on the user’s input.

“What kind of instructions?” There are only a few different kinds of instructions, really.

1.  Expressions are values connected by operators. Expressions are all evaluated down to a single value, as 2 + 2 evaluates to 4 or 'Hello' + ' ' + 'World' evaluates to 'Hello World'. When expressions are next to the if and while keywords, you can also call them conditions.
2.  Assignment statements store values in variables so you can remember the values later in the program.
3.  The if, while, and break statements are flow control statements that can cause the execution to skip instructions, loop over instructions, or break out of loops. Function calls also change the flow of execution by jumping to the instructions inside of a function.
4.  The print() and input() functions. These functions display text on the screen and get text from the keyboard. This is called I/O (pronounced like the letters, “eye-oh”), because it deals with the Input and Output of the program.

And that’s it, just those four things. Of course, there are many details about those four types of instructions. In this book you’ll learn about new data types and operators, new flow control statements, and many other functions that come with Python. There are also different types of I/O such as input from the mouse or outputting sound and graphics instead of just text.

For the person using your programs, they only care about that last type, I/O. The user types on the keyboard and then sees things on the screen or hears things from the speakers. But for the computer to figure out what sights to show and what sounds to play, it needs a program, and programs are just a bunch of instructions that you, the programmer, have written.
