    Kapitel 7
    ANVÄNDA DEBUGGERN

Ämnen som behandlas i detta kapitel:

•   Tre olika typer av fel
•   IDLE:s debugger
•   Hoppa in, över och ut
•   Go och Quit
•   Brytpunkter

Buggar!

“Vid två tillfällen har jag fått frågan 'Herr Babbage, om du matar in fel siffror i maskinen, kommer ändå rätt svar ut?' Jag kan inte fullt ut begripa den förvirring som måste ligga bakom att en sådan fråga ställs.”
-Charles Babbage, 1800-talets upphovsman till konceptet programmerbara datorer (citatet fritt översatt).

Om du matar in fel kod så kommer inte datorn fixa så att programmet blir korrekt. Ett datorprogram gör bara vad du har sagt åt det att göra, men det du säger åt programmet att göra kanske inte är samma sak som det du egentligen vill att det ska göra. Den här typen av fel i ett datorprogram kallas för buggar. Buggar uppstår när programmeraren inte noga har tänkt igenom exakt vad programmet ska göra. Det finns tre typer av buggar som kan uppstå i dina program:

•   Syntaxfel är en typ av buggar som beror på skrivfel. När Python-tolken hittar ett syntaxfel, så beror det på din kod inte följer Pythons språkregler. Även om ditt Python-program bara innehåller ett enda syntaxfel så kan det inte köras.
•   Körningsfel är buggar som uppstår medan programmet körs. Programmet fungerar ända tills exekveringen når raden där felet uppstår, därefter avbryts det och du får ett felmeddelande (det här kallas för att programmet kraschar). Python-tolken kommer att visa en "spårutskrift" och ange på vilken rad problemet uppstod.
•   Semantiska fel är den typ av fel som är svårast att åtgärda. De här buggarna kraschar inte ditt program, men de gör så att programmet inte fungerar så som du har tänkt att det ska fungera. Om en programmerare till exempel vill att variabeln total ska innehålla summan av värdena i variablerna a, b och c men skriver total = a * b * c, så blir värdet i total helt fel. Det här skulle kunna leda till att programmet kraschar längre fram, men det skulle inte vara omedelbart uppenbart var det semantiska felet fanns.

Att hitta buggar i ett program kan vara svårt, eller rent av omöjligt! Men när du kör ditt program så kanske du upptäcker att funktioner ibland inte anropas när de ska anropas, eller att de anropas för många gånger. Du kanske utformade villkoret i en while-loop på fel sätt, så att den loopar ett felaktigt antal gånger. (En loop i ett program som aldrig avbryts kallas för en evig loop. För att avbryta en sådan loop kan du trycka Ctrl-C i den interaktiva kommandotolken, så kommer programmet att avslutas.) Alla de här felen kan uppstå av misstag, om du inte är noggrann.

Ta och testa att skapa en evig loop genom att skriva in den här koden i den interaktiva kommandotolken (du måste trycka på ENTER två gånger så att den interaktiva tolken förstår att du är klar med while-blocket):

>>> while True:
...     print('Tryck Ctrl-C för att stoppa den här eviga loopen!!!')
...

Tryck nu och håll nere Ctrl-tangenten och tryck sedan på C för att stoppa programmet. Den interaktiva tolken kommer att se ut så här:

Tryck Ctrl-C för att stoppa den här eviga loopen!!!
Tryck Ctrl-C för att stoppa den här eviga loopen!!!
Tryck Ctrl-C för att stoppa den här eviga loopen!!!
Tryck Ctrl-C för att stoppa den här eviga loopen!!!
Tryck Ctrl-C för att stoppa den här eviga loopen!!!
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    while True: print('Tryck Ctrl-C för att stoppa den här eviga loopen!!!')
KeyboardInterrupt

Debuggern

Det kan vara svårt att klura ut hur din kod kunde orsaka en bugg. Raderna med kod exekveras snabbt och värdena i variabler ändras ofta. En debugger är ett program som låter dig gå igenom ett program en rad i taget, i samma ordning som Python exekverar dem. Debuggern visar dig även vilka värden som olika variabler innehåller vid varje steg.

Starta debuggern

Öppna spelet Drakriket som du skrev i förra kapitlet i IDLE. När du har öppnat filen drakriket.py, välj Debug ► Debugger så att fönstret Debug Control öppnas (Figur 7-1).

Figur 7-1: Fönstret Debug Control.

Figure 7-2: Att köra spelet Drakriket med debuggern.

När du nu kör Drakriket genom att trycka på F5 så kommer IDLE:s debugger att aktiveras. Det här kallas för att man kör programmet med debuggern, eller i felsökningsläge. Kryssa irutorna Source och Globals i fönstret Debug Control.

När du kör Pythonprogram i felsökningsläge så kommer programmet att pausas innan den första instruktionen exekveras. Om du klickar på titelraden i fönstret med fileditorn (och om du har kryssat i rutan Source i fönstret Debug Control) så kommer den första instruktionen att markeras med grått. I fönstret Debug Control kan man se att exekveringen befinner sig på rad 1, vilket är raden med import random.

Stega igenom program

Debuggern låter dig exekvera en instruktion åt gången. Det här kallas för att stega igenom ett program (eller för att gå igenom det steg för steg). Tryck på knappen Step i fönstret Debug Control för att exekvera en enskild instruktion. Prova nu att göra detta. Python kommer att exekvera instruktionen import random, och pausar därefter exekveringen innan nästa instruktion körs. I fönstret Debug Control ser man nu att exekveringen befinner sig på rad 2, som är raden med import time. Klicka nu på knappen Quit för att avbryta körningen av programmet tills vidare.

Här är en sammanfattning av vad som sker när du klickar på knappen Step när du kör Drakriket med debuggern. Tryck på F5 för att starta Drakriket igen, följ sedan dessa instruktioner:

1.  Klicka på knappen Step två gånger om för att köra de två import-satserna.
2.  Klicka på Step ytterligare tre gånger för att exekvera de tre def-satserna.
3.  Klicka på Step ännu en gång för att definiera variabeln spelaIgen.
4.  Klicka på Go för att köra resten av programmet, eller på Quit för att avbryta exekveringen.

I fönstret Debug Control kan du se vilken rad som kommer att exekveras när du trycker på knappen Step. Debuggern hoppade över rad 3 eftersom den är tom. Notera att du bara kan gå framåt, inte bakåt, med debuggern.

Området Globals

I ytan under rubriken Globals i fönstret Debug Control så listas alla globala variabler. Som du kanske minns så är globala variabler de variabler som skapas utanför alla funktioner (det vill säga i den globala synlighetsnivån).

Eftersom de tre def-satserna definierar och exekverar funktioner så kommer de att visas i området Globals i fönstret Debug Control.

Texten intill funktionernas namn kommer att se ut ungefär såhär: “<function kollaGrotta at 0x012859B0>“. Även intill modulernas namn står det märkliga saker, så som “<module 'random' from 'C:\\Python31\\lib\\random.pyc'>“. Du behöver inte veta vad det här betyder för att kunna använda debuggern. Bara genom att se om funktioner och moduler visas i området Globals så vet du om funktionen har definierats eller om modulen har importerats. 

Du kan också strunta i raderna i området Globals där det står __builtins__, __doc__, och __name__. (Det här är variabler som finns i alla Pythonprogram.)

När variabeln spelaIgen skapas så kommer den att dyka upp under Globals. Intill variabelnamnet så kommer strängen 'ja' att visas. Debuggern låter dig se värdena i alla variabler i programmet medan programmet körs. Det här är användbart när man försöker fixa buggar.

Området Locals

Det finns också ett område med rubriken Locals, som visar de lokala variablerna och de värden som de innehåller. De lokala variablerna visas bara när exekveringen befinner sig inuti en funktion. När exekveringen är på den globala nivån så är denna yta tom.

Knapparna Go och Quit

Om du tröttnar på att hela tiden behöva klicka på Step och vill att programmet ska köras på det vanliga viset så kan du trycka på Go i övre delen av fönstret Debug Control. Programmet exekveras då på det normala sättet i stället för steg för steg.

För att avbryta programmet helt och hållet, klicka på Quit längst upp i fönstret Debug Control. Programmett avslutas omedelbart. Det här kan vara till hjälp om du behöver starta om felsökningen från början av programmet.

Hoppa in, över och ut

Starta nu Drakriket med debuggern igång. Tryck på Step tills debuggern befinner sig på rad 38. Som du ser i Figur 7-3 så är detta raden med visaIntro(). När du klickar på Step ännu en gång så kommer debuggern att hoppa in i denna funktion och ställa sig på rad 5, den första raden i funktionen visaIntro(). När du stegar på det här viset så hoppar du alltså in i funktioner. Men det går också att hoppa över dem, vilket förklaras härnäst.

Figur 7-3: Fortsätt att trycka på Step tills du är på rad 38.

Om du nu, när exekveringen har pausats på rad 5, trycker på Step en gång till så kommer du att hoppa in i print()-funktionen. Funktionen print() är en av Pythons inbyggda funktioner, så det är inte någon vits med att stega igenom den med debuggern. Pythons egna funktioner så som print(), input(), str() och random.randint() har noga kontrollerats så att de inte innehåller några fel. Du kan utgå ifrån att de inte orsakar några buggar i dina program.

Du vill alltså inte slösa tid genom att stega igenom den kod som print()-funktionen innehåller. Så i stället för Step, som gör så att debuggern hoppar in i koden i print(), klicka på Over. På detta vis hoppar du över koden inuti print()-funktionen. Koden i print() kommer att exekveras i normal hastighet och debuggern kommer att pausa exekveringen först när print() har returnerat.

Att hoppa över funktionsanrop är ett smidigt sätt att slippa stega igenom kod inuti funktioner. Debuggern kommer nu att pausa på rad 40, grottnummer = väljGrotta().

Tryck på Step ytterligare en gång för att hoppa in i funktionen väljGrotta(). Fortsätt att stega igenom koden tills du kommer till rad 15, anropet till input(). Programmet kommer att vänta tills du har skrivit in ett svar i den interaktiva kommandotolken, precis som när du kör programmet på det normala sättet. Om du nu trycker på Step så kommer inget att hända, eftersom programmet väntar på en inmatning från tangentbordet. 

Klicka dig tillbaka till fönstret med den interaktiva kommandotolken och mata in numret på den grotta du vill gå in i. Den blinkande markören måste stå på nedersta raden i den interaktiva tolken innan du kan skriva, annars kommer den text du skriver in inte att synas.

När du trycker på ENTER så kommer debuggern att fortsätta att stega igenom kodraderna. Click the Out button on the Debug Control window. This is called stepping out, because it will cause the debugger to step over as many lines as it needs to until execution has returned from the function it is in. After it jumps out, the execution will be on the line after the line that called the function.

For example, clicking Out inside the displayIntro() function on line 6 would step until the function returned to the line after the call to displayIntro(). Stepping out can save you from having to click Step repeatedly to jump out of the function.

If you are not inside a function, clicking Out will cause the debugger will execute all the remaining lines in the program. This is the same behavior as clicking the Go button.

Here’s a recap of what each button does:

•   Go - Executes the rest of the code as normal, or until it reaches a break point. (Break points are described later.)
•   Step - Step one instruction. If the line is a function call, the debugger will step into the function.
•   Over - Step one instruction. If the line is a function call, the debugger won’t step into the function, but instead step over the call.
•   Out - Keeps stepping over lines of code until the debugger leaves the function it was in when Out was clicked. This steps out of the function.
•   Quit - Immediately terminates the program.

Find the Bug

The debugger can help you find the cause of bugs in your program. As an example, here is a small program with a bug. The program comes up with a random addition problem for the user to solve. In the interactive shell window, click on File, then New Window to open a new file editor window. Type this program into that window, and save the program as buggy.py.

buggy.py

1. import random
2. number1 = random.randint(1, 10)
3. number2 = random.randint(1, 10)
4. print('What is ' + str(number1) + ' + ' + str(number2) + '?')
5. answer = input()
6. if answer == number1 + number2:
7.     print('Correct!')
8. else:
9.     print('Nope! The answer is ' + str(number1 + number2))

Type the program as it is above, even if you can already tell what the bug is. Then trying running the program by pressing F5. This is a simple arithmetic quiz that comes up with two random numbers and asks you to add them. Here’s what it might look like when you run the program:

What is 5 + 1?
6
Nope! The answer is 6

That’s a bug! The program doesn’t crash but it is not working correctly. The program says the user is wrong even if they type the correct answer.

Running the program under a debugger will help find the bug’s cause. At the top of the interactive shell window, click on Debug ► Debugger to display the Debug Control window. In the Debug Control window, check all four checkboxes (Stack, Source, Locals, and Globals). This makes the Debug Control window provide the most information. Then press F5 in the file editor window to run the program. This time it will be run under the debugger.

1. import random

The debugger starts at the import random line. Nothing special happens here, so just click Step to execute it. You will see the random module added to the Globals area.

2. number1 = random.randint(1, 10)

Click Step again to run line 2. A new file editor window will appear with the random.py file. You have stepped inside the randint() function inside the random module. Python’s built-in functions won’t be the source of your bugs, so click Out to step out of the randint() function and back to your program. Then close the random.py file's window.

3. number2 = random.randint(1, 10)

Next time, you can click Over to step over the randint() function instead of stepping into it. Line 3 is also a randint() function call. Skip stepping into this code by clicking Over.

4. print('What is ' + str(number1) + ' + ' + str(number2) + '?')

Line 4 is a print() call to show the player the random numbers. You know what numbers the program will print even before it prints them! Just look at the Globals area of the Debug Control window. You can see the number1 and number2 variables, and next to them are the integer values stored in those variables.

The number1 variable has the value 4 and the number2 variable has the value 8. When you click Step, the program will display the string in the print() call with these values. The str() function will concatenate the string version of these integers. When I ran the debugger, it looked like Figure 7-4. (Your random numbers will probably be different.)

Figure 7-4: number1 is set to 4 and number2 is set to 8.

5. answer = input()

Clicking on Step from line 5 will execute input(). The debugger waits until the player enters a response into the program. Enter the correct answer (in my case, 12) into the interactive shell window. The debugger will resume and move down to line 6.

6. if answer == number1 + number2:
7.     print('Correct!')

Line 6 is an if statement. The condition is that the value in answer must match the sum of number1 and number2. If the condition is True, then the debugger will move to line 7. If the condition is False, the debugger will move to line 9. Click Step one more time to find out where it goes.

8. else:
9.     print('Nope! The answer is ' + str(number1 + number2))

The debugger is now on line 9! What happened? The condition in the if statement must have been False. Take a look at the values for number1, number2, and answer. Notice that number1 and number2 are integers, so their sum would have also been an integer. But answer is a string.

That means that answer == number1 + number2 would have evaluated to '12' == 12. A string value and an integer value will always not equal each other, so the condition evaluated to False.

That is the bug in the program. The bug is that the code has answer when it should have int(answer). Change line 6 to int(answer) == number1 + number2, and run the program again.

What is 2 + 3?
5
Correct!

This time, the program worked correctly. Run it one more time and enter a wrong answer on purpose. This will completely test the program. You’ve now debugged this program! Remember, the computer will run your programs exactly as you type them, even if what you type isn’t what you intend.

Break Points

Stepping through the code one line at a time might still be too slow. Often you’ll want the program to run at normal speed until it reaches a certain line. A break point is set on a line when you want the debugger to take control once execution reaches that line. If you think there’s a problem with your code on, say, line 17, just set a break point on line 17 (or maybe a few lines before that).

When execution reaches that line, the debugger will “break into the debugger”. Then you can step through lines one at a time to see what is happening. Clicking Go will execute the program normally until it reaches another break point or the end of the program.

To set a break point, right-click on the line in the file editor and select Set Breakpoint from the menu that appears. The file editor will highlight that line with yellow. You can set break points on as many lines as you want. To remove the break point, click on the line and select Clear Breakpoint from the menu that appears.

Figure 7-5: The file editor with two break points set.

Example Using Break Points

Here is a program that simulates coin flips by calling random.randint(0, 1). The function returning the integer 1 will be “heads” and returning the integer 0 will be “tails”. The  flips variable will track how many coin flips have been done. The heads variable will track how many came up heads.

The program will do “coin flips” one thousand times. This would take a person over an hour to do, but the computer can do it in one second! Type in the following code into the file editor and save it as coinFlips.py. If you get errors after typing this code in, compare the code you typed to the book’s code with the online diff tool at http://invpy.com/diff/coinflips.

coinFlips.py

 1. import random
 2. print('I will flip a coin 1000 times. Guess how many times it will come up heads. (Press enter to begin)')
 3. input()
 4. flips = 0
 5. heads = 0
 6. while flips < 1000:
 7.     if random.randint(0, 1) == 1:
 8.         heads = heads + 1
 9.     flips = flips + 1
10.
11.     if flips == 900:
12.         print('900 flips and there have been ' + str(heads) + ' heads.')
13.     if flips == 100:
14.         print('At 100 tosses, heads has come up ' + str(heads) + ' times so far.')
15.     if flips == 500:
16.         print('Half way done, and heads has come up ' + str(heads) + ' times.')
17.
18. print()
19. print('Out of 1000 coin tosses, heads came up ' + str(heads) + ' times!')
20. print('Were you close?')

The program runs pretty fast. It spent more time waiting for the user to press ENTER than doing the coin flips. Let’s say you wanted to see it do coin flips one by one. On the interactive shell's window, click on Debug ► Debugger to bring up the Debug Control window. Then press F5 to run the program.

The program starts in the debugger on line 1. Press Step three times in the Debug Control window to execute the first three lines (that is, lines 1, 2, and 3). You’ll notice the buttons become disabled because input() was called and the interactive shell window is waiting for the user to type something. Click on the interactive shell window and press ENTER. (Be sure to click beneath the text in the interactive shell window, otherwise IDLE might not receive your keystrokes.)

You can click Step a few more times, but you’ll find that it would take quite a while to get through the entire program. Instead, set a break point on lines 12, 14, and 16. The file editor will highlight these lines as shown in Figure 7-6.

Figure 7-6: Three break points set.

After setting the breakpoints, click Go in the Debug Control window. The program will run at normal speed until it reaches the next break point. When flip is set to 100, the condition for the if statement on line 13 is True. This causes line 14 (where there’s a break point set) to execute, which tells the debugger to stop the program and take over. Look at the Debug Control window in the Globals section to see what the value of flips and heads are.

Click Go again and the program will continue until it reaches the next break point on line 16. Again, see how the values in flips and heads have changed.

If you click Go again, the execution will continue until the next break point is reached, which is on line 12.

Summary

Writing programs is only the first part of programming. The next part is making sure the code you wrote actually works. Debuggers let you step through the code one line at a time. You can examine which lines execute in what order, and what values the variables contain. When this is too slow, you can set break points to stop the debugger only at the lines you want.

Using the debugger is a great way to understand what a program is doing. While this book provides explanations of all the game code in it, the debugger can help you find out more on your own.
